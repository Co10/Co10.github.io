<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2015-12-03CSP-画图</title>
    <url>/2020/03/20/2015-12-03CSP-%E7%94%BB%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a><strong>画图</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　用 ASCII 字符来画图是一件有趣的事情，并形成了一门被称为 ASCII Art 的艺术。例如，下图是用 ASCII 字符画出来的 CSPRO 字样。</span><br><span class="line">　　..____.____..____..____...___..</span><br><span class="line">　　.&#x2F;.___&#x2F;.___||.._.\|.._.\.&#x2F;._.\.</span><br><span class="line">　　|.|...\___.\|.|_).|.|_).|.|.|.|</span><br><span class="line">　　|.|___.___).|..__&#x2F;|.._.&lt;|.|_|.|</span><br><span class="line">　　.\____|____&#x2F;|_|...|_|.\_\\___&#x2F;.</span><br><span class="line">　　本题要求编程实现一个用 ASCII 字符来画图的程序，支持以下两种操作：</span><br><span class="line">　　 画线：给出两个端点的坐标，画一条连接这两个端点的线段。简便起见题目保证要画的每条线段都是水平或者竖直的。水平线段用字符 - 来画，竖直线段用字符 | 来画。如果一条水平线段和一条竖直线段在某个位置相交，则相交位置用字符 + 代替。</span><br><span class="line">　　 填充：给出填充的起始位置坐标和需要填充的字符，从起始位置开始，用该字符填充相邻位置，直到遇到画布边缘或已经画好的线段。注意这里的相邻位置只需要考虑上下左右 4 个方向，如下图所示，字符 @ 只和 4 个字符 * 相邻。</span><br><span class="line">　　.*.</span><br><span class="line">　　*@*</span><br><span class="line">　　.*.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　第1行有三个整数m, n和q。m和n分别表示画布的宽度和高度，以字符为单位。q表示画图操作的个数。</span><br><span class="line">　　第2行至第q + 1行，每行是以下两种形式之一：</span><br><span class="line">　　 0 x1 y1 x2 y2：表示画线段的操作，(x1, y1)和(x2, y2)分别是线段的两端，满足要么x1 &#x3D; x2 且y1 ≠ y2，要么 y1 &#x3D; y2 且 x1 ≠ x2。</span><br><span class="line">　　 1 x y c：表示填充操作，(x, y)是起始位置，保证不会落在任何已有的线段上；c 为填充字符，是大小写字母。</span><br><span class="line">　　画布的左下角是坐标为 (0, 0) 的位置，向右为x坐标增大的方向，向上为y坐标增大的方向。这q个操作按照数据给出的顺序依次执行。画布最初时所有位置都是字符 .（小数点）。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　输出有n行，每行m个字符，表示依次执行这q个操作后得到的画图结果。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">4 2 3</span><br><span class="line">1 0 0 B</span><br><span class="line">0 1 0 2 0</span><br><span class="line">1 0 0 A</span><br><span class="line">Output: </span><br><span class="line">AAAA</span><br><span class="line">A--A</span><br><span class="line"></span><br><span class="line">input: </span><br><span class="line">16 13 9</span><br><span class="line">0 3 1 12 1</span><br><span class="line">0 12 1 12 3</span><br><span class="line">0 12 3 6 3</span><br><span class="line">0 6 3 6 9</span><br><span class="line">0 6 9 12 9</span><br><span class="line">0 12 9 12 11</span><br><span class="line">0 12 11 3 11</span><br><span class="line">0 3 11 3 1</span><br><span class="line">1 4 2 C</span><br><span class="line">output: </span><br><span class="line">................</span><br><span class="line">...+--------+...</span><br><span class="line">...|CCCCCCCC|...</span><br><span class="line">...|CC+-----+...</span><br><span class="line">...|CC|.........</span><br><span class="line">...|CC|.........</span><br><span class="line">...|CC|.........</span><br><span class="line">...|CC|.........</span><br><span class="line">...|CC|.........</span><br><span class="line">...|CC+-----+...</span><br><span class="line">...|CCCCCCCC|...</span><br><span class="line">...+--------+...</span><br><span class="line">................</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1.0 s</span><br><span class="line">Memory limit	256 MB</span><br></pre></td></tr></table></figure>
<h2 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a><strong>数据规模</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　所有的评测用例满足：2 ≤ m, n ≤ 100，0 ≤ q ≤ 100，0 ≤ x &lt; m（x表示输入数据中所有位置的x坐标），0 ≤ y &lt; n（y表示输入数据中所有位置的y坐标）。</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>画线就是一个for循环，if判断对就行，填充的思路就是DFS。</p>
<p>但是，这道题有些坑啊😵……</p>
<h3 id="横纵坐标问题"><a href="#横纵坐标问题" class="headerlink" title="横纵坐标问题"></a>横纵坐标问题</h3><p>输入是<code>0 ≤ x &lt; m, 0 ≤ y &lt; n</code>，然而用数组表示的话，要用<code>array[y][x]</code>来表示点的坐标，因为数组是<code>n</code>行<code>m</code>列的，<code>y</code>为行，列为<code>x</code>。<br>还有就是最后的输出，由于直角坐标第一象限左下角是起始端，然而二维数组左上角是起始端，所以输出要倒过来，第一维逆序遍历，第二维正序遍历。(样例2是水平对称的，但样例1竖直对称、水平不对称，很容易发现错误)</p>
<h3 id="画线交界问题"><a href="#画线交界问题" class="headerlink" title="画线交界问题"></a>画线交界问题</h3><p>题意应该是只要在边界内且遇到的不是<code>-</code>或<code>|</code>就可以直接覆盖，即使是遇到了填充字符串也可以覆盖，此处很容易漏了遇到<code>+</code>的话不能覆盖。<code>|</code>遇到<code>-</code>的话覆盖成<code>+</code>，<code>-</code>遇到|的话覆盖成<code>+</code>，遇到<code>+</code>不覆盖，这边比较容易的。<br>还有就是覆盖时for循环的结束条件。题目给的从一个点(<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>)到另一个点(<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>)，for循环就是由小到大或者由大到小，但是终止的时候是<code>&lt;= 或 &gt;= 结束点横/纵坐标</code>而不是<code>!= 结束点横/纵坐标</code>，这边这个<code>=</code>很容易遗漏。</p>
<h3 id="标记到达问题"><a href="#标记到达问题" class="headerlink" title="标记到达问题"></a>标记到达问题</h3><p>由于填充是可以覆盖的，从样例一可以看出，A把B覆盖了，所以每一次填充，<code>reach</code>数组都要重置。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">103</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> canvas[maxN][maxN];<span class="comment">//画布</span></span><br><span class="line"><span class="keyword">bool</span> reach[maxN][maxN];<span class="comment">//标记到达</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dot</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	dot(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y) :x(_x), y(_y) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 != y2) &#123;<span class="comment">// |</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">min</span>(y1, y2); i &lt;= <span class="built_in">max</span>(y1, y2); i++) &#123;<span class="comment">//这边&lt;=容易写成&lt;</span></span><br><span class="line">			<span class="keyword">if</span> (canvas[i][x1] == <span class="string">'-'</span>)<span class="comment">//有交叉</span></span><br><span class="line">				canvas[i][x1] = <span class="string">'+'</span>;</span><br><span class="line">			<span class="keyword">if</span> (canvas[i][x1] == <span class="string">'+'</span>)<span class="comment">//这个容易遗漏判断</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				canvas[i][x1] = <span class="string">'|'</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (y1 == y2 &amp;&amp; x1 != x2) &#123;<span class="comment">// -</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">min</span>(x1, x2); i &lt;= <span class="built_in">max</span>(x1, x2); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (canvas[y1][i] == <span class="string">'|'</span>)<span class="comment">//有交叉</span></span><br><span class="line">				canvas[y1][i] = <span class="string">'+'</span>;</span><br><span class="line">			<span class="keyword">if</span> (canvas[y1][i] == <span class="string">'+'</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				canvas[y1][i] = <span class="string">'-'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;<span class="comment">//右 左</span></span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;<span class="comment">//上 下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillCanvas</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> c, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">fill</span>(reach[i], reach[i] + m, <span class="literal">false</span>);<span class="comment">//每次都需要重置</span></span><br><span class="line"></span><br><span class="line">	<span class="function">dot <span class="title">ori</span><span class="params">(x, y)</span></span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;dot&gt; q;</span><br><span class="line">	q.push(ori);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		dot temp = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> xx = temp.x, yy = temp.y;</span><br><span class="line">		</span><br><span class="line">		canvas[yy][xx] = c;<span class="comment">//入了队的是一定能填充的</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;<span class="comment">//上下右左4个方向</span></span><br><span class="line">			<span class="keyword">int</span> xxx = temp.x + dx[i];</span><br><span class="line">			<span class="keyword">int</span> yyy = temp.y + dy[i];</span><br><span class="line">			<span class="function">dot <span class="title">temp2</span><span class="params">(xxx, yyy)</span></span>;</span><br><span class="line">			<span class="keyword">if</span> (xxx &gt;= <span class="number">0</span> &amp;&amp; xxx &lt; m &amp;&amp; yyy &gt;= <span class="number">0</span> &amp;&amp; yyy &lt; n</span><br><span class="line">				&amp;&amp; canvas[yyy][xxx] != <span class="string">'-'</span></span><br><span class="line">				&amp;&amp; canvas[yyy][xxx] != <span class="string">'+'</span></span><br><span class="line">				&amp;&amp; canvas[yyy][xxx] != <span class="string">'|'</span></span><br><span class="line">				&amp;&amp; reach[yyy][xxx] != <span class="literal">true</span>) &#123;<span class="comment">//在边界内 &amp;&amp; 不是画的线 &amp;&amp; 没到达</span></span><br><span class="line">				q.push(temp2);<span class="comment">//符合条件 可以入队</span></span><br><span class="line">				reach[yyy][xxx] = <span class="literal">true</span>;<span class="comment">//标记到达</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, n, q;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">fill</span>(canvas[i], canvas[i] + m, <span class="string">'.'</span>);</span><br><span class="line">		<span class="built_in">fill</span>(reach[i], reach[i] + m, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> ops;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; ops;</span><br><span class="line">		<span class="keyword">switch</span> (ops) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: &#123;<span class="comment">//画线</span></span><br><span class="line">			<span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">			drawLine(x1, y1, x2, y2);</span><br><span class="line">		&#125;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: &#123;<span class="comment">//填充</span></span><br><span class="line">			<span class="keyword">int</span> x, y;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			<span class="keyword">char</span> c;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">			fillCanvas(x, y, c, m, n);</span><br><span class="line">		&#125;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//y要记得倒序输出</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; canvas[i][j];</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>倒水问题</title>
    <url>/2020/03/05/%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="倒水问题"><a href="#倒水问题" class="headerlink" title="倒水问题"></a><strong>倒水问题</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“fill A” 表示倒满A杯，“empty A” 表示倒空A杯，“pour A B” 表示把A的水倒到B杯并且把B杯倒满或A倒空。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="input"><a href="#input" class="headerlink" title="input"></a><strong>input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入包含多组数据。每组数据输入 A, B, C 数据范围 0 &lt; A ≤ B 、C ≤ B ≤ 1000 、A和B互质。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你的程序的输出将由一系列的指令组成。这些输出行将导致任何一个罐子正好包含C单位的水。每组数据的最后一行输出应该是“success”。输出行从第1列开始，不应该有空行或任何尾随空格。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input: </span><br><span class="line">2 7 5</span><br><span class="line">2 7 4</span><br><span class="line"></span><br><span class="line">output: </span><br><span class="line">fill B</span><br><span class="line">pour B A</span><br><span class="line">success </span><br><span class="line">fill A</span><br><span class="line">pour A B</span><br><span class="line">fill A</span><br><span class="line">pour A B</span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>两水杯(a容量与b容量)中加水/倒水/相互倒水，目标为c容量，由于题目不会给出错误数据，所以直接暴力执行循环即可。</p>
<p>首先装满A，判断是否满足C，满足则success，否则不断地往B中倒水，不停的判断当前A、B的情况是否满足C，若满足则<code>break</code>，否则继续循环。循环过程中若有一方满了，则判断是否满足C，不满足清空满的杯子，继续循环。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, c;</span><br><span class="line">	<span class="keyword">int</span> x, y;<span class="comment">// a, b当前水量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c).eof()) &#123;</span><br><span class="line">		x = y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"fill A"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//先装满a</span></span><br><span class="line">			x = a;<span class="comment">//a当前容量为a 赋值给x</span></span><br><span class="line">			<span class="keyword">if</span> (x == c) &#123;<span class="comment">//若a达到目的</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"success"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;<span class="comment">//a非空时执行循环</span></span><br><span class="line">				<span class="keyword">if</span> ((b - y) &gt;= x) &#123;<span class="comment">// 若b当前可容下当前的a</span></span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"pour A B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					y = y + x;<span class="comment">//更新当前b</span></span><br><span class="line">					x = <span class="number">0</span>;<span class="comment">//当前a为0</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;<span class="comment">//若容不下</span></span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"pour A B"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//还是a倒给b</span></span><br><span class="line">					x = x - (b - y);<span class="comment">// a中也有剩余</span></span><br><span class="line">					y = b;<span class="comment">// b就满了</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (x == c) &#123;<span class="comment">//判断 若达到目的</span></span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"success"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (y == c)<span class="comment">//当前b达到目的</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (y == b) &#123;<span class="comment">//若b满</span></span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"empty B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					y = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (x == c)<span class="comment">//重复 不输出</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (y == c) &#123;<span class="comment">//若b打到目的</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"success"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尝试过的错误代码"><a href="#尝试过的错误代码" class="headerlink" title="尝试过的错误代码"></a><strong>尝试过的错误代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, c;</span><br><span class="line">	<span class="keyword">while</span> (!(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c).eof()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a == c) &#123;<span class="comment">//若目标水量为 a</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"fill A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"success"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (c % a == <span class="number">0</span> &amp;&amp; a != c) &#123;<span class="comment">//若目标水量为a的倍数</span></span><br><span class="line">			<span class="keyword">int</span> countA = c / a;<span class="comment">//这样子a往b中倒c/a次就行了</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countA; i++) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"fill A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"pour A B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"success"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (b == c) &#123;<span class="comment">//若目标水量为b</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"fill B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"success"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//从b满开始算 若目标水量是从b中扣除整数个a的量</span></span><br><span class="line">		<span class="keyword">if</span> ((b - c) % a == <span class="number">0</span> &amp;&amp; b != c) &#123;</span><br><span class="line">			<span class="keyword">int</span> countB = (b - c) / a;<span class="comment">//扣除次数</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"fill B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">if</span> (countB == <span class="number">1</span>)<span class="comment">//若只需1次</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"pour B A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//否则 要清空a</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countB - <span class="number">1</span>; i++) &#123;</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"pour B A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"empty A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"pour B A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"success"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码忽略了用A把B装满，要装满的最后一次A中还剩水量恰好为C的情况，比如<code>A = 3, B = 13, C = 2</code>。后来换了其他思路想，未提交新情况的代码测试，所以未知是否能通过。</p>
<h2 id="Google后其他人的思路"><a href="#Google后其他人的思路" class="headerlink" title="Google后其他人的思路"></a><strong>Google后其他人的思路</strong></h2><p>只有6种状态：<code>fill A</code>、<code>fill B</code>、<code>empty A</code>、<code>empty B</code>、<code>pour A B</code>、<code>pour B A</code>，每次做出一次选择。这是一个隐式迷宫问题，每次在一个状态做出6种选择，判断是否到达“出口”，因此可采用BFS解题。</p>
]]></content>
      <tags>
        <tag>倒水问题</tag>
      </tags>
  </entry>
  <entry>
    <title>传染病</title>
    <url>/2020/03/27/%E4%BC%A0%E6%9F%93%E7%97%85/</url>
    <content><![CDATA[<h1 id="COVID-19传染病"><a href="#COVID-19传染病" class="headerlink" title="COVID-19传染病"></a><strong>COVID-19传染病</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果一个感染者走入一个群体，那么这个群体需要被隔离。</span><br><span class="line">小A同学被确诊为新冠感染，并且没有戴口罩！</span><br><span class="line">需要尽快找到所有和小A同学直接或者间接接触过的同学，将他们隔离，防止更大范围的扩散。</span><br><span class="line">众所周知，学生的交际可能是分小团体的，一位学生可能同时参与多个小团体内。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多组数据，对于每组测试数据：</span><br><span class="line">第一行为两个整数n和m（n &#x3D; m &#x3D; 0表示输入结束，不需要处理），n 是学生的数量，m 是学生群体的数量。0 &lt; n ≤ 30000 ， 0 ≤ m ≤ 500</span><br><span class="line">学生编号为0~ n-1</span><br><span class="line">小A编号为0</span><br><span class="line">随后，m 行，每行有一个整数 num 即小团体人员数量。随后有 num 个整数代表这个小团体的学生。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出要隔离的人数，每组数据的答案输出占一行</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">100 4</span><br><span class="line">2 1 2</span><br><span class="line">5 10 13 11 12 14</span><br><span class="line">2 0 1</span><br><span class="line">2 99 2</span><br><span class="line">200 2</span><br><span class="line">1 5</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	20000 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>并查集：并：合并两个集合，将元素A作为元素B的父节点；查：确定两个元素是否属于同一集合，每次查找当前节点的父节点，直到遇到根节点，如果两个元素的根节点相同，则它们属于同一集合。</p>
<p>初始化每个成员都属于一个只包括自己的集合，并以自己为代表元素，然后根据题目条件逐一合并集合。</p>
<p>用一个<code>Rank[]</code>数组来维护集合的秩，避免“大树”挂在“小树”上面，使得树更高。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">30005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[maxN];</span><br><span class="line"><span class="keyword">int</span> Rank[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		par[i] = i;</span><br><span class="line">		Rank[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (par[x] == x)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	x = <span class="built_in">find</span>(x);</span><br><span class="line">	y = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x == y)<span class="comment">//同一集合</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (Rank[x] &gt; Rank[y])</span><br><span class="line">		swap(x, y);<span class="comment">//避免大的挂在小的名下</span></span><br><span class="line">	par[x] = y;</span><br><span class="line">	Rank[x] += Rank[y];</span><br><span class="line">	Rank[y] = Rank[x];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span> (scanf_s(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		initial(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> num;</span><br><span class="line">			scanf_s(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">			<span class="keyword">int</span> ori;</span><br><span class="line">			scanf_s(<span class="string">"%d"</span>, &amp;ori);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; num; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> a;</span><br><span class="line">				scanf_s(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">				unit(ori, a);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> res = Rank[<span class="built_in">find</span>(<span class="number">0</span>)];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>DDL-贪婪算法</title>
    <url>/2020/03/19/DDL-%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="DDL问题"><a href="#DDL问题" class="headerlink" title="DDL问题"></a><strong>DDL问题</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有 n 个作业，每个作业都有自己的 DDL，如果没有在 DDL 前做完这个作业，那么老师会扣掉这个作业的全部平时分。如何安排做作业的顺序，才能尽可能少扣一点分？</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入包含 T 个测试用例。输入的第一行是单个整数 T，为测试用例的数量。</span><br><span class="line">每个测试用例以一个正整数 N 开头(1 ≤ N ≤ 1000)，表示作业的数量。</span><br><span class="line">然后两行。第一行包含 N 个整数，表示 DDL，下一行包含 N 个整数，表示扣的分。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于每个测试用例，您应该输出最小的总降低分数，每个测试用例一行。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">3 3 3</span><br><span class="line">10 5 1</span><br><span class="line">3</span><br><span class="line">1 3 1</span><br><span class="line">6 2 3</span><br><span class="line">7</span><br><span class="line">1 4 6 4 2 4 3</span><br><span class="line">3 2 1 7 6 5 4</span><br><span class="line">Output: </span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	32768 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>将扣的分数降序排列，第二关键字按DDL降序排列，然后按照时间线从后往前遍历，并用<code>reach</code>数组标记当天是否被其他作业占用，这样可以保证被扣的分最少，因为每次都优先安排分值大的，且从最晚的DDL往较近的日子安排，这样可以保证后面的晚的DDL对早的DDL的影响最小。</p>
<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>对于时间，我们总是思维定式从前往后，然而本题将时间“倒流”求解，容易得出答案。(助教课上如果没说的话我还真不会往这方面思考🤯)</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ddl;<span class="comment">//due</span></span><br><span class="line">	<span class="keyword">int</span> s;<span class="comment">//due后扣的分</span></span><br><span class="line">	score()&#123; &#125;</span><br><span class="line">	score(<span class="keyword">int</span> _ddl, <span class="keyword">int</span> _s) :ddl(_ddl), s(_s) &#123;  &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> score sc)<span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (s == sc.s)</span><br><span class="line">			<span class="keyword">return</span> ddl &gt; sc.ddl;</span><br><span class="line">		<span class="keyword">return</span> s &gt; sc.s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(score a, score b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">result</span><span class="params">(score* ddl, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> reach[<span class="number">10000</span>];<span class="comment">//标记在哪天是否做了作业</span></span><br><span class="line">	<span class="built_in">memset</span>(reach, <span class="number">0</span>, <span class="number">10000</span>);</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = ddl[i].ddl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> setdown = <span class="literal">false</span>;<span class="comment">//标记某作业是否完成</span></span><br><span class="line">		<span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;<span class="comment">//从第x天(也就是DDL)开始安排 可安排就安置</span></span><br><span class="line">			<span class="keyword">if</span> (reach[x] == <span class="number">0</span>) &#123;<span class="comment">//有空</span></span><br><span class="line">				reach[x] = <span class="number">1</span>;<span class="comment">//占用当天</span></span><br><span class="line">				setdown = <span class="literal">true</span>;<span class="comment">//做了这个作业</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			x--;<span class="comment">//不然继续往前一天看看是否可安排</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (setdown == <span class="literal">false</span>)<span class="comment">//若前面这些天都被占用了</span></span><br><span class="line">			sum += ddl[i].s;<span class="comment">//无法完成作业 扣分</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;<span class="comment">//t组数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;<span class="comment">//n个DDL</span></span><br><span class="line">		<span class="keyword">int</span>* arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">5</span>];</span><br><span class="line">		<span class="keyword">int</span>* arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">5</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr1[j];<span class="comment">//DDL</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr2[j];<span class="comment">//分</span></span><br><span class="line"></span><br><span class="line">		score* DDL = <span class="keyword">new</span> score[n + <span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;<span class="comment">//整理DDL跟分 存入结构体方便记录</span></span><br><span class="line">			<span class="function">score <span class="title">sc</span><span class="params">(arr1[j], arr2[j])</span></span>;</span><br><span class="line">			DDL[j] = sc;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(DDL, DDL + n, cmp);<span class="comment">//按扣的分数降序 第二关键字按DDL降序</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result(DDL, n) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//丢入函数处理</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪婪算法</tag>
      </tags>
  </entry>
  <entry>
    <title>4数列选数问题</title>
    <url>/2020/03/19/4%E6%95%B0%E5%88%97%E9%80%89%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="四数列选数问题"><a href="#四数列选数问题" class="headerlink" title="四数列选数问题"></a><strong>四数列选数问题</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有四个数列 A, B, C, D，每个数列都有 n 个数字。从每个数列中各取出一个数，有多少种方案使得 4 个数的和为 0 ？</span><br><span class="line">(当一个数列中有多个相同的数字的时候，把它们当做不同的数对待。)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行：n (代表数列中数字的个数) (1 ≤ n ≤ 4000)</span><br><span class="line">接下来的 n 行中，第 i 行有四个数字，分别表示数列 A, B, C, D 中的第 i 个数字 (数字不超过 2 的 28 次方)</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出不同组合的个数。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">6</span><br><span class="line">-45 22 42 -16</span><br><span class="line">-41 -27 56 30</span><br><span class="line">-36 53 -37 77</span><br><span class="line">-36 30 -75 -46</span><br><span class="line">26 -38 -10 62</span><br><span class="line">-32 -54 -6 45</span><br><span class="line">Output: </span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		15000 ms</span><br><span class="line">Case time limit	5000 ms</span><br><span class="line">Memory limit	228000 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>有4个数列，用4重<code>for</code>循环暴力求解的话，时间复杂度为<em>O</em>(<em>n</em><sup>4</sup>)，一定会超时，所以要进行优化。</p>
<p>题意很明显求和为0，两个相反数相加为0，因此可以把4个数列优化成2个数列：A和B、C和D依次通过 <em>n</em><sup>2</sup> 次相加得到数列 E(A和B产生)和 F(C和D产生)，然后对F中的每一个数求相反数，A再从新F中找到相同的数即可。时间复杂度优化为<em>O</em>(<em>n</em><sup>2</sup>)。</p>
<p>优化查找效率：二分搜索。<br>标记始末，求得中间，把中间数与目标对比，大则将末改成中间-1，小则将始改成中间+1，循环搜索，直至始末相遇或找到目标。<br>这道题要标记的是有序数组中目标出现的第一个位置，然后从那个位置开始求多少个相同值，就表示有多少个方案，再对这些方案数求和就是答案。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*二分查找 是否存在那个数</span></span><br><span class="line"><span class="comment">  从两端开始往目标逼近*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> first = <span class="number">0</span>, last = n - <span class="number">1</span>, middle;</span><br><span class="line">	<span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (!found &amp;&amp; first &lt;= last) &#123;</span><br><span class="line">		middle = (first + last) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[middle] == x)</span><br><span class="line">			found = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[middle] &gt; x)</span><br><span class="line">			last = middle - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[middle] &lt; x)</span><br><span class="line">			first = middle + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*找到那个数第一次出现的位置*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFirst</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> first = <span class="number">0</span>, last = n - <span class="number">1</span>, middle;</span><br><span class="line">	<span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">		middle = (first + last) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[middle] &lt; x)</span><br><span class="line">			first = middle + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			last = middle;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*其实上面两个二分搜索可以合并成一个的……</span></span><br><span class="line"><span class="comment">  就是后来懒得改了……*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从那个数的位置开始 计算那个数在有序数组中出现了几次*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountNum</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> x, <span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] != x)</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//及时停止</span></span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span>* arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>];<span class="comment">//A</span></span><br><span class="line">	<span class="keyword">int</span>* arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>];<span class="comment">//B</span></span><br><span class="line">	<span class="keyword">int</span>* arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>];<span class="comment">//C</span></span><br><span class="line">	<span class="keyword">int</span>* arr4 = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>];<span class="comment">//D</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr1[i];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr2[i];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr3[i];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr4[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span>* a1 = <span class="keyword">new</span> <span class="keyword">int</span>[n * n + <span class="number">10</span>];<span class="comment">//A和B → E</span></span><br><span class="line">	<span class="keyword">int</span>* a2 = <span class="keyword">new</span> <span class="keyword">int</span>[n * n + <span class="number">10</span>];<span class="comment">//C和D → F</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			a1[count] = arr1[i] + arr2[j];</span><br><span class="line">			a2[count] = (<span class="number">-1</span>) * (arr3[i] + arr4[j]);<span class="comment">//这边直接求相反数</span></span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort(a2, a2 + n * n);<span class="comment">//要先进行排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> numCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * n; i++) &#123;<span class="comment">//遍历</span></span><br><span class="line">		<span class="keyword">if</span> (findNum(a1[i], a2, n * n) == <span class="literal">true</span>) &#123;<span class="comment">//如果有</span></span><br><span class="line">			<span class="keyword">int</span> first = findFirst(a1[i], a2, n * n);<span class="comment">//找到第一次出现的位置</span></span><br><span class="line">			numCount += CountNum(first, a1[i], a2, n * n);<span class="comment">//计数 出现几次 求和</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; numCount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>公园长凳</title>
    <url>/2020/04/17/%E5%85%AC%E5%9B%AD%E9%95%BF%E5%87%B3/</url>
    <content><![CDATA[<h1 id="公园长凳"><a href="#公园长凳" class="headerlink" title="公园长凳"></a><strong>公园长凳</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">公园有 x 条长凳。第 i 个长凳上坐着 ai 个人。这时候又有 y 个人将来到公园，他们将选择坐在某些公园中的长凳上，那么当这 y 个人坐下后，记 k &#x3D; 所有椅子上的人数的最大值，那么 k 可能的最大值 mx 和最小值 mn 分别是多少。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行包含一个整数 x (1 ≤ x ≤ 100) 表示公园中长椅的数目</span><br><span class="line">第二行包含一个整数 y (1 ≤ y ≤ 1000) 表示有 y 个人来到公园</span><br><span class="line">接下来 x 个整数 ai (1 ≤ ai ≤ 100)，表示初始时公园长椅上坐着的人数</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出 mn 和 mx</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">6 13</span><br><span class="line"></span><br><span class="line">Explain:</span><br><span class="line">最初三张椅子的人数分别为 1 6 1</span><br><span class="line">接下来来了 7 个人。</span><br><span class="line">可能出现的情况为 &#123;1, 6, 8&#125;, &#123;1, 7, 7&#125;, …, &#123;8, 6, 1&#125;</span><br><span class="line">相对应的 k 分别为 8, 7, …, 8</span><br><span class="line">其中，状态 &#123;1, 13, 1&#125; 的 k &#x3D; 13，为 mx</span><br><span class="line">状态 &#123;4, 6, 5&#125; 和状态 &#123;5, 6, 4&#125; 的 k &#x3D; 6，为 mn</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	262144 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>咋一看，貌似挺简单，直接对 <em>x</em><sub><em>i</em></sub> 排序，则 mx = <em>x</em><sub>max</sub> + <em>y</em>，mn = <em>x</em><sub>min</sub> + <em>y</em>，太简单了……后来写着写着猛地发现想错了，去看了下样例解释：emm，原来没那么简单。</p>
<p>不过mx求法挺简单的，就是 mx = <em>x</em><sub>max</sub> + <em>y</em>，mn 麻烦了点而已。</p>
<p>不难发现，<em>x</em><sub><em>i</em></sub> 排序后可以看作非减的一排柱形图，可以用 <em>y</em> (分割成 <em>n</em> 个部分)对其填充，记 <em>temp</em> = 所有柱子填充成最高柱子所需的量，则有两种情况：<em>y</em> 够分配给 <em>temp</em>；<em>y</em> 不够分配给 <em>temp</em>。如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/20/B893IjctAs54gdQ.png" alt="bench_001.png"></p>
<p>对于 <em>y</em> ≤ <em>temp</em>，则 mn = <em>x</em><sub>max</sub>；对于 <em>y</em> &gt; <em>temp</em>，mn = <em>x</em><sub>max</sub> + ⌈超出部分/<em>x</em>⌉。</p>
<p>所以这题也不难啊。</p>
<p>不过<code>WA</code>了一次，原因是我没对<code>差值结果/x</code>取<code>double</code>再取<code>ceil</code>，而是直接<code>int</code>取<code>ceil</code>，相当于没取<code>ceil</code>，没用。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		v.push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> theMAX = v[v.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> mn, mx;</span><br><span class="line">	mx = y + theMAX;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); i++)</span><br><span class="line">		temp += (theMAX - v[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (temp &gt;= y)</span><br><span class="line">		mn = theMAX;</span><br><span class="line">	<span class="keyword">if</span> (temp &lt; y) &#123;</span><br><span class="line">		<span class="keyword">int</span> overFlow = y - temp;</span><br><span class="line">		<span class="keyword">int</span> incrs = <span class="built_in">ceil</span>((<span class="keyword">double</span>) overFlow / x);</span><br><span class="line">		mn = theMAX + incrs;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; mn &lt;&lt; <span class="string">" "</span> &lt;&lt; mx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>区间选点Plus</title>
    <url>/2020/04/14/%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9Plus/</url>
    <content><![CDATA[<h1 id="区间选点Plus"><a href="#区间选点Plus" class="headerlink" title="区间选点Plus"></a><strong>区间选点Plus</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数轴上的 n 个区间，要求在数轴上选取最少的点使得第 i 个区间 [ai, bi] 里至少有 ci 个点。</span><br><span class="line">使用差分约束系统的解法解决这道题。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入第一行一个整数 n 表示区间的个数，接下来的 n 行，每一行两个用空格隔开的整数 a, b 表示区间的左右端点。1 ≤ n ≤ 50000， 0 ≤ ai ≤ bi ≤ 50000 并且 1 ≤ ci ≤ bi - ai + 1。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出一个整数表示最少选取的点的个数</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">5</span><br><span class="line">3 7 3</span><br><span class="line">8 10 3</span><br><span class="line">6 8 1</span><br><span class="line">1 3 1</span><br><span class="line">10 11 1</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		2000 ms</span><br><span class="line">Memory limit	65536 kb</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><h3 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h3><p>差分约束系统中的每个约束条件$x_i - x_j ≤ c_k$都可变形成$x_i ≤ x_j + c_k$，这与单源最短路中的不等式dis[u] ≤ dis[v] + w非常相似。因此可以把 <em>x</em><sub><em>i</em></sub> 看作图中的节点，$x_i - x_j ≤ c_k$表示从节点 <em>i</em> 到节点 <em>j</em> 的一条权值为<em>c</em><sub><em>k</em></sub>的有向边。</p>
<p>设<code>dis[0] = 0</code>并向每一个点连一条边，跑单源最短路，若图中存在负环，则给定的差分约束系统无解，否则， <em>x</em><sub><em>i</em></sub> = dis[<em>i</em>]为该差分约束系统的一组解。</p>
<p>求存在负边的单源最短路可以用SPFA。</p>
<h3 id="本题解法"><a href="#本题解法" class="headerlink" title="本题解法"></a>本题解法</h3><p>用一个前缀和<code>sum[i]</code>表示区间<code>[begin, i]</code>之内选取的点的个数，则<code>sum[b] - sum[a] ≥ c</code>表示区间<code>[a, b]</code>内至少选取了<code>c</code>个点，<code>sum[i] - sum[i - 1]</code>表示第 <code>i</code> 个点选或不选，因此可以转化成差分约束的形式。</p>
<p><em>n</em> 个区间，可以看成 <em>n</em> 个差分约束，由 <em>a</em><sub><em>i</em></sub> 到 <em>b</em><sub><em>i</em></sub> + 1 的边，权重为 <em>c</em><sub><em>i</em></sub> ，加入到图中，但是并不能保证图的联通，因此每一个相邻的点之间要加入有向边<code>(i, i + 1, 0)</code>和<code>(i + 1, i, -1)</code>，即差分约束<code>0 ≤ sum[i + 1] - sum[i] ≤ 1</code>，即表示第 <code>i + 1</code> 个点选/不选(存在/不存在)。</p>
<p>本题求下界，所以SPFA要跑最长路，从所有区间的最左端点跑到最右端点即可。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ele;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	node* next;</span><br><span class="line">	node() &#123; ele = <span class="number">-1</span>; w = <span class="number">-2</span>; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">	node(<span class="keyword">int</span> e, <span class="keyword">int</span> _w) :ele(e), w(_w) &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	node* header;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	linkedList() &#123; header = <span class="literal">NULL</span>; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">	~linkedList() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size</span>; &#125;</span><br><span class="line">	<span class="function">node* <span class="title">getHeader</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> ele, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		node* p = <span class="keyword">new</span> node(ele, w);</span><br><span class="line">		<span class="keyword">if</span> (header == <span class="literal">NULL</span>)</span><br><span class="line">			header = p;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			node* temp = header;</span><br><span class="line">			node* temp2 = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				temp2 = temp;</span><br><span class="line">				temp = temp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			temp2-&gt;next = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">size</span>++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		node* temp = header;</span><br><span class="line">		node* ttemp = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			ttemp = temp;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">			ttemp = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		header = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">delete</span> temp;</span><br><span class="line">		<span class="keyword">delete</span> ttemp;</span><br><span class="line">		<span class="keyword">delete</span> header;</span><br><span class="line">		<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxSize = <span class="number">50050</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	linkedList arr[maxSize];</span><br><span class="line">	<span class="keyword">int</span> dis[maxSize];</span><br><span class="line">	<span class="keyword">int</span> vis[maxSize];</span><br><span class="line">	<span class="keyword">int</span> dots;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	graph() &#123; </span><br><span class="line">		dots = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dis, -maxN, maxSize);</span><br><span class="line">		<span class="built_in">memset</span>(vis, <span class="number">0</span>, maxSize);</span><br><span class="line">	&#125;</span><br><span class="line">	graph(<span class="keyword">int</span> n) &#123; </span><br><span class="line">		dots = n;</span><br><span class="line">		<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dis, -maxN, maxSize);</span><br><span class="line">		<span class="built_in">memset</span>(vis, <span class="number">0</span>, maxSize);</span><br><span class="line">	&#125;</span><br><span class="line">	~graph() &#123;  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		arr[u].add(v, w);</span><br><span class="line">		<span class="built_in">size</span>++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= dots; i++) &#123;</span><br><span class="line">			dis[i] = -maxN;</span><br><span class="line">			vis[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dis[s] = <span class="number">0</span>;</span><br><span class="line">		vis[s] = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">		q.push(s);</span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			vis[x] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (node* p = arr[x].getHeader(); p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">				<span class="keyword">int</span> w = p-&gt;w;</span><br><span class="line">				<span class="keyword">int</span> v = p-&gt;ele;</span><br><span class="line">				<span class="keyword">if</span> (dis[v] &lt; dis[x] + w) &#123;</span><br><span class="line">					dis[v] = dis[x] + w;</span><br><span class="line">					<span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">						q.push(v);</span><br><span class="line">						vis[v] = <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dis[e];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	scanf_s(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="function">graph <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> left = maxN, right = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b, c;</span><br><span class="line">		scanf_s(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		G.add(a, b + <span class="number">1</span>, c);</span><br><span class="line">		left = <span class="built_in">min</span>(left, a);</span><br><span class="line">		right = <span class="built_in">max</span>(right, b + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">		G.add(i + <span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line">		G.add(i, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ans = G.spfa(left, right);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>差分约束</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title>农田引水</title>
    <url>/2020/03/28/%E5%86%9C%E7%94%B0%E5%BC%95%E6%B0%B4/</url>
    <content><![CDATA[<h1 id="农田引水"><a href="#农田引水" class="headerlink" title="农田引水"></a><strong>农田引水</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">农田有 n 块，编号从 1~n。种田要灌水。</span><br><span class="line">众所周知东东是一个魔法师，他可以消耗一定的 MP 在一块田上施展魔法，使得黄河之水天上来。他也可以消耗一定的 MP 在两块田的渠上建立传送门，使得这块田引用那块有水的田的水。(1 ≤ n ≤ 300)</span><br><span class="line">黄河之水天上来的消耗是 Wi，i 是农田编号 (1 ≤ Wi ≤ 1e5)</span><br><span class="line">建立传送门的消耗是 Pij，i、j 是农田编号 (1 ≤ Pij ≤ 1e5, Pij &#x3D; Pji, Pii &#x3D; 0)</span><br><span class="line">求为所有的田灌水的最小消耗。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第 1 行：一个数 n</span><br><span class="line">第 2 行到第 n + 1 行：数 wi</span><br><span class="line">第 n + 2 行到第 2n + 1 行：矩阵即 pij 矩阵</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最小消耗的MP值</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">0 2 2 2</span><br><span class="line">2 0 3 3</span><br><span class="line">2 3 0 4</span><br><span class="line">2 3 4 0</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	262144 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>可以将“天上来”作为源点，即第0号农田到第 i 号农田灌水需要消耗的MP值，因此样例的数组可变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">				0 5 4 4 3</span><br><span class="line">0 2 2 2			5 0 2 2 2</span><br><span class="line">2 0 3 3		→	4 2 0 3 3</span><br><span class="line">2 3 0 4		 	4 2 3 0 4</span><br><span class="line">2 3 4 0			3 2 3 4 0</span><br></pre></td></tr></table></figure>
<p>本题就变成了最小生成树问题，可以用Kruskal算法:<br>将所有的边按边权升序排列，每次加入最小权的边到生成树中，保证加入的边在该连通图中，且不会生成环，直到最小生成树中的边数等于总顶点数减1。</p>
<p>这些权重之和就是答案。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">305</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u, v, w;</span><br><span class="line">	edge(<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _w) :u(_u), v(_v), w(_w) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (par[x] == x)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;edge&gt; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> edgeCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">		par[i] = i;</span><br><span class="line">	sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> p1 = <span class="built_in">find</span>(v[i].u);</span><br><span class="line">		<span class="keyword">int</span> p2 = <span class="built_in">find</span>(v[i].v);</span><br><span class="line">		<span class="keyword">if</span> (p1 != p2) &#123;<span class="comment">//并查集保证不会生成环</span></span><br><span class="line">			par[p1] = p2;</span><br><span class="line">			ans += v[i].w;</span><br><span class="line">			edgeCount++;</span><br><span class="line">			<span class="keyword">if</span> (edgeCount == n)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;edge&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		<span class="function">edge <span class="title">e1</span><span class="params">(<span class="number">0</span>, i, a)</span></span>;</span><br><span class="line">		<span class="function">edge <span class="title">e2</span><span class="params">(i, <span class="number">0</span>, a)</span></span>;</span><br><span class="line">		v.push_back(e1);</span><br><span class="line">		v.push_back(e2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> a;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">			<span class="keyword">if</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="function">edge <span class="title">e</span><span class="params">(i, j, a)</span></span>;</span><br><span class="line">				v.push_back(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = kruskal(n, v);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>咕咕东想吃饭</title>
    <url>/2020/03/19/%E5%92%95%E5%92%95%E4%B8%9C%E6%83%B3%E5%90%83%E9%A5%AD/</url>
    <content><![CDATA[<h1 id="咕咕东想吃饭"><a href="#咕咕东想吃饭" class="headerlink" title="咕咕东想吃饭"></a><strong>咕咕东想吃饭</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">咕咕东考试周开始了，考试周⼀共有n天。他不想考试周这么累，于是打算每天都吃顿好的。他决定每天都吃生煎，咕咕东每天需要买ai个生煎。</span><br><span class="line">但是生煎店为了刺激消费，只有两种购买⽅式：</span><br><span class="line">①在某⼀天⼀次性买两个生煎。</span><br><span class="line">②今天买⼀个生煎，同时为明天买⼀个生煎，店家会给⼀个券，第⼆天用券来拿。</span><br><span class="line">没有其余的购买方式，这两种购买方式可以用无数次。但是咕咕东是个节俭的好孩⼦，他考试结束就走了，不允许考试结束时手里有券。咕咕东非常有钱，你不需要担心咕咕东没钱，但是咕咕东太笨了，他想问你他能否在考试周每天都能恰好买ai个生煎。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输⼊两⾏，第⼀行输⼊⼀个正整数 n (1 ≤ n ≤ 100000)，表示考试周的天数。</span><br><span class="line">第⼆行有n个数，第i个数ai表示第i天咕咕东要买的生煎的数量。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果可以满足咕咕东奇怪的要求，输出&quot;YES&quot;，如果不能满足，输出“NO”。（输出不带引号）</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">4 1 2 1 2 </span><br><span class="line">Output: </span><br><span class="line">YES</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">3 1 0 1</span><br><span class="line">Output: </span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	262144 kB</span><br></pre></td></tr></table></figure>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><div class="table-container">
<table>
<thead>
<tr>
<th>数据点</th>
<th><em>n</em> (上限)</th>
<th><em>a<sub>i</sub></em> (上限)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1, 2</td>
<td>10</td>
<td>≤ 10</td>
</tr>
<tr>
<td>3, 4, 5</td>
<td>1000</td>
<td>10</td>
</tr>
<tr>
<td>6, 7</td>
<td>10</td>
<td>10000</td>
</tr>
<tr>
<td>8, 9, 10</td>
<td>100000</td>
<td>10000</td>
</tr>
</tbody>
</table>
</div>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>比较容易，一个<code>for</code>循环再几个<code>if</code>条件判断就行了，复杂度<em>O</em>(<em>n</em>)。</p>
<p>每天都有两种选择，选择根据今天应该有的生煎数来选，初始时昨天预留的生煎数<code>remain = 0</code>，之后若有预留，则<code>remain = 1</code>。则 今日想买的生煎数 - remain 就是 今日应该要买的生煎数。<br>这两种选择，根据今日应买数量是否为2的倍数来判断，是则预留为0，否则预留为1。然后根据最后一天的剩余量判断就行。<br>这题比较容易出错的是0(题目说好的明明“决定每天都吃生煎”呢🤔🤨😐😑😶🙄)，还好样例2有给个0，不然我还真不会去考虑0的情况……若前一天有剩但今日为0，直接终止循环，输出NO。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	<span class="keyword">int</span> remain = <span class="number">0</span>;<span class="comment">//当日剩余生煎数</span></span><br><span class="line">	<span class="keyword">bool</span> failed = <span class="literal">false</span>;<span class="comment">//不能满足？</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a = arr[i] - remain;<span class="comment">//扣去前一天剩下的券(如果有) 今天还有的生煎数</span></span><br><span class="line">		<span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;<span class="comment">//昨天有剩券 但今天不想吃</span></span><br><span class="line">			failed = <span class="literal">true</span>;<span class="comment">//不能满足</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>)<span class="comment">//今天不需要买 券那个方案，选方案一</span></span><br><span class="line">			remain = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">1</span>)<span class="comment">//需要买张券，选方案二</span></span><br><span class="line">			remain = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (remain == <span class="number">0</span> &amp;&amp; failed == <span class="literal">false</span>)<span class="comment">//最后一天 没剩 且 之前都满足</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (remain == <span class="number">1</span> || failed == <span class="literal">true</span>)<span class="comment">//最后一天有剩 或 之前某天不满足</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>区间赋值</title>
    <url>/2020/03/24/%E5%8C%BA%E9%97%B4%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h1 id="区间赋值"><a href="#区间赋值" class="headerlink" title="区间赋值"></a><strong>区间赋值</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select n cities from the world map, and a[i] represents the asset value owned by the i-th city.</span><br><span class="line">Then there will be several operations. Each turn is to choose the city in the interval [l, r] and increase their asset value by c. And finally, it is required to give the asset value of each city after q operations. </span><br><span class="line">------------------------------------------------------</span><br><span class="line">从世界地图从选出 n 个城市，a[i]表示选出的第 i 个城市的值。</span><br><span class="line">接下来会有 q 个操作。每一次从区间[l, r]中选出城市，并把它们的值提高 c。</span><br><span class="line">最终求得各个城市的值。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The first line contains two integers n,q (1 ≤ n,q ≤ 2⋅10^5) — the number of cities and operations.</span><br><span class="line">The second line contains elements of the sequence a: integer numbers a1, a2, ..., an (−10^6 ≤ ai ≤ 10^6).</span><br><span class="line">Then q lines follow, each line represents an operation. The i-th line contains three integers l, r and c (1 ≤ l ≤ r ≤ n, −10^5 ≤ c ≤ 10^5) for the i-th operation.</span><br><span class="line">------------------------------------------------------</span><br><span class="line">第一行两个整数 n, q (1 ≤ n,q ≤ 2⋅10^5)，表示城市数和操作数。</span><br><span class="line">第二行 n 个整数，表示城市 a1, a2, ..., an (−10^6 ≤ ai ≤ 10^6)。</span><br><span class="line">接下来的 q 行，每一行代表一个操作，每一行包括3个整数 l, r 和 c (1 ≤ l ≤ r ≤ n, −10^5 ≤ c ≤ 10^5)。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Print n integers a1,a2,…,an one per line, and ai should be equal to the final asset value of the i-th city.</span><br><span class="line">------------------------------------------------------</span><br><span class="line">输出n个整数，a1, a2, …, an。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input: </span><br><span class="line">4 2</span><br><span class="line">-3 6 8 4</span><br><span class="line">4 4 -2</span><br><span class="line">3 3 1</span><br><span class="line">output: </span><br><span class="line">-3 6 9 2</span><br><span class="line"></span><br><span class="line">input: </span><br><span class="line">2 1</span><br><span class="line">5 -2</span><br><span class="line">1 2 4</span><br><span class="line">output: </span><br><span class="line">9 2</span><br><span class="line"></span><br><span class="line">input: </span><br><span class="line">1 2</span><br><span class="line">0</span><br><span class="line">1 1 -8</span><br><span class="line">1 1 -6</span><br><span class="line">output: </span><br><span class="line">-14</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	262144 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>q 次操作区间，每次对区间内每个数进行加/减操作，暴力做法就是每次赋值操作都来一个<code>for</code>循环，时间复杂度为<em>O</em>(<em>qn</em>)，考虑到数据范围，会超时。</p>
<p>这边就要用到差分跟前缀和。</p>
<p>差分：原数组第二个元素起，每个元素与前一元素之差形成一个新数组。如：<br>原数组<code>a[n]</code>, 新数组<code>b[n]</code>, <code>b[1] = a[1], b[i] = a[i] - a[i-1] (i ≥2)</code></p>
<p>前缀和可以在<em>O</em>(1)时间复杂度内求一个区域内所有元素之和，利用差分数组只进行单点修改，可以更新一个区域内的数值。</p>
<p>比如第一个样例，原数组<code>a[4] = {-3, 6, 8, 4}</code>, 差分数组<code>b[4] = {-3, 9, 2, -4}</code>。<br>第一次操作：第4个数降值2，<code>a&#39;[4] = {-3, 6, 8, 2}</code>, <code>b&#39;[4] = {-3, 9, 2, -6}</code>。<br>第二次操作：第3个数增值1，<code>a&#39;&#39;[4] = {-3, 6, 9, 2}</code>, <code>b&#39;&#39; = {-3, 9, 3, -7}</code>, 前缀和生成数组<code>c[4] = {-3, 6, 9, 2}</code>, 与<code>a&#39;&#39;</code>相同。</p>
<p>本题由于数据范围，如果使用<code>int</code>在test 17会<code>WA</code>，所以得用<code>long long</code>。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n, q;<span class="comment">//n个数 q个操作</span></span><br><span class="line">	scanf_s(<span class="string">"%lld%lld"</span>, &amp;n, &amp;q);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* arr = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[n + <span class="number">10</span>];<span class="comment">//原数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		scanf_s(<span class="string">"%lld"</span>, &amp;arr[i]);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* arr1 = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[n + <span class="number">10</span>];<span class="comment">//差分数组</span></span><br><span class="line">	arr1[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != n; i++)</span><br><span class="line">		arr1[i] = arr[i] - arr[i - <span class="number">1</span>];<span class="comment">//求得差分</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;<span class="comment">//q次操作</span></span><br><span class="line">		<span class="keyword">int</span> l, r, c;</span><br><span class="line">		scanf_s(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">		arr1[l - <span class="number">1</span>] += c;</span><br><span class="line">		arr1[r] -= c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* arr2 = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[n + <span class="number">10</span>];<span class="comment">//前缀和成数组</span></span><br><span class="line">	arr2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != n; i++)</span><br><span class="line">		arr2[i] = arr2[i - <span class="number">1</span>] + arr1[i];<span class="comment">//前缀和</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld "</span>, arr1[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld "</span>, arr2[i] + arr1[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前缀和</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>咕咕东的奇遇</title>
    <url>/2020/03/19/%E5%92%95%E5%92%95%E4%B8%9C%E7%9A%84%E5%A5%87%E9%81%87/</url>
    <content><![CDATA[<h1 id="咕咕东的奇遇"><a href="#咕咕东的奇遇" class="headerlink" title="咕咕东的奇遇"></a><strong>咕咕东的奇遇</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">咕咕东是个贪玩的孩⼦，有⼀天，他从上古遗迹中得到了⼀个神奇的圆环。这个圆环由字⺟表组成首尾相接的环，环上有⼀个指针，最初指向字⺟a。咕咕东每次可以顺时针或者逆时针旋转⼀格。例如，a顺时针旋转到z，逆时针旋转到b。咕咕东⼿⾥有⼀个字符串，但是他太笨了，所以他来请求你的帮助，问最少需要转多少次。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/03/20/EUz2RqGs89xToJu.png" alt="0001.png"></p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输⼊只有⼀行，是⼀个字符串。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出最少要转的次数。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">zeus</span><br><span class="line">Output: </span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	65536 kB</span><br></pre></td></tr></table></figure>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><div class="table-container">
<table>
<thead>
<tr>
<th>数据点</th>
<th>字符串长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>1, 2</td>
<td>≤ 10</td>
</tr>
<tr>
<td>3, 4, 5</td>
<td>≤ 100</td>
</tr>
<tr>
<td>6, 7, 8, 9, 10</td>
<td>≤ 10000</td>
</tr>
</tbody>
</table>
</div>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>简单题，起点为<code>a</code>，每次只有顺时针或者逆时针2种选择，而顺/逆时针判断条件是走的步数是否≤13，由于转盘是有序的，而走的步数可以通过字母表确定。利用<code>a - z</code>的<code>ASCII码</code>有序对应<code>97 - 122</code>，两者<code>ASCII</code>的差值+26再除26求余数即可确定步数，然后把起点标记为走到的那一个，如此循环，直至走完。</p>
<p>但是由于个人疏忽，<code>if</code>判断处有写<code>(差值+26)%26</code>，确定步数时却忘了<code>+26</code>直接进行<code>求余</code>，看着样例没问题，自己出样例又要费时间去算，就直接提交，然后<code>WA</code>了……分全没了……😭(赛后补题补上<code>+26</code>直接<code>AC</code>了……)</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//顺逆13n</span></span><br><span class="line">	<span class="keyword">char</span> start = <span class="string">'a'</span>;<span class="comment">//起始点为a</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">int</span> n = x.length();</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//总步数</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>;<span class="comment">//单次步数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (((x[i] - start + <span class="number">26</span>) % <span class="number">26</span>) &lt;= <span class="number">13</span>) &#123;<span class="comment">//逆时针</span></span><br><span class="line">			<span class="built_in">step</span> = (x[i] - start + <span class="number">26</span>) % <span class="number">26</span>;</span><br><span class="line">			count += <span class="built_in">step</span>;</span><br><span class="line">			start = x[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (((x[i] - start + <span class="number">26</span>) % <span class="number">26</span>) &gt; <span class="number">13</span>) &#123;<span class="comment">//顺时针</span></span><br><span class="line">			<span class="built_in">step</span> = <span class="number">26</span> - (x[i] - start + <span class="number">26</span>) % <span class="number">26</span>;</span><br><span class="line">			count += <span class="built_in">step</span>;</span><br><span class="line">			start = x[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>转盘问题</tag>
      </tags>
  </entry>
  <entry>
    <title>城市穿梭</title>
    <url>/2020/04/09/%E5%9F%8E%E5%B8%82%E7%A9%BF%E6%A2%AD/</url>
    <content><![CDATA[<h1 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a><strong>序列操作</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有 N 个商业城市，编号 1 ～ N，其中 1 号城市是首都。</span><br><span class="line">共有 M 条有向道路供商业城市相互往来。</span><br><span class="line">对每一个商业城市标记一个正整数，表示其繁荣程度，当有人沿道路从一个商业城市走到另一个商业城市时，会被收取 (目的地繁荣程度 – 出发地繁荣程度)^3 的税。</span><br><span class="line">求从首都出发，走到其他城市至少要交多少的税，如果总金额小于 3 或者无法到达请打出 &#39;?&#39;。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行输入 T，表明共有 T 组数据。（1 ≤ T ≤ 50）</span><br><span class="line">对于每一组数据，第一行输入 N，表示点的个数。（1 ≤ N ≤ 200）</span><br><span class="line">第二行输入 N 个整数，表示 1 ～ N 点的权值 a[i]。（0 ≤ a[i] ≤ 20）</span><br><span class="line">第三行输入 M，表示有向道路的条数。（0 ≤ M ≤ 100000）</span><br><span class="line">接下来 M 行，每行有两个整数 A B，表示存在一条 A 到 B 的有向道路。</span><br><span class="line">接下来给出一个整数 Q，表示询问个数。（0 ≤ Q ≤ 100000）</span><br><span class="line">每一次询问给出一个 P，表示求 1 号点到 P 号点的最少税费。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个询问输出一行，如果不可达或税费小于 3 则输出 &#39;?&#39;。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">6 7 8 9 10</span><br><span class="line">6</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">1 5</span><br><span class="line">5 4</span><br><span class="line">4 5</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">1 2 4 4 5 6 7 8 9 10</span><br><span class="line">10</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">1 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">7 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br><span class="line">2</span><br><span class="line">3 10</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">Case 1:</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">Case 2:</span><br><span class="line">?</span><br><span class="line">?</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		2000 ms</span><br><span class="line">Memory limit	32768 kb</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>含有负边的单源最短路问题，可以用Bellman-Ford算法解决。</p>
<h3 id="Bellman-Ford-Algorithm"><a href="#Bellman-Ford-Algorithm" class="headerlink" title="Bellman-Ford Algorithm"></a>Bellman-Ford Algorithm</h3><p>从源点<code>s</code>开始，用<code>dis[]</code>数组初始化距离。<code>dis[s] = 0</code>，<code>dis[v] = +∞ (v ≠ s)</code>。<br>反复对边集<code>E</code>中的每条边进行松弛操作，使得点集<code>V</code>中的每个顶点v的最短距离估计值逼近其最短距离，共运行<code>|V|-1</code>次。<br>判断<code>E</code>中的每一条边的两个端点是否收敛，若有端点未收敛则无解，否则就将从源点可到达的<code>v</code>加入到<code>dis[v]</code>中。</p>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">procedure <span class="title">BellmanFord</span><span class="params">(<span class="built_in">list</span> vertices, <span class="built_in">list</span> edges, vertex source)</span></span></span><br><span class="line"><span class="function">   <span class="comment">// 读入边和节点的列表并对distance和predecessor写入最短路径</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="comment">// 初始化图</span></span></span><br><span class="line"><span class="function">   <span class="keyword">for</span> each vertex v in vertices:</span></span><br><span class="line">       if v is source then distance[v] := 0</span><br><span class="line">       <span class="keyword">else</span> distance[v] := infinity</span><br><span class="line">       predecessor[v] := null</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对每一条边重复操作</span></span><br><span class="line">   <span class="keyword">for</span> i from <span class="number">1</span> to <span class="built_in">size</span>(vertices)<span class="number">-1</span>:</span><br><span class="line">       <span class="keyword">for</span> each edge (u, v) with weight w in edges:</span><br><span class="line">           <span class="keyword">if</span> distance[u] + w &lt; distance[v]:</span><br><span class="line">               distance[v] := distance[u] + w</span><br><span class="line">               predecessor[v] := u</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查是否有负权回路</span></span><br><span class="line">   <span class="keyword">for</span> each edge (u, v) with weight w in edges:</span><br><span class="line">       <span class="keyword">if</span> distance[u] + w &lt; distance[v]:</span><br><span class="line">           error <span class="string">"图包含具负权重的回路"</span></span><br></pre></td></tr></table></figure>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p><img src="https://i.loli.net/2020/04/19/wGkDTRb7ephASn6.png" alt="bford.png"></p>
<p>然而，Bellman-Ford算法的时间复杂度是<em>O</em>(|<em>V</em>|×|<em>E</em>|)，相比于Dijkstra太慢了，因此引入了队列优化的SPFA。</p>
<h3 id="Shortest-Path-Fast-Algorithm-SPFA"><a href="#Shortest-Path-Fast-Algorithm-SPFA" class="headerlink" title="Shortest Path Fast Algorithm (SPFA)"></a>Shortest Path Fast Algorithm (SPFA)</h3><p>SPFA总的期望时间复杂度为<em>O</em>(<em>n</em> log <em>n</em> log (<em>m</em>/<em>n</em>) + <em>m</em>)，基于实验获得的平均时间复杂度为<em>O</em>(2|<em>E</em>|)。(From <a href="[https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%BF%AB%E9%80%9F%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/最短路径快速算法">Wikipedia</a>))</p>
<p>给定一个加权有向图<code>G</code>，从源点<code>s</code>开始，求到每个顶点<code>v</code>的最短路径<code>dis[v]</code>。<br>基本思路与Bellman-Ford相同，只不过SPFA使用了队列维护备选节点，仅有节点被松弛后才会放入队列中。即如果这轮<code>dis[i]</code>没有被更新，那么下一轮就没有必要更新所有从<code>i</code>出发的边。如果某一点入队 <em>n</em> 次则说明有负环。</p>
<h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">procedure Shortest-Path-Faster-Algorithm(G, s)</span><br><span class="line"> <span class="number">1</span>    <span class="keyword">for</span> each vertex v ≠ <span class="function">s in <span class="title">V</span><span class="params">(G)</span></span></span><br><span class="line"><span class="function"> 2        <span class="title">d</span><span class="params">(v)</span> :</span>= ∞</span><br><span class="line"> <span class="number">3</span>    d(s) := <span class="number">0</span></span><br><span class="line"> <span class="number">4</span>    offer s into Q</span><br><span class="line"> <span class="number">5</span>    <span class="keyword">while</span> Q is not empty</span><br><span class="line"> <span class="number">6</span>        u := poll Q</span><br><span class="line"> <span class="number">7</span>        <span class="function"><span class="keyword">for</span> each <span class="title">edge</span> <span class="params">(u, v)</span> in <span class="title">E</span><span class="params">(G)</span></span></span><br><span class="line"><span class="function"> 8            <span class="keyword">if</span> <span class="title">d</span><span class="params">(u)</span> + <span class="title">w</span><span class="params">(u, v)</span> &lt; <span class="title">d</span><span class="params">(v)</span> then</span></span><br><span class="line"><span class="function"> 9                <span class="title">d</span><span class="params">(v)</span> :</span>= d(u) + w(u, v)</span><br><span class="line"><span class="number">10</span>                <span class="keyword">if</span> v is not in Q then</span><br><span class="line"><span class="number">11</span>                    offer v into Q</span><br></pre></td></tr></table></figure>
<h3 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h3><p>根据繁荣程度，求出各个边的权值。题目要求从1到 i 的最短路径。若不可到达、可到达但税收小于3且不存在负环、可到达但存在负环则输出’<code>?</code>‘。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, w;</span><br><span class="line">	edge* next;</span><br><span class="line">	edge() &#123; to = <span class="number">-1</span>; w = <span class="number">-1</span>; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">	edge(<span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">int</span> _w) :to(<span class="keyword">_t</span>), w(_w) &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	edge* head;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	linkedList() &#123; head = <span class="literal">NULL</span>; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">	~linkedList() &#123;</span><br><span class="line">		edge* temp = head;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			edge* p = temp;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">			p = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">delete</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">delete</span> temp;</span><br><span class="line">		head = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">edge* <span class="title">getFirst</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		edge* node = <span class="keyword">new</span> edge(to, w);</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			head = node;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		edge* p = head;</span><br><span class="line">		edge* pp = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			pp = p;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pp-&gt;next = node;</span><br><span class="line">		<span class="built_in">size</span>++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	linkedList arr[maxN];</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">	<span class="keyword">int</span> dis[maxN];</span><br><span class="line">	<span class="keyword">bool</span> visit[maxN];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	graph() &#123; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">	graph(<span class="keyword">int</span> n) :<span class="built_in">size</span>(n) &#123;  &#125;</span><br><span class="line">	~graph() &#123;  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		arr[a].add(b, w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (edge* temp = arr[x].getFirst(); temp != <span class="literal">NULL</span>; temp = temp-&gt;next) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = temp-&gt;to;</span><br><span class="line">			<span class="keyword">if</span> (!visit[y]) &#123;</span><br><span class="line">				visit[y] = <span class="literal">true</span>;</span><br><span class="line">				dfs(y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">		<span class="keyword">int</span> inq[maxN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="keyword">int</span> cnt[maxN] = &#123; <span class="number">0</span> &#125;;<span class="comment">//记录访问每个点经过边的次数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">			dis[i] = inf;</span><br><span class="line">			visit[i] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		q.push(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> p = q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			inq[p] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (edge* temp = arr[p].getFirst(); temp != <span class="literal">NULL</span>; temp = temp-&gt;next) &#123;</span><br><span class="line">				<span class="keyword">int</span> dest = temp-&gt;to;</span><br><span class="line">				<span class="keyword">int</span> weight = temp-&gt;w;</span><br><span class="line">				<span class="keyword">if</span> (visit[dest])</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span> (dis[dest] &gt; dis[p] + weight) &#123;</span><br><span class="line">					dis[dest] = dis[p] + weight;</span><br><span class="line">					cnt[dest] = cnt[p] + <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (cnt[dest] &gt;= <span class="built_in">size</span>) &#123;<span class="comment">//说明存在负环</span></span><br><span class="line">						visit[dest] = <span class="literal">true</span>;</span><br><span class="line">						dfs(dest);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (!inq[dest]) &#123;</span><br><span class="line">						q.push(dest);</span><br><span class="line">						inq[dest] = <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (visit[x] || dis[x] == inf || dis[x] &lt; <span class="number">3</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; dis[x] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">1</span>; ii &lt;= t; ii++) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m, q;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="function">graph <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">int</span>* W = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; W[i];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> a, b;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			<span class="keyword">int</span> w0 = W[b] - W[a];</span><br><span class="line">			<span class="keyword">int</span> weight = w0 * w0 * w0;</span><br><span class="line">			G.add(a, b, weight);</span><br><span class="line">		&#125;</span><br><span class="line">		G.spfa();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ii &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> p;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">			G.output(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>SPFA</tag>
        <tag>Bellman-Ford</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡字符串Plus</title>
    <url>/2020/04/17/%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2Plus/</url>
    <content><![CDATA[<h1 id="平衡字符串Plus"><a href="#平衡字符串Plus" class="headerlink" title="平衡字符串Plus"></a><strong>平衡字符串Plus</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串，字符串中包括26个大写字母和特殊字符&#39;?&#39;，特殊字符&#39;?&#39;可以代表任何一个大写字母。</span><br><span class="line">是否存在一个位置连续的且由26个大写字母组成的子串，在这个子串中每个字母出现且仅出现一次，如果存在，请输出从左侧算起的第一个出现的符合要求的子串，并且要求，如果有多组解同时符合位置最靠左，则输出字典序最小的那个解；如果不存在，输出-1。</span><br><span class="line"></span><br><span class="line">说明：字典序先按照第一个字母，以 A、B、C ...... Z 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，SIGH 和 SIGHT），那么把短者排在前。例如</span><br><span class="line">AB??EFGHIJKLMNOPQRSTUVWXYZ </span><br><span class="line"> </span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">ABDCEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">上面两种填法，都可以构成26个字母，但是我们要求字典序最小，只能取前者。</span><br><span class="line">注意，题目要求的是第一个出现的，字典序最小的！</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入只有一行，一个符合题目描述的字符串。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出只有一行，如果存在这样的子串，请输出，否则输出-1</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">ABC??FGHIJK???OPQR?TUVWXY?</span><br><span class="line">Output: </span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">AABCDEFGHIJKLMNOPQRSTUVW??M</span><br><span class="line">Output: </span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><div class="table-container">
<table>
<thead>
<tr>
<th>数据点</th>
<th>字符串长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>1, 2, 3</td>
<td>10</td>
</tr>
<tr>
<td>4, 5, 6</td>
<td>10<sup>4</sup></td>
</tr>
<tr>
<td>7, 8, 9, 10</td>
<td>10<sup>6</sup></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	65536 kb</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>滑动窗口问题，窗口内26个字符，不断向右滑动；<br>每次对窗口内字符串判断，先记录26个字母的频率，若有其中一个字母频率&gt;1，则这个窗口一定不行，及时终止；若有字母的频率为0，则一定出现了’?’，记下这个字母；26个字符全扫一遍后，将’?’按字母表顺序全部替换为字母，返回字符串。<br>不断滑动窗口，直至出现第一个符合情况的字符串，按要求输出。</p>
<p>这样暴力求解，本来是想骗分的，没想到真的<code>AC</code>了……</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getN</span><span class="params">(<span class="keyword">char</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &gt;= <span class="number">65</span> &amp;&amp; a &lt;= <span class="number">90</span>)</span><br><span class="line">		<span class="keyword">return</span> a - <span class="number">64</span>;<span class="comment">//标记A~Z：1~26</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//标记?：0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve1</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count[<span class="number">27</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">		count[getN(s[i])]++;</span><br><span class="line">	<span class="keyword">int</span> c0 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp[<span class="number">27</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (count[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">string</span> t = <span class="string">"-1"</span>;</span><br><span class="line">			<span class="keyword">return</span> t;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (count[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			temp[c0] = i;</span><br><span class="line">			c0++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> c2 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> res = s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (res[i] == <span class="string">'?'</span>) &#123;</span><br><span class="line">			<span class="keyword">char</span> cha = temp[c2] + <span class="number">64</span>;</span><br><span class="line">			c2++;</span><br><span class="line">			res[i] = cha;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve2</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">25</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">string</span> c = s.substr(i - <span class="number">25</span>, <span class="number">26</span>);</span><br><span class="line">		<span class="built_in">string</span> res = solve1(c);</span><br><span class="line">		<span class="keyword">if</span> (res == <span class="string">"-1"</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (res.<span class="built_in">size</span>() == <span class="number">26</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; solve2(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>实时排名</title>
    <url>/2020/03/05/%E5%AE%9E%E6%97%B6%E6%8E%92%E5%90%8D/</url>
    <content><![CDATA[<h1 id="实时排名"><a href="#实时排名" class="headerlink" title="实时排名"></a><strong>实时排名</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序设计思维作业和实验使用的实时评测系统，具有及时获得成绩排名的特点，那它的功能是怎么实现的呢？</span><br><span class="line">我们千辛万苦怼完了不忍直视的程序并提交以后，评测系统要么返回AC，要么是返回各种其他的错误，不论是怎样的错法，它总会给你记上一笔，表明你曾经在这儿被坑过，而当你历经千辛终将它AC之后，它便会和你算笔总账,表明这题共错误提交了几次。</span><br><span class="line">在岁月的长河中，你通过的题数虽然越来越多，但通过每题时你所共花去的时间(从最开始算起，直至通过题目时的这段时间)都会被记录下来，作为你曾经奋斗的痕迹。特别的，对于你通过的题目，你曾经的关于这题的每次错误提交都会被算上一定的单位时间罚时，这样一来，你在做出的题数上，可能领先别人很多，但是在做出同样题数的人中，你可能会因为罚时过高而处于排名上的劣势。</span><br><span class="line">例如某次考试一共八道题(A, B, C, D, E, F, G, H)，每个人做的题都在对应的题号下有个数量标记，负数表示该学生在该题上有过的错误提交次数但到现在还没有AC，正数表示AC所耗的时间，如果正数a跟上了一对括号，里面有个正数b,则表示该学生AC了这道题，耗去了时间a，同时曾经错误提交了b次。例子可见下方的样例输入与输出部分。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入数据包含多行，第一行是共有的题数 n (1 ≤ n ≤ 12)以及单位罚时 m (10 ≤ m ≤ 20)，之后的每行数据描述一个学生的信息，首先是学生的用户名(不多于10个字符的字串)其次是所有 n 道题的得分现状，其描述采用问题描述中的数量标记的格式。</span><br><span class="line">负数表示尝试但没通过的次数，正数表示得分，正数+括号表示得分+尝试没通过的次数。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据这些学生的得分现状，输出一个实时排名。实时排名显然先按AC题数的多少排，多的在前，再按时间分的多少排，少的在前，如果凑巧前两者都相等，则按名字的字典序排，小的在前。每个学生占一行，输出名字(10个字符宽)，做出的题数(2个字符宽，右对齐)和时间分(4个字符宽，右对齐)。名字、题数和时间分相互之间有一个空格。数据保证可按要求的输出格式进行输出。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input:</span><br><span class="line">8 20</span><br><span class="line">GuGuDong  96     -3    40(3) 0    0    1      -8    0</span><br><span class="line">hrz       107    67    -3    0    0    82     0     0</span><br><span class="line">TT        120(3) 30    10(1) -3   0    47     21(2) -2</span><br><span class="line">OMRailgun 0      -99   -8    0    -666 -10086 0     -9999996</span><br><span class="line">yjq       -2     37(2) 13    -1   0    113(2) 79(1) -1</span><br><span class="line">Zjm       0      0     57(5) 0    0    99(3)  -7    0</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">TT          5  348</span><br><span class="line">yjq         4  342</span><br><span class="line">GuGuDong    3  197</span><br><span class="line">hrz         3  256</span><br><span class="line">Zjm         2  316</span><br><span class="line">OMRailgun   0    0</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>要实现不难，但是，格式很烦，没注意就会<code>WA</code>。</p>
<p>由于不知道要录入几个人，所以要<code>while()</code>一直录入，判断<code>eof()</code>。<br>对于第二行起的每一行输入，首先读入名字，然后对<code>n</code>道题依次读入，判断读入第<code>0</code>位：<code>&#39;-&#39;</code>或<code>&#39;0&#39;</code>不操作，否则丢入<code>realScore()</code>函数获取真实分数，并且通过题数<code>pass+1</code>，再将这些分数累加得到最终的得分<code>point</code>(详见代码)。</p>
<p>输出按照输出格式输出：<br>10个字符宽: <code>setw(10)</code><br>左对齐: <code>left</code><br>右对齐: <code>right</code><br><code>名字、题数和时间分相互之间有一个空格</code>，由于已经进行了对其操作，我写的时候还真漏了，看着不管改了好几次都是<code>WA</code>或者<code>CE</code>真的好烦……<br>排序：冒泡排序</p>
<h2 id="有些坑……"><a href="#有些坑……" class="headerlink" title="有些坑……"></a><strong>有些坑……</strong></h2><ol>
<li><p><code>cin</code>之后如果使用<code>getline(cin, string)</code>会把<code>cin</code>之后的换行符读入，所以<code>getline</code>第一次读入的是换行符。<br>解决：<code>cin.ignore(0x7fffffff, &#39;\n&#39;);</code>把换行符消除。</p>
</li>
<li><p>VJ上面<code>G++</code>编译一直<code>WA</code>，<code>C++</code>编译一直<code>Complication Error</code>，而且提示居然是<code>&quot;What do you want to do?&quot;</code>？？？(本地测试没问题啊)<br>Google的时候发现：<br><strong>在C++中读取一行的getline函数是不读入换行符的，而gcc / g++ 中getline函数是读入换行符的</strong><br>但是我本地没法弄个<code>g++</code>来测试，索性就不用<code>getline()</code>了(本来是每次读入一行，然后通过<code>sstream</code>对读入的这一行以空格分解为多个<code>string</code>进行操作)。</p>
</li>
<li><p>按名字字典排序<br>虽然说名字字长10以内，但是再对名字逐字符对比<code>ASCII</code>码排序，有点麻烦啊……就想想能不能简单的通过<code>&lt;</code>和<code>&gt;</code>对整个<code>string</code>进行对比，Google了一下，发现了<code>compare()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">string::compare</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">Returns:</span></span><br><span class="line">0 : if both strings are equal.</span><br><span class="line">A value &lt; <span class="number">0</span> : <span class="keyword">if</span> *<span class="keyword">this</span> is shorter than str <span class="keyword">or</span>,</span><br><span class="line">first character that does <span class="keyword">not</span> match is smaller than str.</span><br><span class="line">A value &gt; <span class="number">0</span> : <span class="keyword">if</span> *<span class="keyword">this</span> is longer than str <span class="keyword">or</span>,</span><br><span class="line">first character that does <span class="keyword">not</span> match is greater</span><br></pre></td></tr></table></figure>
<p>也就是说<code>string s1</code>如果字典序在<code>string s2</code>的前面，则<code>s1.compare(s2) &lt; 0</code>。</p>
</li>
<li><p>每位学生分数信息用一个结构体<code>struct score</code>储存，每个<code>score</code>我丢到<code>vector</code>里面储存，因为使用比较方便，不需要注意数组的大小，每次只需要<code>push_back()</code>就行。但是……VJ上一直过不了啊!!!(编译器是多老啊😓)<br>所以后来改成用数组储存，容量开大一点，因为也不知道会录入多少。</p>
</li>
</ol>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnum = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 学生成绩结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score</span> &#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;<span class="comment">//名字</span></span><br><span class="line">	<span class="keyword">int</span> n;<span class="comment">//本次成绩个数，不过用不到</span></span><br><span class="line">	<span class="keyword">int</span> p;<span class="comment">//pass//多少个通过</span></span><br><span class="line">	<span class="keyword">int</span> sc;<span class="comment">//scores//总得分</span></span><br><span class="line">	score() &#123; n = <span class="number">0</span>; p = <span class="number">0</span>; sc = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求单项真实分数(原正得分+罚时分)，结果返回int分数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">realScore</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> tried = <span class="literal">false</span>;<span class="comment">//bool 尝试过 = false，即都对，没被罚时</span></span><br><span class="line">    <span class="comment">//扫描左右括号</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s.at(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">			s.at(i) = <span class="string">' '</span>;<span class="comment">//左括号变成空格，方便下一步处理</span></span><br><span class="line">			tried = <span class="literal">true</span>;<span class="comment">//扫到的话，有被罚时</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s.at(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">			s.at(i) = <span class="string">' '</span>;<span class="comment">//右括号变成空格，方便下一步处理</span></span><br><span class="line">			tried = <span class="literal">true</span>;<span class="comment">//再写一次 以防万一</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != s.<span class="built_in">size</span>(); i++) &#123;<span class="comment">//以防万一string里面不是0~9</span></span><br><span class="line">		<span class="keyword">if</span> (!(s.at(i) &gt;= <span class="number">48</span> &amp;&amp; s.at(i) &lt;= <span class="number">57</span>))</span><br><span class="line">			s.at(i) = <span class="string">' '</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tried) &#123;<span class="comment">//如果有罚时</span></span><br><span class="line">		<span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(s)</span></span>;<span class="comment">//处理string  使得可以转成int</span></span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		iss &gt;&gt; a &gt;&gt; b;<span class="comment">//用于处理string 空格分隔 存进两个int里面</span></span><br><span class="line">		<span class="keyword">return</span> (a + b * m);<span class="comment">//a = 原得分  b = 尝试次数   m = 单位罚时</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//没有罚时</span></span><br><span class="line">		<span class="built_in">istringstream</span> iss(s);</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		iss &gt;&gt; a;<span class="comment">//string转成int</span></span><br><span class="line">		<span class="keyword">return</span> a;<span class="comment">//直接返回得分</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于对比名字 Alphabetically */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">com</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.compare(b) &gt; <span class="number">0</span>;<span class="comment">//如果名字a字母表顺序在名字b后 则返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">	score arrayList[maxnum];<span class="comment">// list of names &amp; scores</span></span><br><span class="line">	<span class="built_in">cin</span>.ignore(<span class="number">0x7fffffff</span>, <span class="string">'\n'</span>);<span class="comment">//忽略cin后的换行符 防止下次读入时出错</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> countNum = <span class="number">0</span>;<span class="comment">//计数  录入多少个学生的信息</span></span><br><span class="line">	<span class="built_in">string</span> name;<span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">while</span> (!(<span class="built_in">cin</span> &gt;&gt; name).eof()) &#123;<span class="comment">//没读到EOF就一直执行</span></span><br><span class="line">		countNum++;<span class="comment">//已录入  计数+1</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">string</span> temp;<span class="comment">//临时string  储存得分</span></span><br><span class="line">		<span class="keyword">int</span> pass = <span class="number">0</span>;<span class="comment">//多少题通过 初始为0</span></span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">point</span> = <span class="number">0</span>;<span class="comment">//得分从0开始算</span></span><br><span class="line">		<span class="comment">//int tried = 0;//pass but failed how many times</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//题意 n道题</span></span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">			<span class="keyword">if</span> (temp.at(<span class="number">0</span>) != <span class="string">'-'</span> &amp;&amp; temp.at(<span class="number">0</span>) != <span class="string">'0'</span>) &#123;<span class="comment">//判断</span></span><br><span class="line">                <span class="comment">//若非负分或0分  就可以记分</span></span><br><span class="line">				pass++;<span class="comment">//通过题数+1</span></span><br><span class="line">				<span class="built_in">point</span> += realScore(temp, m);<span class="comment">//丢到函数里计算真实得分 并累加到point</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		score s;</span><br><span class="line">		s.name = name;</span><br><span class="line">		s.n = n;</span><br><span class="line">		s.p = pass;</span><br><span class="line">		s.sc = <span class="built_in">point</span>;</span><br><span class="line"></span><br><span class="line">		arrayList[countNum - <span class="number">1</span>] = s;<span class="comment">//每个学生的信息存到数组arrayList里</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//after input, order list</span></span><br><span class="line">    <span class="comment">//bubble sort</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countNum - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arrayList[j].p &lt; arrayList[j + <span class="number">1</span>].p)<span class="comment">//若通过题数较小</span></span><br><span class="line">				swap(arrayList[j], arrayList[j + <span class="number">1</span>]);<span class="comment">//换位</span></span><br><span class="line">			<span class="keyword">if</span> (arrayList[j].p == arrayList[j + <span class="number">1</span>].p) &#123;<span class="comment">//若通过题数相等 继续判断</span></span><br><span class="line">				<span class="keyword">if</span> (arrayList[j].sc &gt; arrayList[j + <span class="number">1</span>].sc)<span class="comment">//若总分较大</span></span><br><span class="line">					swap(arrayList[j], arrayList[j + <span class="number">1</span>]);<span class="comment">//换位</span></span><br><span class="line">				<span class="keyword">if</span> (arrayList[j].sc == arrayList[j + <span class="number">1</span>].sc)<span class="comment">//若总分相等</span></span><br><span class="line">					<span class="keyword">if</span> (com(arrayList[j].name, arrayList[j + <span class="number">1</span>].name))<span class="comment">//若名字靠后</span></span><br><span class="line">						swap(arrayList[j], arrayList[j + <span class="number">1</span>]);<span class="comment">//换位</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != countNum; i++) &#123;<span class="comment">//按格式输出</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; left &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; arrayList[i].name &lt;&lt; <span class="string">" "</span> &lt;&lt;</span><br><span class="line">			right &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; arrayList[i].p &lt;&lt; <span class="string">" "</span> &lt;&lt;</span><br><span class="line">			right &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; arrayList[i].sc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>排序问题</tag>
      </tags>
  </entry>
  <entry>
    <title>奇妙的序列</title>
    <url>/2020/04/17/%E5%A5%87%E5%A6%99%E7%9A%84%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="奇妙的序列"><a href="#奇妙的序列" class="headerlink" title="奇妙的序列"></a><strong>奇妙的序列</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有一个奇怪的无限序列: 112123123412345...... </span><br><span class="line">这个序列由连续正整数组成的若干部分构成，其中第一部分包含 1 至 1 之间的所有数字，第二部分包含 1 至 2 之间的所有数字，第三部分包含 1 至 3 之间的所有数字，第 i 部分总是包含 1 至 i 之间的所有数字。</span><br><span class="line">所以，这个序列的前 56 项会是11212312341234512345612345671234567812345678912345678910，其中第 1 项是 1，第 3 项是 2，第 20 项是 5，第 38 项是 2，第56项是 0。</span><br><span class="line">求第 k 项数字是多少。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入由多行组成。</span><br><span class="line">第一行一个整数 q 表示有 q 组询问 (1 ≤ q ≤ 500)</span><br><span class="line">接下来第 i+1 行表示第 i 个输入 ki，表示询问第 ki 项数字 (1 ≤ ki ≤ 1e18)</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出包含 q 行</span><br><span class="line">第 i 行输出对询问 ki 的输出结果。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">20</span><br><span class="line">38</span><br><span class="line">56</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><div class="table-container">
<table>
<thead>
<tr>
<th>数据点</th>
<th><em>q</em> (上限)</th>
<th><em>k</em> (上限)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1, 2, 3</td>
<td>500</td>
<td>55</td>
</tr>
<tr>
<td>4, 5, 6</td>
<td>10<sup>4</sup></td>
<td>10<sup>6</sup></td>
</tr>
<tr>
<td>7, 8, 9, 10</td>
<td>500</td>
<td>10<sup>18</sup></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	65536 kb</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><p>暴力代码，只有60%的分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> a;</span><br><span class="line">	<span class="built_in">stringstream</span> b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		b &lt;&lt; i;</span><br><span class="line">	&#125;</span><br><span class="line">	b &gt;&gt; a;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a[n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>序列操作</title>
    <url>/2020/04/11/%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a><strong>序列操作</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存在一个序列 a, 是否存在一个数 K, 使得一些数加上 K，一些数减去 K，一些数不变，使得整个序列中所有的数相等。</span><br><span class="line">其中对于序列中的每个位置上的数字，至多只能执行一次加运算或减运算或是对该位置不进行任何操作。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输⼊第一行是一个正整数 t 表示数据组数。</span><br><span class="line">接下来对于每组数据，输入的第一个正整数 n 表示序列 a 的长度，随后一行有 n 个整数，标号序列 a 。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出共包含 t 行，每组数据输出一行。对于每组数据，如果存在这样的 K，输出&quot;YES&quot;，否则输出&quot;NO&quot;。（输出不包含引号）</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><div class="table-container">
<table>
<thead>
<tr>
<th>数据点(上限)</th>
<th><em>t</em></th>
<th><em>n</em></th>
<th><em>a</em><sub><em>i</em></sub></th>
</tr>
</thead>
<tbody>
<tr>
<td>1, 2</td>
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>3, 4, 5</td>
<td>10</td>
<td>10<sup>3</sup></td>
<td>10<sup>9</sup></td>
</tr>
<tr>
<td>6, 7, 8, 9, 10</td>
<td>10</td>
<td>10<sup>4</sup></td>
<td>10<sup>15</sup></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	65536 kb</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>操作只有，一些数加上<em>k</em>，一些数减去<em>k</em>，一些数不变，对于每一个数列，<em>k</em>恒定为一个数<em>k</em>或者其相反数。</p>
<p>可以把原数组排序，前面的数(小的数)加上<em>k</em>，中间的数不变，后面的数(大的数)减去<em>k</em>，所以一个数列中最多存在3个数：<em>x</em> - <em>k</em>, <em>x</em>, <em>x</em> + <em>k</em>，因此可以记录数列中有多少种不同的数。</p>
<p>如果不同的数种类 &gt; 3，则不存在<em>k</em>；<br>若种类 = 1 或 2，则一定存在<em>k</em>；<br>若种类 = 3，则可以记录不同数出现的位置，记下这3个不同数：若<code>(小的数+大的数)=2×中间的数</code>，则一定存在<em>k</em>，否则<em>k</em>不存在。</p>
<p>模拟的时候，没有注意数据范围，用的<code>int</code>，后面几组数据<code>WA</code>了，后来改成<code>long long</code> 就过了……所以一定要留意数据范围啊！</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	sort(a, a + n);</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> dif[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] != a[i - <span class="number">1</span>]) &#123;</span><br><span class="line">			dif[count] = i;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> x = a[dif[<span class="number">0</span>] - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> y = a[dif[<span class="number">0</span>]];</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> z = a[dif[<span class="number">1</span>]];</span><br><span class="line">		<span class="keyword">if</span> (x + z != <span class="number">2</span> * y)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">1</span> || count == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii != t; ii++) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span>* a = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[n + <span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">bool</span> ans = solve(a, n);</span><br><span class="line">		<span class="keyword">if</span> (ans)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>平衡字符串</title>
    <url>/2020/03/24/%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="平衡字符串"><a href="#平衡字符串" class="headerlink" title="平衡字符串"></a><strong>平衡字符串</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个长度为 n 的字符串 s，其中仅包含 &#39;Q&#39;, &#39;W&#39;, &#39;E&#39;, &#39;R&#39; 四种字符。</span><br><span class="line">如果四种字符在字符串中出现次数均为 n&#x2F;4，则其为一个平衡字符串。</span><br><span class="line">现可以将 s 中连续的一段子串替换成相同长度的只包含那四个字符的任意字符串，使其变为一个平衡字符串，问替换子串的最小长度?</span><br><span class="line">如果 s 已经平衡则输出0。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一行字符表示给定的字符串s。</span><br><span class="line">(字符串长度 n 是4的倍数，1 ≤ n ≤ 10^5，字符串中仅包含字符 &#39;Q&#39;, &#39;W&#39;, &#39;E&#39; 和 &#39;R&#39;。)</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个整数表示答案。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input: </span><br><span class="line">QWER</span><br><span class="line">output: </span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">input: </span><br><span class="line">QQWE</span><br><span class="line">output: </span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">input: </span><br><span class="line">QQQW</span><br><span class="line">output: </span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">input: </span><br><span class="line">QQQQ</span><br><span class="line">output: </span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	262144 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>这是一个滑动窗口问题，可以用双指针的方法，首先记录4个字符的出现频率，然后维护一个区间内的字符出现频率，二者之差可以得到区间外的每种字符频率。如果区间外每种字符的出现次数都小于等于 <em>n</em>/4，则这个区间是合法的，否则需要通过减少其他字符串的频率来达到平衡。滑动过之后，每个区间外的字符串都满足小于等于 <em>n</em>/4。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getN</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;<span class="comment">//对字符标记</span></span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">'W'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">'E'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">'R'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRes</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> ans = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> avg = s.<span class="built_in">size</span>() / <span class="number">4</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != s.<span class="built_in">size</span>(); i++)</span><br><span class="line">		count[getN(s[i])]++;<span class="comment">//记录4个字符的个数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != s.<span class="built_in">size</span>(); j++) &#123;<span class="comment">//活动窗口i, j左右指针</span></span><br><span class="line">		count[getN(s[j])]--;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; count[<span class="number">0</span>] &lt;= avg &amp;&amp;</span><br><span class="line">			count[<span class="number">1</span>] &lt;= avg &amp;&amp; count[<span class="number">2</span>] &lt;= avg</span><br><span class="line">			&amp;&amp; count[<span class="number">3</span>] &lt;= avg) &#123;<span class="comment">//找到了可以替换的字符串</span></span><br><span class="line">			ans = <span class="built_in">min</span>(ans, j - i + <span class="number">1</span>);<span class="comment">//计算字符串长度</span></span><br><span class="line">			count[getN(s[i++])]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; getRes(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>快线换乘-最短路径</title>
    <url>/2020/04/07/%E5%BF%AB%E7%BA%BF%E6%8D%A2%E4%B9%98-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a><strong>最短路径</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">猫猫快线是市民从市内去喵星机场的首选交通工具。猫猫快线分为经济线和商业线两种，线路、速度和价钱都不同。TT 有一张商业线车票，可以坐一站商业线，而其他时候只能乘坐经济线。假设换乘时间忽略不计，你的任务是找一条去喵星机场最快的线路。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入包含多组数据。每组数据第一行为 3 个整数 N, S 和 E (2 ≤ N ≤ 500, 1 ≤ S, E ≤ 100)，即猫猫快线中的车站总数，起点和终点（即喵星机场所在站）编号。</span><br><span class="line"></span><br><span class="line">下一行包含一个整数 M (1 ≤ M ≤ 1000)，即经济线的路段条数。</span><br><span class="line"></span><br><span class="line">接下来有 M 行，每行 3 个整数 X, Y, Z (1 ≤ X, Y ≤ N, 1 ≤ Z ≤ 100)，表示 TT 可以乘坐经济线在车站 X 和车站 Y 之间往返，其中单程需要 Z 分钟。</span><br><span class="line"></span><br><span class="line">下一行为商业线的路段条数 K (1 ≤ K ≤ 1000)。</span><br><span class="line"></span><br><span class="line">接下来 K 行是商业线路段的描述，格式同经济线。</span><br><span class="line"></span><br><span class="line">所有路段都是双向的，但有可能必须使用商业车票才能到达机场。保证最优解唯一。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于每组数据，输出3行。第一行按访问顺序给出 TT 经过的各个车站（包括起点和终点），第二行是 TT 换乘商业线的车站编号（如果没有使用商业线车票，输出&quot;Ticket Not Used&quot;，不含引号），第三行是 TT 前往喵星机场花费的总时间。</span><br><span class="line"></span><br><span class="line">本题不忽略多余的空格和制表符，且每一组答案间要输出一个换行</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">4 1 4</span><br><span class="line">4</span><br><span class="line">1 2 2</span><br><span class="line">1 3 3</span><br><span class="line">2 4 4</span><br><span class="line">3 4 5</span><br><span class="line">1</span><br><span class="line">2 4 3</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">1 2 4</span><br><span class="line">2</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>不考虑商业线，这是一个没有负边的单源最短路问题，用Dijksta算法求解即可。</p>
<h3 id="Dijkstra-Algorithm"><a href="#Dijkstra-Algorithm" class="headerlink" title="Dijkstra Algorithm"></a>Dijkstra Algorithm</h3><p>引进两个集合<code>S</code>和<code>U</code>，<code>S</code>记录已求出的最短路径的顶点，<code>U</code>记录还未求出最短路径的顶点。</p>
<p>从一个起点<code>s</code>出发，初始时，<code>S</code>中只有<code>s</code>，<code>U</code>中有除<code>s</code>外的其它顶点且其距离为<code>s</code>到之的距离，不断的从<code>U</code>中选出距离最短的顶点<code>k</code>，并将<code>k</code>加入到<code>S</code>中，且从<code>U</code>中移除<code>k</code>。</p>
<p>然后更新<code>U</code>，<code>(s, v)</code>表示<code>s</code>到<code>v</code>的距离，若<code>(s, v) &gt; (s, k) + (k, v)</code>，则更新<code>(s, v)</code>。</p>
<p>不断重复以上操作，直至遍历完所有顶点。</p>
<h3 id="再看这道题"><a href="#再看这道题" class="headerlink" title="再看这道题"></a>再看这道题</h3><p>先不考虑商业线，从起点开始遍历，可以求出起点到每个点的最短距离<code>dis1[]</code>，再从终点开始遍历得到最短距离<code>dis2[]</code>。</p>
<p>考虑商业线，对于每一次输入的商业线<code>(u, v, w)</code>，对比一下<code>dis1[u]+dis2[v]+w</code>(由起点到<code>u</code>、由终点到<code>v</code>，且算上这条商业线的<code>w</code>)与<code>dis1[v]+dis2[u]+w</code>(起点→<code>v</code>、终点→<code>u</code>、商业线权重<code>w</code>)，取最小值，并用一个<code>ans</code>记录每一个的最小值，次次取最小，枚举完后记录的那个就是所取的商业线。<code>ans</code>再与不走商业线对比，最小值就是最终答案，根据题目格式输出。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, w;</span><br><span class="line">	edge* next;</span><br><span class="line">	edge() &#123; to = <span class="number">-1</span>; w = <span class="number">-1</span>; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">	edge(<span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">int</span> _w) :to(<span class="keyword">_t</span>), w(_w) &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	edge* head;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	linkedList() &#123; head = <span class="literal">NULL</span>; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">	~linkedList() &#123;</span><br><span class="line">		edge* temp = head;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			edge* p = temp;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">			p = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">delete</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">delete</span> temp;</span><br><span class="line">		head = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">edge* <span class="title">getFirst</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		edge* node = <span class="keyword">new</span> edge(to, w);</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			head = node;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		edge* p = head;</span><br><span class="line">		edge* pp = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			pp = p;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		pp-&gt;next = node;</span><br><span class="line">		<span class="built_in">size</span>++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis1[maxN], dis2[maxN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接链表表示的图*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	linkedList arr[maxN];</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">	<span class="keyword">int</span> pre1[maxN];</span><br><span class="line">	<span class="keyword">int</span> pre2[maxN];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	graph() &#123; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">	graph(<span class="keyword">int</span> n) :<span class="built_in">size</span>(n) &#123;  &#125;</span><br><span class="line">	~graph() &#123;  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">		arr[x].add(y, z);</span><br><span class="line">		arr[y].add(x, z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">bool</span> sta)</span> </span>&#123;</span><br><span class="line">		priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> reach[maxN] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sta) <span class="comment">//判断是否是初始车站</span></span><br><span class="line">				dis1[i] = inf;</span><br><span class="line">			<span class="keyword">if</span> (!sta)</span><br><span class="line">				dis2[i] = inf;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span> (sta)</span><br><span class="line">			dis1[s] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!sta)</span><br><span class="line">			dis2[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		q.push(make_pair(<span class="number">0</span>, s));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = q.top().second;</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="keyword">if</span> (reach[x])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			reach[x] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (edge* temp = arr[x].getFirst(); temp != <span class="literal">NULL</span>; temp = temp-&gt;next) &#123;<span class="comment">//遍历以当前点所有可能到达的最近车站，更新距离并记录前一车站以便输出</span></span><br><span class="line">				<span class="keyword">int</span> dest = temp-&gt;to;</span><br><span class="line">				<span class="keyword">int</span> weight = temp-&gt;w;</span><br><span class="line">				<span class="keyword">if</span> (sta) &#123;</span><br><span class="line">					<span class="keyword">if</span> (dis1[dest] &gt; dis1[x] + weight) &#123;</span><br><span class="line">						dis1[dest] = dis1[x] + weight;</span><br><span class="line">						pre1[dest] = x;</span><br><span class="line">						q.push(make_pair(-dis1[dest], dest));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!sta) &#123;</span><br><span class="line">					<span class="keyword">if</span> (dis2[dest] &gt; dis2[x] + weight) &#123;</span><br><span class="line">						dis2[dest] = dis2[x] + weight;</span><br><span class="line">						pre2[dest] = x;</span><br><span class="line">						q.push(make_pair(-dis2[dest], dest));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output1</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s != cur)</span><br><span class="line">			output1(s, pre1[cur]);</span><br><span class="line">		<span class="keyword">if</span> (s == cur)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, cur);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" %d"</span>, cur);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output2</span><span class="params">(<span class="keyword">int</span> e, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (cur != e) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" %d"</span>, cur);</span><br><span class="line">			cur = pre2[cur];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" %d"</span>, cur);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, s, e;<span class="comment">//车站总数 起点 终点</span></span><br><span class="line">	<span class="keyword">bool</span> firstOutput = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;s, &amp;e) != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!firstOutput)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">		<span class="function">graph <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x, y, z;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">			G.add(x, y, z);</span><br><span class="line">		&#125;</span><br><span class="line">		G.dijkstra(s, <span class="literal">true</span>);</span><br><span class="line">		G.dijkstra(e, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">int</span> k;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">		<span class="keyword">int</span> ans = inf;</span><br><span class="line">		<span class="keyword">int</span> d1, d2;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;<span class="comment">//枚举每一条商业线</span></span><br><span class="line">			<span class="keyword">int</span> x, y, z;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">			<span class="keyword">if</span> (ans &gt; <span class="built_in">min</span>(dis1[x] + dis2[y] + z, dis2[x] + dis1[y] + z)) &#123;</span><br><span class="line">				ans = <span class="built_in">min</span>(dis1[x] + dis2[y] + z, dis2[x] + dis1[y] + z);</span><br><span class="line">				<span class="keyword">if</span> (dis1[x] + dis2[y] &gt; dis1[y] + dis2[x])</span><br><span class="line">					swap(x, y);<span class="comment">//最终变成由s到x，y到e，便于输出</span></span><br><span class="line">				d2 = x;</span><br><span class="line">				d1 = y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (firstOutput)</span><br><span class="line">			firstOutput = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ans &lt; dis1[e]) &#123;<span class="comment">//使用了车票</span></span><br><span class="line">			G.output1(s, d2);</span><br><span class="line">			G.output2(e, d1);<span class="comment">//逆序输出</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>, d2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//没使用车票 直接输出</span></span><br><span class="line">			ans = dis1[e];</span><br><span class="line">			G.output1(s, e);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\nTicket Not Used\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>恐怖的宇宙射线</title>
    <url>/2020/03/19/%E6%81%90%E6%80%96%E7%9A%84%E5%AE%87%E5%AE%99%E5%B0%84%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="可怕又恐怖的宇宙射线"><a href="#可怕又恐怖的宇宙射线" class="headerlink" title="可怕又恐怖的宇宙射线"></a><strong>可怕又恐怖的宇宙射线</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">宇宙射线会在无限的二维平⾯上传播(可以看做⼀个二维网格图)，初始方向默认向上。宇宙射线会在发射出⼀段距离后分裂，向该⽅向的左右45°⽅向分裂出两条宇宙射线，同时威力不变！宇宙射线会分裂 n 次，每次分裂后会在分裂方向前进 ai 个单位长度。</span><br><span class="line">求宇宙射线共经过多少个位置。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输⼊第⼀行包含⼀个正整数n(n ≤ 30)，表示宇宙射线会分裂n次</span><br><span class="line">第⼆行包含n个正整数a1, a2, ..., an，第i个数 表示第i次分裂的宇宙射线会在它原方向上继续走多少个单位长度。</span><br></pre></td></tr></table></figure>
<h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出⼀个数ans，表示有多少个位置有射线经过。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input: </span><br><span class="line">4</span><br><span class="line">4 2 2 3</span><br><span class="line">output: </span><br><span class="line">39</span><br><span class="line"></span><br><span class="line">input: </span><br><span class="line">15</span><br><span class="line">1 2 3 4 5 5 4 3 2 1 1 2 3 4 5</span><br><span class="line">output: </span><br><span class="line">6179</span><br><span class="line"></span><br><span class="line">input: </span><br><span class="line">20</span><br><span class="line">1 2 3 4 5 5 4 3 2 1 1 2 3 4 5 5 4 3 2 1</span><br><span class="line">output: </span><br><span class="line">11404</span><br><span class="line"></span><br><span class="line">input: </span><br><span class="line">30</span><br><span class="line">5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5</span><br><span class="line">output: </span><br><span class="line">43348</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/03/20/caVDzir3ulJgp51.png" alt="0002.png"></p>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	262144 kB</span><br></pre></td></tr></table></figure>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><div class="table-container">
<table>
<thead>
<tr>
<th>数据点</th>
<th><em>n</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>10%</td>
<td>≤10</td>
</tr>
<tr>
<td>40%</td>
<td>≤20</td>
</tr>
<tr>
<td>100%</td>
<td>≤30</td>
</tr>
</tbody>
</table>
</div>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>信息量挺大的，短时间内要理解题意，还要想出解题方法，还要写好代码，还要考虑<code>MLE</code>或者<code>TLE</code>去优化时间、空间复杂度，还要测试是否<code>CE</code>，还要自己出数据验证思路对不对……反正赛时那时间我没写出来，最后几分钟草草提交，结果<code>CE</code>了……赛后也是写了好久，一直卡在<code>MLE on test 5</code>……后来才对DFS优化剪枝，用优化前后的测试数据对比判断优化是否<code>WA</code>了……最后才<code>AC</code>……🤧</p>
<p>思路就是DFS，8种选择写的麻烦了一点，主要就是解题有许多坑啊……😖</p>
<h3 id="分裂后的方向问题"><a href="#分裂后的方向问题" class="headerlink" title="分裂后的方向问题"></a>分裂后的方向问题</h3><p>每次分裂都会往左右45°产生2个方向，二维平面总共有8个方向，因此我对这些方向标号(见代码)，原方向与分裂后产生的方向(方向1、方向2，原方向的左侧优先)就有规律可循了，用2个函数就能求出方向1、方向2。</p>
<h3 id="第几次分裂、前进长度问题"><a href="#第几次分裂、前进长度问题" class="headerlink" title="第几次分裂、前进长度问题"></a>第几次分裂、前进长度问题</h3><p>刚开始我的处理是对输出进行多次录入处理，比如原输入<code>1 2 3 4</code>，对应数组第<code>0 1 2 3</code>位，则对应产生的射线就是2<sup><em>i</em></sup>条(<em>i</em> 为数组下标)，则我在输入时对数组进行处理，数组元素就变成<code>{ 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4 }</code>。<br>可是后来剪枝优化的时候，发现比较难判断这是第几次分裂，况且<em>n</em>越大这个数组指数级变长……所以就要对当前是第几次大分裂进行标记，简单方法就是把这个第几次存入点<code>dot</code>的结构体中，每次要用的时候取出，每次分裂并前进结束后再对这个数+1就能清楚当前是第几次大分裂了。</p>
<h3 id="标记到达的问题"><a href="#标记到达的问题" class="headerlink" title="标记到达的问题"></a>标记到达的问题</h3><p>我一开始的思路是，对于每个经过点，都<code>pushback()</code>到<code>vector</code>里面，然后对这个<code>vector</code>排序，<code>for</code>循环后算出有多少个重复点，再用<code>size()</code>减去重复数量就能求出有多少点……但是后面数据太大太多，明显会<code>MLE</code>且<code>TLE</code>，所以我考虑用<code>reach</code>数组标记到达的方法。<br>但是问题又来了，我一开始的起始点思维定式成<code>(0, 0)</code>，射线可以会经过<em>x</em>轴跟<em>y</em>轴的负数区间的，数组标记不了负的下标啊……后来想想，可以用一个四维数组<code>reach[x][y][2][2]</code>，第三维的2代表x的正负，第四维的2代表y的正负。但是……好麻烦，<code>if</code>又要写一大堆还容易出错😥。<br>后来观察图形，发现是关于<em>y</em>轴对称的，所以可以只记录<em>x</em>轴正半轴处的分裂，只记录<em>y</em>的正负，降维成三维数组，最终得到的点数目×2 - 处于y轴上的点就是结果了。但是，老是要考虑正负还是麻烦啊😒……<br>后来，后来，再后来……我观察了数据范围，发现它最长能达到的横坐标是 5 × 30 × 2 = 300 (每一大次分裂都走5步, 最多30次, 正负各一次)，纵坐标奕然，所以，把起点换成<code>(150, 150)</code>就不用考虑<em>x</em>, <em>y</em>的坐标正负问题了😀……<br>思维定式真的坑🕳啊……</p>
<h3 id="如何剪枝的问题"><a href="#如何剪枝的问题" class="headerlink" title="如何剪枝的问题"></a>如何剪枝的问题</h3><p>每次分裂只考虑一个方向的话，8次后，方向就会绕回来了。所以那么多次分裂，很多步骤都是重复的。所以要用另一个数组标记，<code>con[x][y][8][31]</code>表示分裂起始点坐标，方向，第几次分裂(确定了第几次分裂就一定可以知道前进步数，所以不用再对步数进行标记到达)，这样就可以免去许多重复的步骤，优化复杂度。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><p><code>AC</code>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXREACH = <span class="number">310</span>;<span class="comment">//最大300，大一点点以防万一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x, y, direction, time</span></span><br><span class="line"><span class="keyword">bool</span> con[MAXREACH][MAXREACH][<span class="number">8</span>][<span class="number">31</span>] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="keyword">bool</span> reach[MAXREACH][MAXREACH] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">		<span class="comment">/*我根据产生方向的先后顺序标记的8个方向*/</span></span><br><span class="line"><span class="comment">/*↑: 1   ↖: 2   ↗: 3   ←: 4   →:5   ↙: 6   ↘: 7   ↓: 8*/</span></span><br><span class="line">	<span class="comment">/*north: 1;  northwest: 2;   northeast: 3;   west: 4;</span></span><br><span class="line"><span class="comment">	east: 5;   southwest: 6;   southeast: 7;   south: 8*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dot</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">int</span> dir;</span><br><span class="line">	<span class="keyword">int</span> times;</span><br><span class="line">	dot() &#123;  &#125;</span><br><span class="line">	dot(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y) : x(_x), y(_y) &#123; dir = <span class="number">0</span>; times = <span class="number">0</span>; &#125;</span><br><span class="line">	dot(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> d, <span class="keyword">int</span> t) : x(_x), y(_y), dir(d), times(t) &#123;  &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> dot d)<span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (x == d.x)	<span class="keyword">return</span> y &lt; d.y;</span><br><span class="line">		<span class="keyword">return</span> x &lt; d.x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> dot d)<span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (x == d.x &amp;&amp; y == d.y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextDir1</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;<span class="comment">//往左45°产生的方向</span></span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">1</span>)	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">2</span>)	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">3</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">4</span>)	<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">5</span>)	<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">6</span>)	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">7</span>)	<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">8</span>)	<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextDir2</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;<span class="comment">//往右45°产生的方向</span></span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">1</span>)	<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">2</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">3</span>)	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">4</span>)	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">5</span>)	<span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">6</span>)	<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">7</span>)	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">8</span>)	<span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">dot <span class="title">genDot</span><span class="params">(dot s, <span class="keyword">int</span> dir)</span> </span>&#123;<span class="comment">//每次走一步 产生下一个点</span></span><br><span class="line">	<span class="function">dot <span class="title">e</span><span class="params">(s.x, s.y)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">1</span>)	e.y += <span class="number">1</span>;<span class="comment">//↑</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">4</span>)	e.x -= <span class="number">1</span>;<span class="comment">//←</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">5</span>)	e.x += <span class="number">1</span>;<span class="comment">//→</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">8</span>)	e.y -= <span class="number">1</span>;<span class="comment">//↓</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">2</span>) &#123; e.x -= <span class="number">1</span>; e.y += <span class="number">1</span>; &#125;<span class="comment">//↖</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">3</span>) &#123; e.x += <span class="number">1</span>; e.y += <span class="number">1</span>; &#125;<span class="comment">//↗</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">6</span>) &#123; e.x -= <span class="number">1</span>; e.y -= <span class="number">1</span>; &#125;<span class="comment">//↙</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">7</span>) &#123; e.x += <span class="number">1</span>; e.y -= <span class="number">1</span>; &#125;<span class="comment">//↘</span></span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span>* <span class="built_in">step</span> = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; <span class="built_in">step</span>[i];</span><br><span class="line">	<span class="function">dot <span class="title">s</span><span class="params">(<span class="number">152</span>, <span class="number">152</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;<span class="comment">//以防万一 起点变成(152, 152) 方向1 第0次分裂</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">queue</span>&lt;dot&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> reachCount = <span class="number">0</span>;<span class="comment">//记录到达过多少个位置</span></span><br><span class="line">	<span class="keyword">int</span> times = <span class="number">0</span>;<span class="comment">//记录第几次大分裂</span></span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		dot cur = q.front();<span class="comment">//当前点</span></span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> dir = cur.dir;<span class="comment">//当前方向</span></span><br><span class="line">		times = cur.times;<span class="comment">//当前是第几次大分裂</span></span><br><span class="line">		<span class="keyword">if</span> (con[cur.x][cur.y][dir - <span class="number">1</span>][times] == <span class="literal">true</span>)<span class="comment">//如果这次分裂重复来过了</span></span><br><span class="line">			<span class="keyword">continue</span>;<span class="comment">//不用管这一次了 继续下一个循环</span></span><br><span class="line">		con[cur.x][cur.y][dir<span class="number">-1</span>][times] = <span class="literal">true</span>;<span class="comment">//没来过 标记true</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="built_in">step</span>[times]; i++) &#123;<span class="comment">//走几步</span></span><br><span class="line">			dot temp = genDot(cur, dir);<span class="comment">//产生下一个点</span></span><br><span class="line">			cur = temp;</span><br><span class="line">			<span class="keyword">int</span> ca = cur.x, cb = cur.y;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (reach[ca][cb] == <span class="literal">false</span>) &#123;<span class="comment">//标记到达</span></span><br><span class="line">				reach[ca][cb] = <span class="literal">true</span>;</span><br><span class="line">				reachCount++;<span class="comment">//计数</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (times &lt; n - <span class="number">1</span>) &#123;<span class="comment">//还没到最后一次的大分裂 可入队</span></span><br><span class="line">			<span class="keyword">int</span> a = cur.x, b = cur.y;</span><br><span class="line">			<span class="function">dot <span class="title">cur1</span><span class="params">(a, b, nextDir1(dir), times + <span class="number">1</span>)</span></span>;</span><br><span class="line">			<span class="function">dot <span class="title">cur2</span><span class="params">(a, b, nextDir2(dir), times + <span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="comment">//2个方向 入队</span></span><br><span class="line">			q.push(cur1);</span><br><span class="line">			q.push(cur2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; reachCount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MLE</code>暴力代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dot</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">int</span> dir;</span><br><span class="line">	dot() &#123;  &#125;</span><br><span class="line">	dot(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y) : x(_x), y(_y) &#123; dir = <span class="number">0</span>; &#125;</span><br><span class="line">	dot(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> d) : x(_x), y(_y), dir(d)&#123;  &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> dot d)<span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (x == d.x)	<span class="keyword">return</span> y &lt; d.y;</span><br><span class="line">		<span class="keyword">return</span> x &lt; d.x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> dot d)<span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (x == d.x &amp;&amp; y == d.y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextDir1</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">1</span>)	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">2</span>)	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">3</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">4</span>)	<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">5</span>)	<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">6</span>)	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">7</span>)	<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">8</span>)	<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextDir2</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">1</span>)	<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">2</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">3</span>)	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">4</span>)	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">5</span>)	<span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">6</span>)	<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">7</span>)	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">8</span>)	<span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">dot <span class="title">genDot</span><span class="params">(dot s, <span class="keyword">int</span> dir)</span> </span>&#123;</span><br><span class="line">	<span class="function">dot <span class="title">e</span><span class="params">(s.x, s.y)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">1</span>)	e.y += <span class="number">1</span>;<span class="comment">//↑</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">4</span>)	e.x -= <span class="number">1</span>;<span class="comment">//←</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">5</span>)	e.x += <span class="number">1</span>;<span class="comment">//→</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">8</span>)	e.y -= <span class="number">1</span>;<span class="comment">//↓</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">2</span>) &#123; e.x -= <span class="number">1</span>; e.y += <span class="number">1</span>; &#125;<span class="comment">//↖</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">3</span>) &#123; e.x += <span class="number">1</span>; e.y += <span class="number">1</span>; &#125;<span class="comment">//↗</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">6</span>) &#123; e.x -= <span class="number">1</span>; e.y -= <span class="number">1</span>; &#125;<span class="comment">//↙</span></span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="number">7</span>) &#123; e.x += <span class="number">1</span>; e.y -= <span class="number">1</span>; &#125;<span class="comment">//↘</span></span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">step</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> sx;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; sx;</span><br><span class="line">		<span class="keyword">double</span> stimes = <span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">double</span> j = <span class="number">0</span>; j != stimes; j++)</span><br><span class="line">			<span class="built_in">step</span>.push_back(sx);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">dot <span class="title">s</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;dot&gt; path;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">queue</span>&lt;dot&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		dot cur = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> dir = cur.dir;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="built_in">step</span>[times]; i++) &#123;</span><br><span class="line">			dot temp = genDot(cur, dir);</span><br><span class="line">			path.push_back(temp);</span><br><span class="line">			cur = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		times++;</span><br><span class="line">		<span class="keyword">int</span> a = cur.x, b = cur.y;</span><br><span class="line">		<span class="function">dot <span class="title">cur1</span><span class="params">(a, b, nextDir1(dir))</span></span>;</span><br><span class="line">		<span class="function">dot <span class="title">cur2</span><span class="params">(a, b, nextDir2(dir))</span></span>;</span><br><span class="line">		q.push(cur1);</span><br><span class="line">		q.push(cur2);</span><br><span class="line">		<span class="keyword">if</span> (times == <span class="built_in">step</span>.<span class="built_in">size</span>())</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> psize = path.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> sameCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=psize<span class="number">-1</span>;i++)</span><br><span class="line">		<span class="keyword">if</span> (path[i] == path[i + <span class="number">1</span>])</span><br><span class="line">			sameCount++;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; psize - sameCount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>扑克牌again</title>
    <url>/2020/04/17/%E6%89%91%E5%85%8B%E7%89%8Cagain/</url>
    <content><![CDATA[<h1 id="又打牌"><a href="#又打牌" class="headerlink" title="又打牌"></a><strong>又打牌</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打牌新规则：</span><br><span class="line">👉所有扑克牌只按数字来算大小，忽略花色。</span><br><span class="line">👉每张扑克牌的大小由一个值表示。A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K 分别指代 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13。</span><br><span class="line">👉每个玩家抽得 5 张扑克牌，组成一手牌。(每种扑克牌的张数是无限的)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>一手牌有不同类型，并且有大小之分。<br>比如一手牌 α, β，要么 α &gt; β，要么 α &lt; β，要么 α = β。</p>
<p>对于不同类型的一手牌，其值的大小即下面的标号；对于同类型的一手牌，根据组成这手牌的 5 张牌不同，其值不同。下面依次列举了这手牌的形成规则：</p>
<ol>
<li>大牌：这手牌不符合下面任一个形成规则。如果 <em>α</em> 和 <em>β</em> 都是大牌，那么定义它们的大小为组成这手牌的 5 张牌的大小总和。</li>
<li>对子：5 张牌中有 2 张牌的值相等。如果 <em>α</em> 和 <em>β</em> 都是对子，比较这个 “对子” 的大小，如果 <em>α</em> 和 <em>β</em> 的 “对子” 大小相等，那么比较剩下 3 张牌的总和。</li>
<li>两对：5 张牌中有两个不同的对子。如果 <em>α</em> 和 <em>β</em> 都是两对，先比较双方较大的那个对子，如果相等，再比较双方较小的那个对子，如果还相等，只能比较 5 张牌中的最后那张牌组不成对子的牌。</li>
<li>三个：5 张牌中有 3 张牌的值相等。如果 <em>α</em> 和 <em>β</em> 都是 “三个”，比较这个 “三个” 的大小，如果 <em>α</em> 和 <em>β</em> 的 “三个” 大小相等，那么比较剩下 2 张牌的总和。</li>
<li>三带二：5 张牌中有 3 张牌的值相等，另外 2 张牌值也相等。如果 α 和 β 都是 “三带二”，先比较它们的 “三个” 的大小，如果相等，再比较 “对子” 的大小。</li>
<li>炸弹：5 张牌中有 4 张牌的值相等。如果 <em>α</em> 和 <em>β</em> 都是 “炸弹”，比较 “炸弹” 的大小，如果相等，比较剩下那张牌的大小。</li>
<li>顺子：5 张牌中形成 <em>x</em>, <em>x</em>+1, <em>x</em>+2, <em>x</em>+3, <em>x</em>+4。如果 <em>α</em> 和 <em>β</em> 都是 “顺子”，直接比较两个顺子的最大值。</li>
<li>龙顺：5 张牌分别为 10、J、Q、K、A。</li>
</ol>
<p>要求输出一个排行榜。排行榜按照选手们的 “一手牌” 大小进行排序，如果两个选手的牌相等，那么人名字典序小的排在前面。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入包含多组数据。每组输入开头一个整数 n (1 ≤ n ≤ 100000)，表明全场共多少人。</span><br><span class="line">随后是 n 行，每行一个字符串 s1 和 s2 (1 ≤ |s1|,|s2| ≤ 10)， s1 是对应人的名字，s2 是他手里的牌情况。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于每组测试数据，输出 n 行，即这次全场人的排名。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">3</span><br><span class="line">DongDong AAA109</span><br><span class="line">ZJM 678910</span><br><span class="line">Hrz 678910</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">Hrz</span><br><span class="line">ZJM</span><br><span class="line">DongDong</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	262144 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>又是打牌，又是又臭又长的题干，又是中间麻烦的字符串处理过程……这种题目不算难，就是要反复读题，中间处理过程多检查几遍，不然容易<code>WA</code>。</p>
<h3 id="分步处理"><a href="#分步处理" class="headerlink" title="分步处理"></a>分步处理</h3><p>长题可以分成多步骤解决，这题的主要步骤就是：</p>
<ol>
<li>手牌字符串转整型数组，并排序</li>
<li>根据题意判断手牌牌型，并记录第 <em>n</em> 关键字(第一关键字是牌型的编号)，存到结构体内<br>2.1 大牌：啥也不是，第二关键字是5张牌的和<br>2.2 对子：2等3不等，第二关键字是这个”2”，第三关键字是这个3张牌的和<br>2.3 两对：2等+2等+1，第二关键字是大的”2”，第三关键字是较小的”2”，第四关键字是这个”1”<br>2.4 三个：3等2不等，第二关键字是这个”3”，第三关键字是这个2张牌的和<br>2.5 三带二：3等+2等，第二关键字是这个”3”，第三关键字是这个”2”<br>2.6 炸弹：4等+1，第二关键字是这个”4”，第三关键字是这个”1”<br>2.7 顺子：形如”1 2 3 4 5””A B C D E”，第二关键字是这个”5”(“E”)<br>2.8 龙顺：手牌为10、J、Q、K、A，即数组<code>[1, 10, 11, 12, 13]</code></li>
<li>将所有人的手牌排序，输出人名</li>
</ol>
<h3 id="逐个攻破"><a href="#逐个攻破" class="headerlink" title="逐个攻破"></a>逐个攻破</h3><p>整体思路清晰后，就一一实现：</p>
<p><code>String</code>转<code>int Array[]</code>：对于10特殊处理，扫到 ‘10’ 的 ‘1’ 就存入10，对于 ‘10’ 的 ‘0’ 不做处理，因为扫不到其它的 1 (A、J、Q、K)。</p>
<p>判断牌型：用一个<code>int sameCnt</code>记录相同牌有几张(用 <em>a</em><sub><em>i</em></sub> 跟 <em>a</em><sub><em>i</em>+1</sub> 对比，所以<code>sameCnt = 各组相同张数和 - 1</code>)，并用一个<code>vector&lt;int&gt;</code>存放相同牌，然后可依此大致分为3大组：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Type</th>
<th style="text-align:center">Sample</th>
<th style="text-align:center">sameCnt</th>
<th style="text-align:center">vector</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">对子</td>
<td style="text-align:center"><code>[[A A] B C D]</code><br><code>[B [A A] C D]</code><br><code>[B C [A A] D]</code><br><code>[B C D [A A]]</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>[A]</code></td>
</tr>
<tr>
<td style="text-align:center">两对</td>
<td style="text-align:center"><code>[[A A] [B B] C]</code><br><code>[[A A] C [B B]]</code><br><code>[C [A A] [B B]]</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>[A, B]</code></td>
</tr>
<tr>
<td style="text-align:center">三个</td>
<td style="text-align:center"><code>[[A A A] B C]</code><br><code>[B [A A A] C]</code><br><code>[B C [A A A]]</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>[A, A]</code></td>
</tr>
<tr>
<td style="text-align:center">三带二</td>
<td style="text-align:center"><code>[[A A A] [B B]]</code><br><code>[[B B] [A A A]]</code></td>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>[A, A, B]</code><br><code>[B, A, A]</code></td>
</tr>
<tr>
<td style="text-align:center">炸弹</td>
<td style="text-align:center"><code>[[A A A A] B]</code><br><code>[B [A A A A]]</code></td>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>[A, A, A]</code></td>
</tr>
<tr>
<td style="text-align:center">顺子</td>
<td style="text-align:center"><code>[x, x+1, x+2, x+3, x+4]</code></td>
<td style="text-align:center">0</td>
<td style="text-align:center">EMPTY</td>
</tr>
<tr>
<td style="text-align:center">龙顺</td>
<td style="text-align:center"><code>[1, 10, 11, 12, 13]</code></td>
<td style="text-align:center">0</td>
<td style="text-align:center">EMPTY</td>
</tr>
<tr>
<td style="text-align:center">大牌</td>
<td style="text-align:center"><code>[A B C D E]</code></td>
<td style="text-align:center">0</td>
<td style="text-align:center">EMPTY</td>
</tr>
</tbody>
</table>
</div>
<p>每个大组里根据<code>vector</code>就可以把牌型再细分出来了，同时记录第 <em>n</em> 关键字。(详见代码)</p>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>自己随便出几组数据测试没啥问题，不过提交还是<code>WA</code>了，所以仔细再读了题目，发觉也没漏了啥条件，再反复看看了代码，利用中间输出，测试是哪一大步出错了？测了测也没啥错误啊……</p>
<p>找了好久才发现判断大牌的<code>for</code>循坏条件把<code>i &lt; 5</code>写成<code>i &lt; 4</code>……因为前面算<code>sameCnt</code>的时候条件是<code>i &lt; 4</code>，我貌似直接 copy-paste 了……</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poker</span> &#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> theLevel;</span><br><span class="line">	<span class="keyword">int</span> firstKey, secondKey, thirdKey;</span><br><span class="line">	poker(<span class="built_in">string</span> na, <span class="keyword">int</span> lvl, <span class="keyword">int</span> fK, <span class="keyword">int</span> sK, <span class="keyword">int</span> tK): name(na),</span><br><span class="line">		theLevel(lvl), firstKey(fK), secondKey(sK), thirdKey(tK) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">poker <span class="title">level</span><span class="params">(<span class="built_in">string</span> name, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sameCnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p[i] == p[i + <span class="number">1</span>]) &#123;</span><br><span class="line">			sameCnt++;</span><br><span class="line">			v.push_back(p[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2) 2 of 5 is equal</span></span><br><span class="line">	<span class="keyword">if</span> (sameCnt == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> firstKey = v.at(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">int</span> secondKey = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">			<span class="keyword">if</span> (p[i] != firstKey)</span><br><span class="line">				secondKey += p[i];</span><br><span class="line">		<span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">2</span>, firstKey, secondKey, <span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> po;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sameCnt == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">// (3) 2 and 2 of 5 each is equal</span></span><br><span class="line">		<span class="keyword">if</span> (v.at(<span class="number">0</span>) != v.at(<span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> firstKey = v.at(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">int</span> secondKey = v.at(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">int</span> thirdKey = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">				<span class="keyword">if</span> (p[i] != firstKey &amp;&amp; p[i] != secondKey)</span><br><span class="line">					thirdKey = p[i];</span><br><span class="line">			<span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">3</span>, firstKey, secondKey, thirdKey)</span></span>;</span><br><span class="line">			<span class="keyword">return</span> po;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (4) 3 of 5 is equal</span></span><br><span class="line">		<span class="keyword">if</span> (v.at(<span class="number">0</span>) == v.at(<span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> firstKey = v.at(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">int</span> secondKey = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">				<span class="keyword">if</span> (p[i] != firstKey)</span><br><span class="line">					secondKey += p[i];</span><br><span class="line">			<span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">4</span>, firstKey, secondKey, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">return</span> po;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (sameCnt == <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="comment">// (5) 3 of 5 &amp; 2 of 5</span></span><br><span class="line">		<span class="keyword">if</span> (v.at(<span class="number">0</span>) != v.at(<span class="number">2</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> firstKey = v.at(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">int</span> secondKey = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (v.at(<span class="number">0</span>) != v.at(<span class="number">1</span>))</span><br><span class="line">				secondKey = v.at(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (v.at(<span class="number">0</span>) == v.at(<span class="number">1</span>))</span><br><span class="line">				secondKey = v.at(<span class="number">2</span>);</span><br><span class="line">			<span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">5</span>, firstKey, secondKey, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">return</span> po;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (6) 4 of 5 is equal</span></span><br><span class="line">		<span class="keyword">if</span> (v.at(<span class="number">0</span>) == v.at(<span class="number">2</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> firstKey = v.at(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">int</span> secondKey = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (p[<span class="number">0</span>] == firstKey)</span><br><span class="line">				secondKey = p[<span class="number">4</span>];</span><br><span class="line">			<span class="keyword">if</span> (p[<span class="number">0</span>] != firstKey)</span><br><span class="line">				secondKey = p[<span class="number">0</span>];</span><br><span class="line">			<span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">6</span>, firstKey, secondKey, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">return</span> po;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sameCnt == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// (7) shunza</span></span><br><span class="line">		<span class="keyword">if</span> ((p[<span class="number">0</span>] + <span class="number">1</span> == p[<span class="number">1</span>]) &amp;&amp; (p[<span class="number">1</span>] + <span class="number">1</span> == p[<span class="number">2</span>]) &amp;&amp;</span><br><span class="line">			(p[<span class="number">2</span>] + <span class="number">1</span> == p[<span class="number">3</span>]) &amp;&amp; (p[<span class="number">3</span>] + <span class="number">1</span> == p[<span class="number">4</span>])) &#123;</span><br><span class="line">			<span class="keyword">int</span> firstKey = p[<span class="number">4</span>];</span><br><span class="line">			<span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">7</span>, firstKey, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">return</span> po;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (8) 10, J, Q, K, A</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="number">10</span> &amp;&amp; p[<span class="number">2</span>] == <span class="number">11</span></span><br><span class="line">			&amp;&amp; p[<span class="number">3</span>] == <span class="number">12</span> &amp;&amp; p[<span class="number">4</span>] == <span class="number">13</span>) &#123;</span><br><span class="line">			poker po(name, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> po;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (1) none of above</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> firstKey = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">				firstKey += p[i];</span><br><span class="line">			<span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">1</span>, firstKey, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">return</span> po;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; poke;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; pMap;</span><br><span class="line">	pMap[<span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">50</span>; i &lt;= <span class="number">57</span>; i++)</span><br><span class="line">		pMap[i] = i - <span class="number">48</span>;</span><br><span class="line">	pMap[<span class="string">'1'</span>] = <span class="number">10</span>;</span><br><span class="line">	pMap[<span class="string">'J'</span>] = <span class="number">11</span>;</span><br><span class="line">	pMap[<span class="string">'Q'</span>] = <span class="number">12</span>;</span><br><span class="line">	pMap[<span class="string">'K'</span>] = <span class="number">13</span>;</span><br><span class="line">	pMap[<span class="string">'0'</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> res = pMap[s[i]];</span><br><span class="line">		<span class="keyword">if</span> (res != <span class="number">0</span>)</span><br><span class="line">			poke.push_back(res);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort(poke.<span class="built_in">begin</span>(), poke.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> poke;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> poker&amp; p1, <span class="keyword">const</span> poker&amp; p2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p1.theLevel == p2.theLevel) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p1.firstKey == p2.firstKey) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p1.secondKey == p2.secondKey) &#123;</span><br><span class="line">				<span class="keyword">if</span> (p1.thirdKey == p2.thirdKey) &#123;</span><br><span class="line">					<span class="keyword">return</span> p1.name.compare(p2.name) &lt; <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> p1.thirdKey &gt; p2.thirdKey;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> p1.secondKey &gt; p2.secondKey;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p1.firstKey &gt; p2.firstKey;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1.theLevel &gt; p2.theLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (!(<span class="built_in">cin</span> &gt;&gt; n).eof()) &#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;poker&gt; v;</span><br><span class="line">		<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">			<span class="built_in">string</span> s1, s2;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">			<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p = convert(s2);</span><br><span class="line">			poker po = level(s1, p);</span><br><span class="line">			v.push_back(po);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); i++)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; v[i].name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>扑克牌牌型</title>
    <url>/2020/03/31/%E6%89%91%E5%85%8B%E7%89%8C%E7%89%8C%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="扑克牌牌型"><a href="#扑克牌牌型" class="headerlink" title="扑克牌牌型"></a><strong>扑克牌牌型</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有 A × B 张扑克牌。每张扑克牌有一个大小(整数，记为a，范围区间是 0 到 A - 1）和一个花色（整数，记为b，范围区间是 0 到 B - 1。</span><br><span class="line">扑克牌是互异的，也就是独一无二的，也就是说没有两张牌大小和花色都相同。</span><br><span class="line">“一手牌”的意思是你手里有5张不同的牌，这 5 张牌没有谁在前谁在后的顺序之分，它们可以形成一个牌型。 我们定义了 9 种牌型，如下是 9 种牌型的规则，我们用“低序号优先”来匹配牌型，即这“一手牌”从上到下满足的第一个牌型规则就是它的“牌型编号”（一个整数，属于1到9）:</span><br><span class="line">1. 同花顺: 同时满足规则 5 和规则 4.</span><br><span class="line">2. 炸弹 : 5张牌其中有4张牌的大小相等.</span><br><span class="line">3. 三带二 : 5张牌其中有3张牌的大小相等，且另外2张牌的大小也相等.</span><br><span class="line">4. 同花 : 5张牌都是相同花色的.</span><br><span class="line">5. 顺子 : 5张牌的大小形如 x, x + 1, x + 2, x + 3, x + 4</span><br><span class="line">6. 三条: 5张牌其中有3张牌的大小相等.</span><br><span class="line">7. 两对: 5张牌其中有2张牌的大小相等，且另外3张牌中2张牌的大小相等.</span><br><span class="line">8. 一对: 5张牌其中有2张牌的大小相等.</span><br><span class="line">9. 要不起: 这手牌不满足上述的牌型中任意一个.</span><br><span class="line">现在从A × B 张扑克牌中拿走 2 张牌，分别是 (a1, b1) 和 (a2, b2). （其中a表示大小，b表示花色），现在要从剩下的扑克牌中再随机拿出 3 张，组成一手牌。</span><br><span class="line">求在所有可能的方案中，这 9 种牌型每种牌型的方案数。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第 1 行包含了整数 A 和 B (5 ≤ A ≤ 25, 1 ≤ B ≤ 4).</span><br><span class="line">第 2 行包含了整数 a1, b1, a2, b2 (0 ≤ a1, a2 ≤ A - 1, 0 ≤ b1, b2 ≤ B - 1, (a1, b1) ≠ (a2, b2)).</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出一行，这行有 9 个整数，每个整数代表了 9 种牌型的方案数（按牌型编号从小到大的顺序）</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">5 2</span><br><span class="line">1 0 3 1</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">0 0 0 0 8 0 12 36 0</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">25 4</span><br><span class="line">0 0 24 3</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">0 2 18 0 0 644 1656 36432 113344</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		2000 ms</span><br><span class="line">Memory limit	524288 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>这是一道搜索问题，暴力<code>for</code>循环搜索就能解决，不需要用到排列组合……</p>
<p>本题主要有两步：求出所有组合，判断属于哪种牌型。</p>
<h3 id="求组合"><a href="#求组合" class="headerlink" title="求组合"></a>求组合</h3><p>本来是采用递归求出所有组合的，但是扑克牌有点数和花色，二维数组的组合枚举不会写……由于每一张牌都不同，所以把二维数组变成一维数组进行枚举，然后……不知怎么样反正就是<code>WA</code>了，判断牌型没出问题，但是找不出组合哪里出问题，纠结半天，也还是找不出来……后来看见某人发了说说才恍然大悟——这是一个搜索问题！😕</p>
<p>看数据比较小，25×4，多重<code>for</code>循环应该不会超时，所以后来直接暴力<code>for</code>循环求组合，但是又出现了新问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != a; i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != b; j++)</span><br><span class="line">		<span class="keyword">if</span> (!(i == a1 &amp;&amp; j == b1) &amp;&amp; !(i == a2 &amp;&amp; j == b2))</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> ii = i; ii != a; ii++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span>; jj != b; jj++)</span><br><span class="line">					<span class="keyword">if</span> (!(ii == a1 &amp;&amp; jj == b1) &amp;&amp; !(ii == a2 &amp;&amp; jj == b2) &amp;&amp;</span><br><span class="line">						!(ii == i &amp;&amp; jj == j))</span><br><span class="line">						<span class="keyword">for</span> (<span class="keyword">int</span> iii = ii; iii != a; iii++)</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> jjj = jj; jjj != b; jjj++)</span><br><span class="line">								<span class="keyword">if</span> (!(iii == a1 &amp;&amp; jjj == b1) &amp;&amp;</span><br><span class="line">									!(iii == a2 &amp;&amp; jjj == b2) &amp;&amp;</span><br><span class="line">									!(iii == i &amp;&amp; jjj == j) &amp;&amp;</span><br><span class="line">									!(iii == ii &amp;&amp; jjj == jj)) &#123;</span><br><span class="line">									<span class="function">poke <span class="title">p1</span><span class="params">(i, j)</span></span>;</span><br><span class="line">									pv.push_back(p1);</span><br><span class="line">									<span class="function">poke <span class="title">p2</span><span class="params">(ii, jj)</span></span>;</span><br><span class="line">									pv.push_back(p2);</span><br><span class="line">									<span class="function">poke <span class="title">p3</span><span class="params">(iii, jjj)</span></span>;</span><br><span class="line">									pv.push_back(p3);</span><br><span class="line">									sort(pv.<span class="built_in">begin</span>(), pv.<span class="built_in">end</span>(), cmp);</span><br><span class="line">									pokeKind(pv);</span><br><span class="line">								&#125;</span><br></pre></td></tr></table></figure>
<p>第二&amp;第三大次的<code>for</code>循环无法保证选的牌这一次和下一次选的不是相反的，比如第n次选牌，第二大次<code>for</code>循环选了红桃4，第三大次<code>for</code>循环选了黑桃4；然而第n+1次选牌，第二大次<code>for</code>循环选了黑桃4，第三大次<code>for</code>循环选了红桃4……</p>
<p>我的改进就是每2个小次的for循环合并，<code>手牌标号%总点数 = 当前点数</code>，<code>手牌标号/总点数= 当前花色</code>，比如<code>手牌(点数, 花色): (0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), ..., (4, 0), (4, 1)</code>标号就是<code>0, 1, 2, 3, 4, 5, ..., 8, 9</code>。</p>
<h3 id="排序后判断牌型"><a href="#排序后判断牌型" class="headerlink" title="排序后判断牌型"></a>排序后判断牌型</h3><p>我用了5个变量：<code>int sameC, diffC</code>：几组两两连续的点数相同/不同；<code>bool colorS, Shunza</code>：是否同花/顺子；<code>int diffPos</code>：最后一次出现连续两两不等的位置。</p>
<p>具体见<code>pokeKind()</code>函数区分。</p>
<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>有时暴力一下可能出奇迹……</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poke</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">point</span>;</span><br><span class="line">	<span class="keyword">int</span> color;</span><br><span class="line">	poke(<span class="keyword">int</span> p, <span class="keyword">int</span> c) :<span class="built_in">point</span>(p), color(c) &#123;  &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> poke p)<span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (p.<span class="built_in">point</span> == <span class="built_in">point</span>)</span><br><span class="line">			<span class="keyword">return</span> color &lt; p.color;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">point</span> &lt; p.<span class="built_in">point</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pK[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(poke a, poke b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pokeKind</span><span class="params">(<span class="built_in">vector</span>&lt;poke&gt; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sameC = <span class="number">0</span>, diffC = <span class="number">0</span>; <span class="comment">//4=; 3=&amp;2=; 3=; 2=&amp;2=; 2=</span></span><br><span class="line">	<span class="keyword">int</span> diffPos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> colorS = <span class="literal">true</span>;<span class="comment">//同花</span></span><br><span class="line">	<span class="keyword">bool</span> Shunza = <span class="literal">true</span>;<span class="comment">//顺子</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != v.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v[i].<span class="built_in">point</span> == v[i + <span class="number">1</span>].<span class="built_in">point</span>)</span><br><span class="line">			sameC++;</span><br><span class="line">		<span class="keyword">if</span> (v[i].<span class="built_in">point</span> != v[i + <span class="number">1</span>].<span class="built_in">point</span>) &#123;</span><br><span class="line">			diffC++;</span><br><span class="line">			diffPos = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (colorS == <span class="literal">true</span> &amp;&amp; v[i].color != v[i + <span class="number">1</span>].color)</span><br><span class="line">			colorS = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (Shunza == <span class="literal">true</span> &amp;&amp; v[i].<span class="built_in">point</span> + <span class="number">1</span> != v[i + <span class="number">1</span>].<span class="built_in">point</span>)</span><br><span class="line">			Shunza = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (colorS == <span class="literal">true</span> &amp;&amp; Shunza == <span class="literal">true</span>) &#123;</span><br><span class="line">		pK[<span class="number">0</span>]++;<span class="comment">//1 同花顺</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sameC == <span class="number">3</span> &amp;&amp; diffC == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (diffPos == <span class="number">0</span> || diffPos == <span class="number">3</span>)</span><br><span class="line">			pK[<span class="number">1</span>]++;<span class="comment">//2 炸弹</span></span><br><span class="line">		<span class="keyword">if</span> (diffPos == <span class="number">1</span> || diffPos == <span class="number">2</span>)</span><br><span class="line">			pK[<span class="number">2</span>]++;<span class="comment">//3 三带二</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (colorS == <span class="literal">true</span> &amp;&amp; Shunza == <span class="literal">false</span>) &#123;</span><br><span class="line">		pK[<span class="number">3</span>]++;<span class="comment">//4 同花</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (colorS == <span class="literal">false</span> &amp;&amp; Shunza == <span class="literal">true</span>) &#123;</span><br><span class="line">		pK[<span class="number">4</span>]++;<span class="comment">//5 顺子</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sameC == <span class="number">2</span> &amp;&amp; diffC == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">bool</span> same3 = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=v.<span class="built_in">size</span>()<span class="number">-2</span>;i++)</span><br><span class="line">			<span class="keyword">if</span> (v[i].<span class="built_in">point</span> == v[i + <span class="number">2</span>].<span class="built_in">point</span>)</span><br><span class="line">				same3 = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (same3 == <span class="literal">true</span>)</span><br><span class="line">			pK[<span class="number">5</span>]++;<span class="comment">//6 三条</span></span><br><span class="line">		<span class="keyword">if</span> (same3 == <span class="literal">false</span>)</span><br><span class="line">			pK[<span class="number">6</span>]++;<span class="comment">//7 两对</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sameC == <span class="number">1</span> &amp;&amp; diffC == <span class="number">3</span>) &#123;</span><br><span class="line">		pK[<span class="number">7</span>]++;<span class="comment">//8 一对</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pK[<span class="number">8</span>]++;<span class="comment">//9 要不起</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> a1, b1, a2, b2;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; a2 &gt;&gt; b2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">		pK[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != a * b - <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> ai = i % a, bi = i / a;</span><br><span class="line">		<span class="keyword">if</span> (!(ai == a1 &amp;&amp; bi == b1) &amp;&amp; !(ai == a2 &amp;&amp; bi == b2)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j != a * b - <span class="number">1</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> aj = j % a, bj = j / a;</span><br><span class="line">				<span class="keyword">if</span> (!(aj == a1 &amp;&amp; bj == b1) &amp;&amp; !(aj == a2 &amp;&amp; bj == b2)) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k != a * b; k++) &#123;</span><br><span class="line">						<span class="keyword">int</span> ak = k % a, bk = k / a;</span><br><span class="line">						<span class="keyword">if</span> (!(ak == a1 &amp;&amp; bk == b1) &amp;&amp; !(ak == a2 &amp;&amp; bk == b2)) &#123;</span><br><span class="line">							<span class="function">poke <span class="title">o1</span><span class="params">(a1, b1)</span></span>;</span><br><span class="line">							<span class="function">poke <span class="title">o2</span><span class="params">(a2, b2)</span></span>;</span><br><span class="line">							<span class="built_in">vector</span>&lt;poke&gt; pv;</span><br><span class="line">							pv.push_back(o1);</span><br><span class="line">							pv.push_back(o2);</span><br><span class="line">							</span><br><span class="line">							<span class="function">poke <span class="title">p1</span><span class="params">(ai, bi)</span></span>;</span><br><span class="line">							pv.push_back(p1);</span><br><span class="line">							<span class="function">poke <span class="title">p2</span><span class="params">(aj, bj)</span></span>;</span><br><span class="line">							pv.push_back(p2);</span><br><span class="line">							<span class="function">poke <span class="title">p3</span><span class="params">(ak, bk)</span></span>;</span><br><span class="line">							pv.push_back(p3);</span><br><span class="line">							sort(pv.<span class="built_in">begin</span>(), pv.<span class="built_in">end</span>(), cmp);</span><br><span class="line">							pokeKind(pv);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pK[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>扑克牌手牌排序</title>
    <url>/2020/03/05/%E6%89%91%E5%85%8B%E7%89%8C%E6%89%8B%E7%89%8C%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="扑克牌手牌排序"><a href="#扑克牌手牌排序" class="headerlink" title="扑克牌手牌排序"></a><strong>扑克牌手牌排序</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">瑞神HRZ因为疫情在家闲得无聊，同时他又非常厉害，所有的课对他来说都是水一水就能拿A+，所以他无聊，找来了另外三个人：咕咕东，腾神以及zjm来打牌(天下苦瑞神久矣)。</span><br><span class="line">显然，牌局由四个人构成，围成一圈。我们称四个方向为北 东 南 西。对应的英文是North，East，South，West。游戏一共由一副扑克，也就是52张构成。开始，我们指定一位发牌员(东南西北中的一个，用英文首字母标识)开始发牌，发牌顺序为顺时针，发牌员第一个不发自己，而是发他的下一个人(顺时针的下一个人)。这样，每个人都会拿到13张牌。</span><br><span class="line">现在我们定义牌的顺序，首先，花色是 梅花 &lt; 方片 &lt; 黑桃 &lt; 红桃，(输入时，我们用C, D, S, H分别表示梅花，方片，黑桃，红桃，即其单词首字母)。对于牌面的值，我们规定 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; T &lt; J &lt; Q &lt; K &lt; A。</span><br><span class="line">现在你作为上帝，你要从小到大排序每个人手中的牌，并按照给定格式输出。(具体格式见输出描述和样例输出)。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入包含多组数据</span><br><span class="line">每组数据的第一行包含一个大写字符，表示发牌员是谁。如果该字符为‘#’则表示输入结束。</span><br><span class="line">接下来有两行，每行有52个字符，表示了26张牌，两行加起来一共52张牌。每张牌都由两个字符组成，第一个字符表示花色，第二个字符表示数值。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出多组数据发牌的结果，每组数据之后需要额外多输出一个空行！！！！！</span><br><span class="line">每组数据应该由24行的组成，输出按照顺时针方向，始终先输出South Player的结果，每位玩家先输出一行即玩家名称(东南西北)，接下来五行，第一行和第五行输出固定格式(见样例)，第二行和第四行按顺序和格式输出数值(见样例)，第三行按顺序和格式输出花色(见样例)。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">N</span><br><span class="line">CTCAH8CJD4C6D9SQC7S5HAD2HJH9CKD3H6D6D7H3HQH4C5DKHKS9</span><br><span class="line">SJDTS3S7S4C4CQHTSAH2D8DJSTSKS2H5D5DQDAH7C9S8C8S6C2C3</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">South player:</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">|6 6|A A|6 6|J J|5 5|6 6|7 7|9 9|4 4|5 5|7 7|9 9|T T|</span><br><span class="line">| C | C | D | D | S | S | S | S | H | H | H | H | H |</span><br><span class="line">|6 6|A A|6 6|J J|5 5|6 6|7 7|9 9|4 4|5 5|7 7|9 9|T T|</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">West player:</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">|2 2|5 5|9 9|K K|5 5|7 7|9 9|4 4|T T|J J|A A|8 8|A A|</span><br><span class="line">| C | C | C | C | D | D | D | S | S | S | S | H | H |</span><br><span class="line">|2 2|5 5|9 9|K K|5 5|7 7|9 9|4 4|T T|J J|A A|8 8|A A|</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">North player:</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">|3 3|4 4|J J|2 2|3 3|T T|Q Q|K K|8 8|Q Q|K K|2 2|3 3|</span><br><span class="line">| C | C | C | D | D | D | D | D | S | S | S | H | H |</span><br><span class="line">|3 3|4 4|J J|2 2|3 3|T T|Q Q|K K|8 8|Q Q|K K|2 2|3 3|</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">East player:</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">|7 7|8 8|T T|Q Q|4 4|8 8|A A|2 2|3 3|6 6|J J|Q Q|K K|</span><br><span class="line">| C | C | C | C | D | D | D | S | S | H | H | H | H |</span><br><span class="line">|7 7|8 8|T T|Q Q|4 4|8 8|A A|2 2|3 3|6 6|J J|Q Q|K K|</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+---+---+---+</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>注意一下格式就行。虽然说题目<del>又臭又长</del>(其实不长)，输入输出一大串，本题不算难。考察的还是排序。<br>输出顺时针按<code>SWNE</code>，输入首个算然不是固定但也是顺时针，所以录入4维数组时可以根据输入的首个处理录入位。详见如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input order			N-E-S-W		E-S-W-N		S-W-N-E		W-N-E-S</span><br><span class="line">position adjustment	 (+2)%4		 (+3)%4		    0		 (+1)%4</span><br></pre></td></tr></table></figure>
<p>然后根据上述位差按序录入数组。录入之后就是排序问题。先按花色排序，可以通过<code>map</code>将<code>梅花到红桃</code>分别对应为<code>0到3</code>，点数<code>2到A</code>分别对应<code>0到12</code>，再比较大小即可。<br>解题过程详见代码。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*扑克牌结构体 花色+点数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poker</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> colour;<span class="comment">//花色</span></span><br><span class="line">	<span class="keyword">char</span> points;<span class="comment">//点数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据发牌员判断发牌顺序，用于矫正录入顺序*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">playerNum</span><span class="params">(<span class="keyword">char</span> dealer)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dealer == <span class="string">'N'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (dealer == <span class="string">'E'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (dealer == <span class="string">'S'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (dealer == <span class="string">'W'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序用于输出 固定为 S - W - N - E */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playerWho</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"South player:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"West player:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"North player:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"East player:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> dealer;<span class="comment">// ... -&gt; N -&gt; E -&gt; S -&gt; W -&gt; N -&gt; ...//发牌员</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; colour;<span class="comment">//编号花色 用于排序</span></span><br><span class="line">	colour[<span class="string">'C'</span>] = <span class="number">0</span>;</span><br><span class="line">	colour[<span class="string">'D'</span>] = <span class="number">1</span>;</span><br><span class="line">	colour[<span class="string">'S'</span>] = <span class="number">2</span>;</span><br><span class="line">	colour[<span class="string">'H'</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; points;<span class="comment">//编号点数 用于排序</span></span><br><span class="line">	points[<span class="string">'2'</span>] = <span class="number">0</span>;</span><br><span class="line">	points[<span class="string">'3'</span>] = <span class="number">1</span>;</span><br><span class="line">	points[<span class="string">'4'</span>] = <span class="number">2</span>;</span><br><span class="line">	points[<span class="string">'5'</span>] = <span class="number">3</span>;</span><br><span class="line">	points[<span class="string">'6'</span>] = <span class="number">4</span>;</span><br><span class="line">	points[<span class="string">'7'</span>] = <span class="number">5</span>;</span><br><span class="line">	points[<span class="string">'8'</span>] = <span class="number">6</span>;</span><br><span class="line">	points[<span class="string">'9'</span>] = <span class="number">7</span>;</span><br><span class="line">	points[<span class="string">'T'</span>] = <span class="number">8</span>;</span><br><span class="line">	points[<span class="string">'J'</span>] = <span class="number">9</span>;</span><br><span class="line">	points[<span class="string">'Q'</span>] = <span class="number">10</span>;</span><br><span class="line">	points[<span class="string">'K'</span>] = <span class="number">11</span>;</span><br><span class="line">	points[<span class="string">'A'</span>] = <span class="number">12</span>;</span><br><span class="line">	<span class="comment">/*这样写的太长了</span></span><br><span class="line"><span class="comment">	其实可以用一个数组跟一个for循环进行赋值</span></span><br><span class="line"><span class="comment">	但是已经写了 所以就懒得改了*/</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; dealer) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dealer == <span class="string">'#'</span>)<span class="comment">//判断终止读入</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		poker player[<span class="number">4</span>][<span class="number">13</span>];<span class="comment">//玩家的手牌 存到一个二维数组内</span></span><br><span class="line">        <span class="comment">//数组的行数编号与 S - W - N - E 一一对应 所以要处理录入的赋值顺序</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> posAdj = playerNum(dealer);<span class="comment">//adjust input order</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//input</span></span><br><span class="line">        <span class="comment">//按照顺时针方向录入  每圈给4人发4张  扣去大小王 这样的圈共13个</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;<span class="comment">//每次4个玩家</span></span><br><span class="line">				poker x;<span class="comment">//1张牌</span></span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; x.colour &gt;&gt; x.points;<span class="comment">//花色、点数</span></span><br><span class="line">				player[(j + posAdj) % <span class="number">4</span>][i] = x;<span class="comment">//位置矫正后录入数组</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//order</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;<span class="comment">//对每个玩家</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">13</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">12</span> - j; k++) &#123;<span class="comment">//对牌冒泡排序</span></span><br><span class="line">					<span class="keyword">if</span> (colour[player[i][k].colour] &gt; colour[player[i][k + <span class="number">1</span>].colour])<span class="comment">//先按照花色</span></span><br><span class="line">						swap(player[i][k], player[i][k + <span class="number">1</span>]);</span><br><span class="line">					<span class="keyword">if</span> (colour[player[i][k].colour] == colour[player[i][k + <span class="number">1</span>].colour]) &#123;<span class="comment">//花色相同时</span></span><br><span class="line">						<span class="keyword">if</span> (points[player[i][k].points] &gt; points[player[i][k + <span class="number">1</span>].points])<span class="comment">//按照点数</span></span><br><span class="line">							swap(player[i][k], player[i][k + <span class="number">1</span>]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//output</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;<span class="comment">//一个一个玩家依次输出</span></span><br><span class="line">			playerWho(i);<span class="comment">//输出东西南北哪个玩家</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"+---+---+---+---+---+---+---+---+---+---+---+---+---+"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">13</span>; j++)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> &lt;&lt; player[i][j].points &lt;&lt; <span class="string">" "</span> &lt;&lt; player[i][j].points;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">13</span>; j++)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"| "</span> &lt;&lt; player[i][j].colour &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">13</span>; j++)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> &lt;&lt; player[i][j].points &lt;&lt; <span class="string">" "</span> &lt;&lt; player[i][j].points;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"+---+---+---+---+---+---+---+---+---+---+---+---+---+"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>排序问题</tag>
      </tags>
  </entry>
  <entry>
    <title>最大矩形</title>
    <url>/2020/03/21/%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a><strong>最大矩形</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给一个直方图，求直方图中的最大矩形的面积。</span><br><span class="line">例如，下面这个图片中直方图的高度从左到右分别是2, 1, 4, 5, 1, 3, 3, 他们的宽都是1，其中最大的矩形是阴影部分。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/03/21/yL5phGK9S2vljgs.gif" alt="Max_rec.png"></p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入包含多组数据。每组数据用一个整数n来表示直方图中小矩形的个数，你可以假定1 ≤ n ≤ 100000. 然后接下来n个整数h1, ..., hn, 满足 0 ≤ hi ≤ 1000000000. 这些数字表示直方图中从左到右每个小矩形的高度，每个小矩形的宽度为1。 测试数据以0结尾。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于每组测试数据输出一行一个整数表示答案。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">7 2 1 4 5 1 3 3</span><br><span class="line">4 1000 1000 1000 1000</span><br><span class="line">0</span><br><span class="line">Output: </span><br><span class="line">8</span><br><span class="line">4000</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	32768 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p><code>直方图的矩形面积 = (右端点 - 左端点) × 限制高度</code>，每次维护一个左端点和右端点，用最小高度计算矩形面积，暴力做法就是对于每一个柱形图往左&amp;往右找第一个小于他的高度的左/右端点，得到宽度，再乘上高度就能更新最大面积，时间复杂度为<em>O</em>(<em>n</em><sup>2</sup>)，显然后面会超时。</p>
<p>这里就要用到单调栈。</p>
<p>每次维护矩形的左右端点的高度，利用单调非增栈，开始遇到矮的就弹栈，否则入栈并一直更新右端点，这样就能在线性时间内找到第一个比当前元素小的右端点高度，每一次弹栈的过程中更新矩形的最大面积。</p>
<p>这题比较要注意的就是后面 h 会很大，面积可能会超出<code>int</code>的范围，所以高度和面积的数据类型要用<code>long long</code>。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">height</span>;</span><br><span class="line">	<span class="keyword">int</span> left;</span><br><span class="line">	rec() &#123; <span class="built_in">height</span> = <span class="number">0</span>; left = <span class="number">0</span>; &#125;</span><br><span class="line">	rec(<span class="keyword">long</span> <span class="keyword">long</span> h, <span class="keyword">int</span> l) :<span class="built_in">height</span>(h), left(l) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (!(<span class="built_in">cin</span> &gt;&gt; n).eof()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		rec arr[<span class="number">100005</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">long</span> <span class="keyword">long</span> h;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; h;</span><br><span class="line">			<span class="function">rec <span class="title">r</span><span class="params">(h, i)</span></span>;</span><br><span class="line">			arr[i] = r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;<span class="comment">//答案</span></span><br><span class="line">		<span class="built_in">stack</span>&lt;rec&gt; st;<span class="comment">//栈</span></span><br><span class="line">		rec temp;</span><br><span class="line">		st.push(arr[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> l = arr[i].left;<span class="comment">//矩形的右端点</span></span><br><span class="line">			<span class="keyword">while</span> (!st.empty() &amp;&amp; st.top().<span class="built_in">height</span> &gt; arr[i].<span class="built_in">height</span>) &#123;</span><br><span class="line">                <span class="comment">//遇到了矮的 开始弹栈</span></span><br><span class="line">				temp = st.top();</span><br><span class="line">				st.pop();</span><br><span class="line">				arr[i].left = temp.left;<span class="comment">//更新左端点</span></span><br><span class="line">				<span class="keyword">long</span> <span class="keyword">long</span> sq = (l - temp.left) * temp.<span class="built_in">height</span>;<span class="comment">//计算面积</span></span><br><span class="line">				ans = <span class="built_in">max</span>(sq, ans);</span><br><span class="line">			&#125;</span><br><span class="line">			st.push(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="comment">//最后清栈</span></span><br><span class="line">			temp = st.top();</span><br><span class="line">			st.pop();</span><br><span class="line">			<span class="keyword">long</span> <span class="keyword">long</span> sq = (n - temp.left) * temp.<span class="built_in">height</span>;</span><br><span class="line">			ans = <span class="built_in">max</span>(sq, ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据中心</title>
    <url>/2020/03/30/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h1 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a><strong>数据中心</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个集中式网络中，存在一个根节点，需要长时间接收其余结点传输给它的反馈数据。</span><br><span class="line">存在一个 n 结点的网络图，编号从 1 到 n。该网络的传输时全双工的，所以是无向图。如果两结点 vi, ui 相连，表明 vi, ui 之间可以互相收发数据，边权是传输数据所需时间 ti。现在每个结点需要选择一条路径将数据发送到 root 号节点。希望求出一个最优的树结构传输图，使得完成这个任务所需要的时间最少。root 结点只能接收数据，其余任何一个节点可以将数据传输给另外的一个节点，但是不能将数据传输给多个节点。所有节点可以接收多个不同节点的数据。</span><br><span class="line">一个树结构传输图的传输时间为Tmax，其中Tmax &#x3D; max(Th), h为接收点在树中的深度，Th &#x3D; max(th,j), th,j表示 j 条不同的边，这 j 条边接收点的深度都为 h。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从标准输入读入数据。</span><br><span class="line">输入的第 1 行包含一个正整数 n，保证 n ≤ 5 × 10^4</span><br><span class="line">输入的第 2 行包含一个正整数 m，保证 m ≤ 10^5。</span><br><span class="line">输入的第 3 行包含一个正整数 root，保证 root ≤ 5 × 10^4</span><br><span class="line">输入的第 4 行至第 3+m 行包含 3 个正整数 vi, ui, ti，保证 vi ≤ 5 × 10^4, ui ≤ 5 × 10^4, ti ≤ 10^6, vi ≠ ui。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出到标准输出。</span><br><span class="line">输出仅有一行，包含一个正整数 ans，表示最优的树结构流水线所耗时 Tmax。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">1 2 3</span><br><span class="line">1 3 4</span><br><span class="line">1 4 5</span><br><span class="line">2 3 8</span><br><span class="line">3 4 2</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">1 2 3</span><br><span class="line">1 3 4</span><br><span class="line">1 4 5</span><br><span class="line">2 3 8</span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a><strong>Note</strong></h2><p><img src="https://i.loli.net/2020/04/03/juJwNGV2FL7dXm5.png" alt="image-20200403020036204.png"></p>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	524288 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p><del>本题又臭又长，题设变量花里胡哨，样例解释东拉西扯，</del>题意大致就是n个节点的带权无向图，连接每个点求总权重最小，其实就是一个最小生成树问题，可以用Kruskal算法，算法具体思路同上一篇。</p>
<p>就是吐槽一下test好像跑了120组，测试用了7分钟……也太多了吧，在那等着出结果等的心好慌，测那么多万一<code>WA</code>了还是啥的会崩溃的……🙃</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">305</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u, v, w;</span><br><span class="line">	edge(<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _w) :u(_u), v(_v), w(_w) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (par[x] == x)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;edge&gt; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> edgeCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">		par[i] = i;</span><br><span class="line">	sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> p1 = <span class="built_in">find</span>(v[i].u);</span><br><span class="line">		<span class="keyword">int</span> p2 = <span class="built_in">find</span>(v[i].v);</span><br><span class="line">		<span class="keyword">if</span> (p1 != p2) &#123;</span><br><span class="line">			par[p1] = p2;</span><br><span class="line">			ans += v[i].w;</span><br><span class="line">			edgeCount++;</span><br><span class="line">			<span class="keyword">if</span> (edgeCount == n)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;edge&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		<span class="function">edge <span class="title">e1</span><span class="params">(<span class="number">0</span>, i, a)</span></span>;</span><br><span class="line">		<span class="function">edge <span class="title">e2</span><span class="params">(i, <span class="number">0</span>, a)</span></span>;</span><br><span class="line">		v.push_back(e1);</span><br><span class="line">		v.push_back(e2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> a;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">			<span class="keyword">if</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="function">edge <span class="title">e</span><span class="params">(i, j, a)</span></span>;</span><br><span class="line">				v.push_back(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = kruskal(n, v);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>新数组中位数问题</title>
    <url>/2020/03/19/%E6%96%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="新数组中位数问题"><a href="#新数组中位数问题" class="headerlink" title="新数组中位数问题"></a><strong>新数组中位数问题</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个 N 个数的数组 cat[i]，并用这个数组生成一个新数组 ans[i]。新数组定义为对于任意的 i, j 且 i !&#x3D; j，均有 ans[] &#x3D; abs(cat[i] - cat[j])，1 ≤ i &lt; j ≤ N。试求出这个新数组的中位数，中位数即为排序之后 (len+1)&#x2F;2 位置对应的数字，&#39;&#x2F;&#39; 为下取整。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多组输入，每次输入一个 N，表示有 N 个数，之后输入一个长度为 N 的序列 cat, cat[i] ≤ 1e9, 3 ≤ n ≤ 1e5</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出新数组 ans 的中位数</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">4</span><br><span class="line">1 3 2 4</span><br><span class="line">3</span><br><span class="line">1 10 2</span><br><span class="line">Output: </span><br><span class="line">1</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	65536 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>C题嘛，自然对时间复杂度要求严格，暴力求解会<code>TLE</code>，而且<code>cin</code>读入慢所以要采用<code>scanf()</code>。</p>
<p>产生的新数列全都不小于0，且原数列排序后<code>cat[n - 1] - cat[0]</code>一定是新数列中的最大数，也就是第<code>n × (n - 1) / 2 - 1</code>个，新数列排序后是单调递增的，而中位数就位于中间，因此可以对产生的新数进行二分：若新数的排名低于<code>n × (n - 1) / 2</code>，则它一定在中位数前面，若高于，则在后面，若等于，则就是所求的中位数。</p>
<p>问题来了，没有求出新数列，如何计算名次？<br>首先原数列是有序排列的，所以可以利用两个指针 <em>i</em>, <em>j</em>，<em>j</em>从第二位开始一直往后扫，同时i从第一位开始，一直扫到 <em>j</em> 的前面，计算<code>cat[j] - cat[i]</code>的值，如果大于目标数，则说明目标排名的后面有这个数，则可增加 <em>i</em>，求出最逼近目标排名的坐标，<em>j</em> - <em>i</em> 表示对于这个 <em>j</em>，目标之前一定有这么多个数在他前面；把所有可行的 <em>j</em> 遍历完后就可求出相对应的 <em>j</em> - <em>i</em>，这些 <em>j</em> - <em>i</em> 求和就是目标的名次。</p>
<p>港真，课上如果没说，真的很难想到这个层面……</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Rank</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>, rank = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (arr[j] - arr[i] &gt; a)<span class="comment">//对于每一个j, 求得距离</span></span><br><span class="line">			i++;</span><br><span class="line">		rank += (j - i);<span class="comment">//这些距离之和就是名次</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (scanf_s(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">		<span class="keyword">int</span>* cat = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			scanf_s(<span class="string">"%d"</span>, &amp;cat[i]);<span class="comment">//后面一直出问题 就索性从1开始记位</span></span><br><span class="line">		sort(cat + <span class="number">1</span>, cat + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> N = n * (n - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//新数组的元素个数</span></span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">1</span>, <span class="built_in">end</span> = cat[n];</span><br><span class="line">		<span class="keyword">int</span> aim = (N + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//目标中位数的位置，根据题意取的+1</span></span><br><span class="line">		<span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">begin</span> &lt;= <span class="built_in">end</span>) &#123;<span class="comment">//二分求中位数</span></span><br><span class="line">			middle = (<span class="built_in">begin</span> + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">begin</span> == <span class="built_in">end</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">int</span> theRank = Rank(middle, cat, n);<span class="comment">//当前名次</span></span><br><span class="line">			<span class="keyword">if</span> (theRank &gt;= aim)<span class="comment">//in the left</span></span><br><span class="line">				<span class="built_in">end</span> = middle;</span><br><span class="line">			<span class="keyword">if</span> (theRank &lt; aim)<span class="comment">//in the right</span></span><br><span class="line">				<span class="built_in">begin</span> = middle + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, middle);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>烷烃基的类别</title>
    <url>/2020/03/05/%E7%83%B7%E7%83%83%E5%9F%BA%E7%9A%84%E7%B1%BB%E5%88%AB/</url>
    <content><![CDATA[<h1 id="烷烃基的类别"><a href="#烷烃基的类别" class="headerlink" title="烷烃基的类别"></a><strong>烷烃基的类别</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><p>化学很神奇，以下是烷烃基。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Name</th>
<th>HDMG</th>
<th>Name</th>
<th>HDMG</th>
</tr>
</thead>
<tbody>
<tr>
<td>n-hexane</td>
<td><img src="https://i.loli.net/2020/03/06/PDuvRZLO5YrmIB8.png" alt="01.png"></td>
<td>2-methylpentane</td>
<td><img src="https://i.loli.net/2020/03/06/lVBZqugfItOzmFU.png" alt="02.png"></td>
</tr>
<tr>
<td>3-methylpentane</td>
<td><img src="https://i.loli.net/2020/03/06/i1RbSPtM5yoCecp.png" alt="03.png"></td>
<td>2,3-dimethylbutane</td>
<td><img src="https://i.loli.net/2020/03/06/ADbymgKM5S1YFJt.png" alt="04.png"></td>
</tr>
<tr>
<td>2,2-dimethylbutane</td>
<td><img src="https://i.loli.net/2020/03/06/delSR7chwiEG4oV.png" alt="05.png"></td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<p>假设如上图，这个烷烃基有6个原子和5个化学键，6个原子分别标号1~6，然后用一对数字 a,b 表示原子a和原子b间有一个化学键。这样通过5行a,b可以描述一个烷烃基<br>你的任务是甄别烷烃基的类别。<br>原子没有编号方法，比如<br>1 2<br>2 3<br>3 4<br>4 5<br>5 6<br>和<br>1 3<br>2 3<br>2 4<br>4 5<br>5 6<br>是同一种，本质上就是一条链，编号其实是没有关系的，可以在纸上画画就懂了</p>
<h2 id="input"><a href="#input" class="headerlink" title="input"></a><strong>input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入第一行为数据的组数 T (1 ≤ T ≤ 200000)。</span><br><span class="line">每组数据有5行，每行是两个整数 a, b (1 ≤ a,b ≤ 6, a ≤ b)</span><br><span class="line">数据保证，输入的烷烃基是以上5种之一</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每组数据，输出一行，代表烷烃基的英文名</span><br></pre></td></tr></table></figure>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a><strong>Example</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">Output: </span><br><span class="line">n-hexane</span><br><span class="line">3-methylpentane</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><ol>
<li><p>对烷烃基标号</p>
<p>对于每一个标号可以用<code>数组标号+1</code>表示，其连接的其他碳原子<code>标号-1</code>用链表储存。<br>对于上述5种烷烃基，可以得到如下邻接链表结构：</p>
<p>| Name               | HDMG                   | Structure                                                    |<br>| ————————— | ——————————— | —————————————————————————————— |<br>| n-hexane           | <img src="https://i.loli.net/2020/03/06/7WRikFoTcJSUZgm.png" alt="06.png"> | <code>[1]→2</code><br><code>[2]→1→3</code><br><code>[3]→2→4</code><br><code>[4]→3→5</code><br><code>[5]→4→6</code><br><code>[6]→5</code> |<br>| 2-methylpentane    | <img src="https://i.loli.net/2020/03/06/WTZyfRF7UheqptI.png" alt="07.png"> | <code>[1]→2</code><br><code>[2]→1→3→4</code><br><code>[3]→2</code><br><code>[4]→2→5</code><br><code>[5]→4→6</code><br><code>[6]→5</code> |<br>| 3-methylpentane    | <img src="https://i.loli.net/2020/03/06/9Pg1Wzmsy3bMG7C.png" alt="08.png"> | <code>[1]→2</code><br><code>[2]→1→3</code><br><code>[3]→2→4→5</code><br><code>[4]→3</code><br><code>[5]→3→6</code><br><code>[6]→5</code> |<br>| 2,3-dimethylbutane | <img src="https://i.loli.net/2020/03/06/hns7fKtdUEr6vi2.png" alt="09.png"> | <code>[1]→2</code><br><code>[2]→1→3→4</code><br><code>[3]→2</code><br><code>[4]→2→5→6</code><br><code>[5]→4</code><br><code>[6]→4</code> |<br>| 2,2-dimethylbutane | <img src="https://i.loli.net/2020/03/06/RlrhLUBGVP3ifD8.png" alt="10.png"> | <code>[1]→2</code><br><code>[2]→1→3→4→5</code><br><code>[3]→2</code><br><code>[4]→2</code><br><code>[5]→2→6</code><br><code>[6]→5</code> |</p>
</li>
<li><p>初次鉴别<br>标号不管怎么变都无法影响烷烃基的种类，但是观察邻接链表，不难发现链长可以进行初次区分。</p>
<p>| 正己烷 | 2-甲基苯丙烷 | 3-甲基苯丙烷 | 2,3-二甲基丁烷 | 2,2-二甲基丁烷 |<br>| :——: | :—————: | :—————: | :——————: | :——————: |<br>|   1    |      1       |      1       |       1        |       1        |<br>|   2    |      3       |      2       |       3        |       4        |<br>|   2    |      1       |      3       |       1        |       1        |<br>|   2    |      2       |      1       |       3        |       1        |<br>|   2    |      2       |      2       |       1        |       2        |<br>|   1    |      1       |      1       |       1        |       1        |</p>
</li>
</ol>
<p>可以设3个<code>int</code>变量<code>count2, count3, count4</code>用来记录<code>链长 = x</code>的出现次数。<br>   只有<em>2,2-dimethylbutane</em>的<code>count4 = 1</code>;<br>   只有<em>n-hexane</em>的<code>count2 = 4</code>;<br>   只有<em>2,3-dimethylbutane</em>的<code>count3 = 2</code>;<br>   对于<em>2-methylpentane</em>和<em>3-methylpentane</em>，<code>count2 = 2, count3 = 1, count4 = 0</code>，无法通过链长来区分。</p>
<ol>
<li>鉴别<em>2-methylpentane</em>和<em>3-methylpentane</em><br>不难发现，不管怎么编号(正/反)，当<code>链长 = 3</code>时，与这个碳原子相连的甲基个数不同。因此可记录<code>链长 = 3</code>时数组编号<code>no</code>，然后找到此数组所在的链<code>arr[no]</code>，记录该条链储存的元素，即记录与之相连的碳原子的编号。<br>比如图中<em>2-methylpentane</em>与<code>2</code>相连的是<code>1, 3, 4</code>，属于甲基(即<code>链长 = 1</code>)的是<code>1, 3</code>;<br><em>3-methylpentane</em>与<code>3</code>相连的是<code>2, 4, 5</code>，属于甲基的是<code>4</code>。<br><em>2-methylpentane</em>的甲基个数为2，<em>3-methylpentane</em>的甲基个数为1，以此鉴别。</li>
</ol>
<h2 id="数据结构及实现方法"><a href="#数据结构及实现方法" class="headerlink" title="数据结构及实现方法"></a><strong>数据结构及实现方法</strong></h2><p>采用邻接链表表示的有向图，本题只需提供插入、查找、遍历操作。详见源代码注释。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*链表的节点*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	node* next;</span><br><span class="line">	node() &#123; a = <span class="number">0</span>; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">	node(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a) &#123; <span class="keyword">this</span>-&gt;a = a; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">	node(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, node* next) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;	<span class="keyword">this</span>-&gt;next = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*链表*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">chain</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	node* firstNode;<span class="comment">//指向链表头节点的指针</span></span><br><span class="line">	<span class="keyword">int</span> listSize;<span class="comment">//链表长度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	chain(<span class="keyword">int</span> initialCapacity = <span class="number">10</span>) &#123;<span class="comment">//初始化构造函数</span></span><br><span class="line">		firstNode = <span class="literal">NULL</span>;</span><br><span class="line">		listSize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	chain(<span class="keyword">const</span> chain&amp;);</span><br><span class="line">	~chain() &#123;<span class="comment">//析构函数</span></span><br><span class="line">		<span class="keyword">while</span> (firstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			node* nextNode = firstNode-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> firstNode;</span><br><span class="line">			firstNode = nextNode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> listSize; &#125;<span class="comment">//返回链表长度</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; theElement)</span> </span>&#123;<span class="comment">//链表的有序插入操作</span></span><br><span class="line">		<span class="keyword">if</span> (firstNode == <span class="literal">NULL</span>)<span class="comment">//当链表为空时，直接插入</span></span><br><span class="line">			firstNode = <span class="keyword">new</span> node(theElement, firstNode);</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//链表非空时</span></span><br><span class="line">			node* p = firstNode;<span class="comment">//指向头节点的指针</span></span><br><span class="line">			node* pp = <span class="literal">NULL</span>;<span class="comment">//指针pp紧跟p的后面</span></span><br><span class="line">			<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;a &lt; theElement) &#123;<span class="comment">//要插入的元素小于当前指向的节点</span></span><br><span class="line">				pp = p;<span class="comment">//pp跟上p</span></span><br><span class="line">				p = p-&gt;next;<span class="comment">//p指向下一节点</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//到了合适的插入位</span></span><br><span class="line">			node* newNode = <span class="keyword">new</span> node(theElement, p);<span class="comment">//新建节点，插入的元素指向p</span></span><br><span class="line">			<span class="keyword">if</span> (pp == <span class="literal">NULL</span>)<span class="comment">//当插入为头节点时</span></span><br><span class="line">				firstNode = newNode;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//否则，插入点之前的指针指向新节点</span></span><br><span class="line">				pp-&gt;next = newNode;</span><br><span class="line">		&#125;</span><br><span class="line">		listSize++;<span class="comment">//每次成功插入，链表大小+1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; theElement)</span> <span class="keyword">const</span> </span>&#123;<span class="comment">//获取该元素所在位置</span></span><br><span class="line">		node* currentNode = firstNode;</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (currentNode != <span class="literal">NULL</span> &amp;&amp; currentNode-&gt;a != theElement) &#123;<span class="comment">//遍历即可</span></span><br><span class="line">			currentNode = currentNode-&gt;next;</span><br><span class="line">			index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (currentNode == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//未找到时返回-1</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> index;<span class="comment">//找到时返回index</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getElement</span><span class="params">()</span> </span>&#123;<span class="comment">//遍历，获取链表所有元素，用vector储存</span></span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nei;</span><br><span class="line">		node *p = firstNode;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			nei.push_back(p-&gt;a);</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nei;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ane</span> &#123;</span><span class="comment">//烷烃基无向图的类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	chain arr[<span class="number">6</span>];<span class="comment">//邻接链表，每个碳原子标号，0~5一一对应</span></span><br><span class="line">	<span class="keyword">int</span> chainSize[<span class="number">6</span>];<span class="comment">//记录每条链的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ane()&#123; &#125;</span><br><span class="line">	~ane()&#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//向无向图中插入点</span></span><br><span class="line">		<span class="keyword">if</span> (arr[a].indexOf(b) == <span class="number">-1</span>) &#123;<span class="comment">//未找到，即标号还未存在时插入</span></span><br><span class="line">			arr[a].insert(b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;<span class="comment">//6个点插入完成后，记录每条链大小</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">			chainSize[i] = arr[i].getSize();</span><br><span class="line">			<span class="comment">//cout &lt;&lt; chainSize[i] &lt;&lt; endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">type</span><span class="params">()</span> </span>&#123;<span class="comment">//判断属于哪种烷</span></span><br><span class="line">		<span class="keyword">int</span> count2 = <span class="number">0</span>, count3 = <span class="number">0</span>, count4 = <span class="number">0</span>;<span class="comment">/*分别记录</span></span><br><span class="line"><span class="comment">		链长 = 2，链长 = 3，链长 = 4出现次数*/</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (chainSize[i] == <span class="number">2</span>)</span><br><span class="line">				count2++;</span><br><span class="line">			<span class="keyword">if</span> (chainSize[i] == <span class="number">3</span>)</span><br><span class="line">				count3++;</span><br><span class="line">			<span class="keyword">if</span> (chainSize[i] == <span class="number">4</span>)</span><br><span class="line">				count4++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (count2 == <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"n-hexane"</span>;<span class="comment">//链长 = 2 出现4次</span></span><br><span class="line">		<span class="keyword">if</span> (count4 == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"2,2-dimethylbutane"</span>;<span class="comment">//链长 = 4 出现1次</span></span><br><span class="line">		<span class="keyword">if</span> (count3 == <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"2,3-dimethylbutane"</span>;<span class="comment">//链长 = 3 出现2次</span></span><br><span class="line">        <span class="comment">//以上区分出3种，剩下2种另外区分</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">2</span> &amp;&amp; count3 == <span class="number">1</span> &amp;&amp; count4 == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> no = <span class="number">0</span>;<span class="comment">// no用于记录 链长 = 3 所在数组位置</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">				<span class="keyword">if</span> (chainSize[i] == <span class="number">3</span>)</span><br><span class="line">					no = i;<span class="comment">//找到位置i</span></span><br><span class="line">			<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nei = arr[no].getElement();<span class="comment">//获得该链元素</span></span><br><span class="line">			<span class="keyword">int</span> count1 = <span class="number">0</span>;<span class="comment">//记录甲基个数</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != nei.<span class="built_in">size</span>(); i++)</span><br><span class="line">				<span class="keyword">if</span> (chainSize[nei.at(i)] == <span class="number">1</span>)</span><br><span class="line">					count1++;</span><br><span class="line">			<span class="keyword">if</span> (count1 == <span class="number">2</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"2-methylpentane"</span>;<span class="comment">//甲基个数 = 2 得出</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="string">"3-methylpentane"</span>;<span class="comment">//否则，甲基个数 = 1</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		ane tane;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> a, b;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			tane.insert(a - <span class="number">1</span>, b - <span class="number">1</span>);</span><br><span class="line">			tane.insert(b - <span class="number">1</span>, a - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		tane.getSize();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; tane.type() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>无向图</tag>
      </tags>
  </entry>
  <entry>
    <title>炉石传说</title>
    <url>/2020/04/18/%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4/</url>
    <content><![CDATA[<h1 id="炉石传说-CSP201609-3"><a href="#炉石传说-CSP201609-3" class="headerlink" title="炉石传说 - CSP201609-3"></a><strong>炉石传说 - CSP201609-3</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">《炉石传说：魔兽英雄传》（Hearthstone: Heroes of Warcraft，简称炉石传说）是暴雪娱乐开发的一款集换式卡牌游戏（如下图所示）。游戏在一个战斗棋盘上进行，由两名玩家轮流进行操作，本题所使用的炉石传说游戏的简化规则如下：</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/04/18/bUldetRrg5aPp3f.jpg" alt="hearthstone.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　* 玩家会控制一些角色，每个角色有自己的生命值和攻击力。当生命值小于等于 0 时，该角色死亡。角色分为英雄和随从。</span><br><span class="line">　　* 玩家各控制一个英雄，游戏开始时，英雄的生命值为 30，攻击力为 0。当英雄死亡时，游戏结束，英雄未死亡的一方获胜。</span><br><span class="line">　　* 玩家可在游戏过程中召唤随从。棋盘上每方都有 7 个可用于放置随从的空位，从左到右一字排开，被称为战场。当随从死亡时，它将被从战场上移除。</span><br><span class="line">　　* 游戏开始后，两位玩家轮流进行操作，每个玩家的连续一组操作称为一个回合。</span><br><span class="line">　　* 每个回合中，当前玩家可进行零个或者多个以下操作：</span><br><span class="line">　　1) 召唤随从：玩家召唤一个随从进入战场，随从具有指定的生命值和攻击力。</span><br><span class="line">　　2) 随从攻击：玩家控制自己的某个随从攻击对手的英雄或者某个随从。</span><br><span class="line">　　3) 结束回合：玩家声明自己的当前回合结束，游戏将进入对手的回合。该操作一定是一个回合的最后一个操作。</span><br><span class="line">　　* 当随从攻击时，攻击方和被攻击方会同时对彼此造成等同于自己攻击力的伤害。受到伤害的角色的生命值将会减少，数值等同于受到的伤害。例如，随从 X 的生命值为 HX、攻击力为 AX，随从 Y 的生命值为 HY、攻击力为 AY，如果随从 X 攻击随从 Y，则攻击发生后随从 X 的生命值变为 HX - AY，随从 Y 的生命值变为 HY - AX。攻击发生后，角色的生命值可以为负数。</span><br><span class="line">　　本题将给出一个游戏的过程，要求编写程序模拟该游戏过程并输出最后的局面。</span><br></pre></td></tr></table></figure>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　输入第一行是一个整数 n (0 ≤ n ≤ 1000)，表示操作的个数。接下来 n 行，每行描述一个操作，格式如下：</span><br><span class="line">　　&lt;action&gt; &lt;arg1&gt; &lt;arg2&gt; ...</span><br><span class="line">　　其中&lt;action&gt;表示操作类型，是一个字符串，共有 3 种：summon表示召唤随从，attack表示随从攻击，end表示结束回合。这 3 种操作的具体格式如下：</span><br><span class="line">　　* summon &lt;position&gt; &lt;attack&gt; &lt;health&gt;：当前玩家在位置&lt;position&gt;召唤一个生命值为&lt;health&gt;、攻击力为&lt;attack&gt;的随从。其中&lt;position&gt;是一个 1 到 7 的整数，表示召唤的随从出现在战场上的位置，原来该位置及右边的随从都将顺次向右移动一位; 随从的初始生命值为 1 到 100 的整数，攻击力为 0 到 100 的整数。</span><br><span class="line">　　* attack &lt;attacker&gt; &lt;defender&gt;：当前玩家的角色&lt;attacker&gt;攻击对方的角色 &lt;defender&gt;。&lt;attacker&gt;是 1 到 7 的整数，表示发起攻击的本方随从编号，&lt;defender&gt;是 0 到 7 的整数，表示被攻击的对方角色，0 表示攻击对方英雄，1 到 7 表示攻击对方随从的编号。</span><br><span class="line">　　* end：当前玩家结束本回合。</span><br><span class="line">　　注意：随从的编号会随着游戏的进程发生变化，当召唤一个随从时，玩家指定召唤该随从放入战场的位置，此时，原来该位置及右边的所有随从编号都会增加 1。而当一个随从死亡时，它右边的所有随从编号都会减少 1。任意时刻，战场上的随从总是从1开始连续编号。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　输出共 5 行。</span><br><span class="line">　　第 1 行包含一个整数，表示这 n 次操作后（以下称为 T 时刻）游戏的胜负结果，1 表示先手玩家获胜，-1 表示后手玩家获胜，0 表示游戏尚未结束，还没有人获胜。</span><br><span class="line">　　第 2 行包含一个整数，表示 T 时刻先手玩家的英雄的生命值。</span><br><span class="line">　　第 3 行包含若干个整数，第一个整数 p 表示 T 时刻先手玩家在战场上存活的随从个数，之后 p 个整数，分别表示这些随从在 T 时刻的生命值（按照从左往右的顺序）。</span><br><span class="line">　　第 4 行和第 5 行与第 2 行和第 3 行类似，只是将玩家从先手玩家换为后手玩家。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">8</span><br><span class="line">summon 1 3 6</span><br><span class="line">summon 2 4 2</span><br><span class="line">end</span><br><span class="line">summon 1 4 5</span><br><span class="line">summon 1 2 1</span><br><span class="line">attack 1 2</span><br><span class="line">end</span><br><span class="line">attack 1 1</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">0</span><br><span class="line">30</span><br><span class="line">1 2</span><br><span class="line">30</span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">Explain: </span><br><span class="line">　　按照样例输入从第 2 行开始逐行的解释如下：</span><br><span class="line">　　1. 先手玩家在位置 1 召唤一个生命值为 6、攻击力为 3 的随从 A，是本方战场上唯一的随从。</span><br><span class="line">　　2. 先手玩家在位置 2 召唤一个生命值为 2、攻击力为 4 的随从 B，出现在随从 A 的右边。</span><br><span class="line">　　3. 先手玩家回合结束。</span><br><span class="line">　　4. 后手玩家在位置 1 召唤一个生命值为 5、攻击力为 4 的随从 C，是本方战场上唯一的随从。</span><br><span class="line">　　5. 后手玩家在位置 1 召唤一个生命值为 1、攻击力为 2 的随从 D，出现在随从 C 的左边。</span><br><span class="line">　　6. 随从 D 攻击随从 B，双方均死亡。</span><br><span class="line">　　7. 后手玩家回合结束。</span><br><span class="line">　　8. 随从 A 攻击随从 C，双方的生命值都降低至 2。</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	262144 kb</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>又是一道长题，长题必坑我。</p>
<h3 id="Step-1-处理Arguments"><a href="#Step-1-处理Arguments" class="headerlink" title="Step 1  处理Arguments"></a>Step 1  处理Arguments</h3><p>3种指令：<code>summon</code>, <code>attack</code>, <code>end</code>。根据首字母都不同，直接<code>switch(cmder[0])</code>就行，3个<code>case</code>，主函数差不多写完了。(这边的<code>end</code>容易乍一看以为是结束战斗然后输出的意思，然而<code>end</code>并没有调用输出，所以要看中间输出测试自己写的对不对的话，自己再写个<code>case</code>去调用输出就行)</p>
<h3 id="Step-2-结构构造"><a href="#Step-2-结构构造" class="headerlink" title="Step 2  结构构造"></a>Step 2  结构构造</h3><p>根据题意，关键字<code>HP</code>跟<code>AT</code>，英雄的<code>HP</code>为30，<code>AT</code>为0；随从HP跟AT随机，不用初始化。用结构体储存，同时用二位数组储存英雄+随从，第一维表示开始时的先手玩家，第二维表示开始时的后手玩家。每一维的数组第0位存放英雄，第1至7位存放随从。</p>
<p>用一个<code>cur</code>变量(取值0或1)表示这一轮轮到谁了，换人时异或1就行。</p>
<h3 id="Step-3-类的实现"><a href="#Step-3-类的实现" class="headerlink" title="Step 3  类的实现"></a>Step 3  类的实现</h3><p>我本来是用数组写的，可是后面一直<code>WA</code>，我就搞不明白哪里出了问题，后来用了<code>vector</code>重新写了一遍(后来证明并不是数组出现了问题)。这边只说数组实现(因为<code>vector</code>没啥好说的，<code>insert()</code>和<code>erase()</code>直接用就行了)。</p>
<p><code>summon</code>：位置只可能是1至7，若召唤的位置有随从，则其与后面的全部后移，我用了不断的<code>swap</code>(见代码)，同时标记<code>swap</code>过后最后一个位置为<code>true</code>表示这边有随从。</p>
<p><code>attack</code>：先攻击，计算血量，双方都会扣血(可以扣0滴血，比如攻击了英雄)，就是说攻击必定反噬。然后判断死亡：若英雄死了，则结束战斗；若随从死了，则这个位置标记false，同时判断后面有没有随从，若有，则不断的<code>swap</code>(见代码)，直至<code>swap</code>的最后没人。</p>
<p><code>end</code>：换人，就是<code>cur^1</code>，我本来没用的异或，所以写的<code>if()</code>条件句。</p>
<p><code>Output</code>：根据题意输出。</p>
<p>随从数目我用<code>sz[2]</code>数组记录(先手玩家，后手玩家)，不记录英雄，每次<code>summon</code>则<code>+1</code>，<code>attack</code>若有随从死了则<code>-1</code>。</p>
<h3 id="有些坑"><a href="#有些坑" class="headerlink" title="有些坑"></a>有些坑</h3><p>我定义的数组第一维是储存先手/后手玩家，第二位是英雄/随从，结果由于<code>i</code>和<code>1</code>太像了，我在输出的时候把后手玩家的2个维度搞反了，也是不好发现……</p>
<p>题意问题挺大的。</p>
<p>“当英雄死亡时，游戏结束”。我就想着写一个判断，若有一方的英雄死了，则直接<code>break</code>，不进行接下来的输入……结果题目设置的意思就是，若有英雄死亡，则最后一次输入一定是英雄死亡的那一回合，设置的刚刚好……</p>
<p>“攻击发生后，角色的生命值可以为负数”。我手贱的就把英雄的生命值置零了。因为这个，我卡在80分卡了好久，一直没想通哪里<code>WA</code>了……(哪有游戏的最终显示结果是生命为负啊，血条最后都归零了……)<br>多读题多读题多读题。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><h3 id="vector实现"><a href="#vector实现" class="headerlink" title="vector实现"></a><code>vector</code>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">role</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> HP;</span><br><span class="line">	<span class="keyword">int</span> AT;</span><br><span class="line">	role() &#123; HP = <span class="number">0</span>; AT = <span class="number">0</span>; &#125;</span><br><span class="line">	role(<span class="keyword">int</span> hp, <span class="keyword">int</span> att) :HP(hp), AT(att) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hearthstone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;role&gt; hs[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> cur;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	hearthstone() &#123;</span><br><span class="line">		cur = <span class="number">0</span>;</span><br><span class="line">		<span class="function">role <span class="title">hero</span><span class="params">(<span class="number">30</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		hs[<span class="number">0</span>].push_back(hero);</span><br><span class="line">		hs[<span class="number">1</span>].push_back(hero);</span><br><span class="line">	&#125;</span><br><span class="line">	~hearthstone() &#123;  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">summon</span><span class="params">(<span class="keyword">int</span> pos, role r)</span> </span>&#123;</span><br><span class="line">		hs[cur].insert(hs[cur].<span class="built_in">begin</span>() + pos, r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		hs[cur][a].HP -= hs[cur ^ <span class="number">1</span>][d].AT;</span><br><span class="line">		hs[cur ^ <span class="number">1</span>][d].HP -= hs[cur][a].AT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hs[cur][a].HP &lt;= <span class="number">0</span>)</span><br><span class="line">			hs[cur].erase(hs[cur].<span class="built_in">begin</span>() + a);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//if (hs[cur ^ 1][d].HP &lt;= 0 &amp;&amp; d == 0)</span></span><br><span class="line">			<span class="comment">//hs[cur ^ 1][d].HP = 0;//手贱的置零</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hs[cur ^ <span class="number">1</span>][d].HP &lt;= <span class="number">0</span> &amp;&amp; d != <span class="number">0</span>)</span><br><span class="line">			hs[cur ^ <span class="number">1</span>].erase(hs[cur ^ <span class="number">1</span>].<span class="built_in">begin</span>() + d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">curEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cur ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (hs[<span class="number">0</span>][<span class="number">0</span>].HP &lt;= <span class="number">0</span>)</span><br><span class="line">			res = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (hs[<span class="number">1</span>][<span class="number">0</span>].HP &lt;= <span class="number">0</span>)</span><br><span class="line">			res = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != hs[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; hs[<span class="number">0</span>][<span class="number">0</span>].HP &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; hs[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; hs[<span class="number">0</span>][i].HP;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != hs[<span class="number">1</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; hs[<span class="number">1</span>][<span class="number">0</span>].HP &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; hs[<span class="number">1</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; hs[<span class="number">1</span>][i].HP;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	hearthstone HS;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="built_in">string</span> cmder;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; cmder;</span><br><span class="line">		<span class="keyword">switch</span> (cmder[<span class="number">0</span>]) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'s'</span>: &#123;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">position</span>, attack, health;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; <span class="built_in">position</span> &gt;&gt; attack &gt;&gt; health;</span><br><span class="line">			<span class="function">role <span class="title">sv</span><span class="params">(health, attack)</span></span>;</span><br><span class="line">			HS.summon(<span class="built_in">position</span>, sv);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'a'</span>: &#123;</span><br><span class="line">			<span class="keyword">int</span> attacker, defender;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; attacker &gt;&gt; defender;</span><br><span class="line">			HS.attack(attacker, defender);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'e'</span>: &#123;</span><br><span class="line">			HS.curEnd();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	HS.output();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">role</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> HP;</span><br><span class="line">	<span class="keyword">int</span> AT;</span><br><span class="line">	role() &#123; HP = <span class="number">0</span>; AT = <span class="number">0</span>; &#125;</span><br><span class="line">	role(<span class="keyword">int</span> hp, <span class="keyword">int</span> att) :HP(hp), AT(att) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hearthstone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> curPlayer;</span><br><span class="line">	<span class="keyword">int</span> wPlayer;</span><br><span class="line">	role servant[<span class="number">2</span>][<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">bool</span> exist[<span class="number">2</span>][<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> sz[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	hearthstone() &#123;</span><br><span class="line">		<span class="function">role <span class="title">h</span><span class="params">(<span class="number">30</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		servant[<span class="number">0</span>][<span class="number">0</span>] = h;</span><br><span class="line">		servant[<span class="number">1</span>][<span class="number">0</span>] = h;</span><br><span class="line">		sz[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		sz[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		curPlayer = <span class="number">0</span>;</span><br><span class="line">		wPlayer = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">				exist[i][j] = <span class="literal">false</span>;</span><br><span class="line">		exist[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">		exist[<span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~hearthstone() &#123;  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">summon</span><span class="params">(<span class="keyword">int</span> pos, role sv)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> ipos = pos;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exist[curPlayer][i]) &#123;</span><br><span class="line">				swap(sv, servant[curPlayer][i]);</span><br><span class="line">				ipos++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		servant[curPlayer][ipos] = sv;</span><br><span class="line">		exist[curPlayer][ipos] = <span class="literal">true</span>;</span><br><span class="line">		sz[curPlayer]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shift</span><span class="params">(<span class="keyword">int</span> playerWho, <span class="keyword">int</span> curPos)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = curPos; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">			<span class="keyword">if</span> (exist[playerWho][i + <span class="number">1</span>]) &#123;</span><br><span class="line">				swap(exist[playerWho][i], exist[playerWho][i + <span class="number">1</span>]);</span><br><span class="line">				swap(servant[playerWho][i], servant[playerWho][i + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Attack</span></span><br><span class="line">		servant[wPlayer][d].HP -= servant[curPlayer][a].AT;</span><br><span class="line">		servant[curPlayer][a].HP -= servant[wPlayer][d].AT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// calculate hero HP, if dead, break</span></span><br><span class="line">			<span class="keyword">if</span> (servant[wPlayer][<span class="number">0</span>].HP &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">//servant[wPlayer][0].HP = 0;//这个必须删了</span></span><br><span class="line">				exist[wPlayer][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// calculate HP, if dead, shift</span></span><br><span class="line">			<span class="keyword">if</span> (servant[wPlayer][d].HP &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				exist[wPlayer][d] = <span class="literal">false</span>;</span><br><span class="line">				sz[wPlayer]--;</span><br><span class="line">				<span class="keyword">if</span> (exist[wPlayer][d + <span class="number">1</span>])</span><br><span class="line">					shift(wPlayer, d);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (servant[curPlayer][a].HP &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			exist[curPlayer][a] = <span class="literal">false</span>;</span><br><span class="line">			sz[curPlayer]--;</span><br><span class="line">			<span class="keyword">if</span> (exist[curPlayer][a + <span class="number">1</span>])</span><br><span class="line">				shift(curPlayer, a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">curEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		swap(curPlayer, wPlayer);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">theEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (exist[<span class="number">0</span>][<span class="number">0</span>] == <span class="literal">false</span> || exist[<span class="number">1</span>][<span class="number">0</span>] == <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!exist[<span class="number">0</span>][<span class="number">0</span>] &amp;&amp; exist[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (!exist[<span class="number">1</span>][<span class="number">0</span>] &amp;&amp; exist[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (exist[<span class="number">0</span>][<span class="number">0</span>] &amp;&amp; exist[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (!exist[<span class="number">0</span>][<span class="number">0</span>] &amp;&amp; !exist[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; servant[<span class="number">0</span>][<span class="number">0</span>].HP &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; sz[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">			<span class="keyword">if</span> (exist[<span class="number">0</span>][i])</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; servant[<span class="number">0</span>][i].HP;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; servant[<span class="number">1</span>][<span class="number">0</span>].HP &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; sz[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">			<span class="keyword">if</span> (exist[<span class="number">1</span>][i])</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; servant[<span class="number">1</span>][i].HP;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*void testOutput() &#123;</span></span><br><span class="line"><span class="comment">		if (exist[0][0] == false)</span></span><br><span class="line"><span class="comment">			cout &lt;&lt; "-1" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		if (exist[1][0] == false)</span></span><br><span class="line"><span class="comment">			cout &lt;&lt; "1" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		if (exist[0][0] &amp;&amp; exist[1][0])</span></span><br><span class="line"><span class="comment">			cout &lt;&lt; "0" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "hero1: " &lt;&lt; servant[0][0].HP &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; sz[0] &lt;&lt; ":";</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		for (int i = 1; i &lt; 8; i++)</span></span><br><span class="line"><span class="comment">			if (exist[0][i])</span></span><br><span class="line"><span class="comment">				cout &lt;&lt; " (" &lt;&lt; servant[0][i].HP &lt;&lt;", "&lt;&lt; servant[0][i].AT &lt;&lt; ")";</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "hero2: " &lt;&lt; servant[1][0].HP &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; sz[1] &lt;&lt; ":";</span></span><br><span class="line"><span class="comment">		for (int i = 1; i &lt; 8; i++)</span></span><br><span class="line"><span class="comment">			if (exist[1][i])</span></span><br><span class="line"><span class="comment">				cout &lt;&lt; " (" &lt;&lt; servant[1][i].HP &lt;&lt; ", " &lt;&lt; servant[1][i].AT &lt;&lt; ")";</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; endl &lt;&lt; "----------" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; action;</span><br><span class="line">	action[<span class="string">"summon"</span>] = <span class="number">0</span>;</span><br><span class="line">	action[<span class="string">"attack"</span>] = <span class="number">1</span>;</span><br><span class="line">	action[<span class="string">"end"</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//action["res"] = 3;</span></span><br><span class="line">	hearthstone hs;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="comment">//if (hs.theEnd())</span></span><br><span class="line">			<span class="comment">//break;</span></span><br><span class="line">		<span class="built_in">string</span> cmder;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; cmder;</span><br><span class="line">		<span class="keyword">switch</span> (action[cmder]) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">position</span>, attack, health;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; <span class="built_in">position</span> &gt;&gt; attack &gt;&gt; health;</span><br><span class="line">			<span class="function">role <span class="title">sv</span><span class="params">(health, attack)</span></span>;</span><br><span class="line">			hs.summon(<span class="built_in">position</span>, sv);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">			<span class="keyword">int</span> attacker, defender;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; attacker &gt;&gt; defender;</span><br><span class="line">			hs.attack(attacker, defender);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">			hs.curEnd();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*case 3: &#123;</span></span><br><span class="line"><span class="comment">			hs.testOutput();</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">		<span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	hs.output();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2020/03/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><strong>滑动窗口</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有一个长度为 n 的数列和一个大小为 k 的窗口, 窗口可以在数列上来回移动。问在窗口从左往右滑的时候，每次窗口内数的最大值和最小值分别是多少？</span><br><span class="line">例如：数列是 [1 3 -1 -3 5 3 6 7], 其中 k 等于 3。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Window position</strong></th>
<th style="text-align:right"><strong>Minimum value</strong></th>
<th style="text-align:right"><strong>Maximum value</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[1 3 -1] -3 5 3 6 7</code></td>
<td style="text-align:right">-1</td>
<td style="text-align:right">3</td>
</tr>
<tr>
<td><code>1 [3 -1 -3] 5 3 6 7</code></td>
<td style="text-align:right">-3</td>
<td style="text-align:right">3</td>
</tr>
<tr>
<td><code>1 3 [-1 -3 5] 3 6 7</code></td>
<td style="text-align:right">-3</td>
<td style="text-align:right">5</td>
</tr>
<tr>
<td><code>1 3 -1 [-3 5 3] 6 7</code></td>
<td style="text-align:right">-3</td>
<td style="text-align:right">5</td>
</tr>
<tr>
<td><code>1 3 -1 -3 [5 3 6] 7</code></td>
<td style="text-align:right">3</td>
<td style="text-align:right">6</td>
</tr>
<tr>
<td><code>1 3 -1 -3 5 [3 6 7]</code></td>
<td style="text-align:right">3</td>
<td style="text-align:right">7</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入有两行。第一行两个整数 n 和k分别表示数列的长度和滑动窗口的大小，1 ≤ k ≤ n ≤ 1000000。</span><br><span class="line">第二行有n个整数表示数列。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出有两行。第一行输出滑动窗口在从左到右的每个位置时，滑动窗口中的最小值。第二行是最大值。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input: </span><br><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br><span class="line">output: </span><br><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		12000 ms</span><br><span class="line">Memory limit	65536 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>维护局部单调性，可以用单调队列。</p>
<p>求最小值可以用单调非减队列，从左往右依次入队，若入队的元素比队尾小则不断弹出队尾元素直到符合条件。当<code>队尾索引 - 队首索引 + 1 = 滑动窗口大小</code>时，队首元素弹出，此时队首元素就是最小值。</p>
<p>同理，求最大值用单调非增队列。</p>
<p>两次遍历就能求出最大最小值。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">num</span> &#123;</span><span class="comment">//记录元素值与位置</span></span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	num(<span class="keyword">int</span> x, <span class="keyword">int</span> y) :a(x), b(y) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;num&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty() &amp;&amp; q.back().a &gt;= arr[i])</span><br><span class="line">			q.pop_back();<span class="comment">//队尾大于要入队的元素</span></span><br><span class="line">		<span class="function">num <span class="title">x</span><span class="params">(arr[i], i)</span></span>;</span><br><span class="line">		q.push_back(x);<span class="comment">//符合条件 可以入队</span></span><br><span class="line">		<span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) &#123;<span class="comment">//到达了窗口的宽度  队首弹出</span></span><br><span class="line">			<span class="keyword">while</span> (i - q.front().b &gt; k - <span class="number">1</span>)</span><br><span class="line">				q.pop_front();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>, q.front().a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;num&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty() &amp;&amp; q.back().a &lt;= arr[i])</span><br><span class="line">			q.pop_back();<span class="comment">//队尾小于要入队的元素</span></span><br><span class="line">		<span class="function">num <span class="title">x</span><span class="params">(arr[i], i)</span></span>;</span><br><span class="line">		q.push_back(x);<span class="comment">//符合条件 可以入队</span></span><br><span class="line">		<span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) &#123;<span class="comment">//到达了窗口的宽度  队首弹出</span></span><br><span class="line">			<span class="keyword">while</span> (i - q.front().b &gt; k - <span class="number">1</span>)</span><br><span class="line">				q.pop_front();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>, q.front().a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	scanf_s(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)</span><br><span class="line">		scanf_s(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">	getMin(arr, n, k);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	getMax(arr, n, k);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>最长网线</title>
    <url>/2020/03/26/%E6%9C%80%E9%95%BF%E7%BD%91%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="最长网线"><a href="#最长网线" class="headerlink" title="最长网线"></a><strong>最长网线</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实验室里原先有一台电脑(编号为 1 )，最近又购置了 N - 1 台电脑，编号为 2 到 N 。每台电脑都用网线连接到一台先前安装的电脑上。求第 i 台电脑到其他电脑的最大网线长度。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入文件包含多组测试数据。对于每组测试数据，第一行一个整数 N (N ≤ 10000)，接下来有 N - 1 行，每一行两个数，对于第 j 行的两个数，它们表示与 i 号电脑连接的电脑编号以及它们之间网线的长度。网线的总长度不会超过 10^9，每个数之间用一个空格隔开。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于每组测试数据输出 N 行，第 i 行表示 i 号电脑的答案 (1 ≤ i ≤ N).</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">1 1</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	32768 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>每台电脑最多有2条网线相连，因此可以看成一棵树，采用邻接矩阵来储存节点。</p>
<p>利用DFS逐个求出每个节点的最长路径会超时，但是本题连接的网线可以看成一棵没有分支的树，是一条链，树的直径就是链长，因此可以求出链的两端点到每个节点的距离，更新最大距离即可。</p>
<p>树的直径：从某个点开始遍历，它能到达的终点就是直径的一个端点；再从这个得到的端点开始遍历，它能到达的终点就是直径的另一个端点。</p>
<p>本题进行3次DFS就能得出结果。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">	edge() &#123; v = <span class="number">0</span>; w = <span class="number">0</span>; &#125;</span><br><span class="line">	edge(<span class="keyword">int</span> _v, <span class="keyword">long</span> <span class="keyword">long</span> _w) :v(_v), w(_w) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; edges[maxN];</span><br><span class="line"><span class="keyword">bool</span> visit[maxN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> path[maxN];</span><br><span class="line"><span class="keyword">int</span> source;<span class="comment">//直径的端点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">long</span> <span class="keyword">long</span> length)</span> </span>&#123;</span><br><span class="line">	visit[s] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges[s].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = edges[s].at(i).v;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> tempW = edges[s].at(i).w;</span><br><span class="line">		<span class="keyword">if</span> (!visit[temp]) &#123;</span><br><span class="line">			path[temp] = <span class="built_in">max</span>(path[temp], length + tempW);</span><br><span class="line">			<span class="keyword">if</span> (path[source] &lt; path[temp])</span><br><span class="line">				source = temp;</span><br><span class="line">			dfs(temp, length + tempW);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thePath</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	source = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">	<span class="built_in">memset</span>(path, <span class="number">0</span>, <span class="keyword">sizeof</span>(path));</span><br><span class="line"></span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">0</span>);<span class="comment">//第一次 从第一个点开始 求得直径的一个端点</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">	dfs(source, <span class="number">0</span>);<span class="comment">//第二次 从求得的端点开始 求得另一端点 同时更新最长路径</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">	dfs(source, <span class="number">0</span>);<span class="comment">//第三次 从上一次求得的端点开始 更新最长路径</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, path[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (scanf_s(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> a;</span><br><span class="line">			<span class="keyword">long</span> <span class="keyword">long</span> b;</span><br><span class="line">			scanf_s(<span class="string">"%d %lld"</span>, &amp;a, &amp;b);</span><br><span class="line">			<span class="function">edge <span class="title">e1</span><span class="params">(a, b)</span></span>;</span><br><span class="line">			<span class="function">edge <span class="title">e2</span><span class="params">(i, b)</span></span>;</span><br><span class="line">			edges[i].push_back(e1);</span><br><span class="line">			edges[a].push_back(e2);</span><br><span class="line">		&#125;</span><br><span class="line">		thePath(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">			edges[i].<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>班长竞选</title>
    <url>/2020/04/17/%E7%8F%AD%E9%95%BF%E7%AB%9E%E9%80%89/</url>
    <content><![CDATA[<h1 id="班长竞选"><a href="#班长竞选" class="headerlink" title="班长竞选"></a><strong>班长竞选</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大学班级选班长，N 个同学均可以发表意见，若意见为 A B，则表示 A 认为 B 合适。意见具有传递性，即 A 认为 B 合适，B 认为 C 合适，则 A 也认为 C 合适。共有 M 条意见，求最高票数，并给出一份候选人名单，即所有得票最多的同学。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本题有多组数据。第一行 T 表示数据组数。每组数据开始有两个整数 N 和 M (2 ≤ n ≤ 5000, 0 &lt; m ≤ 30000)，接下来有 M 行包含两个整数 A 和 B (A ≠ B) 表示 A 认为 B 合适。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于每组数据，第一行输出&quot;Case x: &quot;，x 表示数据的编号，从1开始，紧跟着是最高的票数。 接下来一行输出得票最多的同学的编号，用空格隔开，不忽略行末空格！</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">2</span><br><span class="line">4 3</span><br><span class="line">3 2</span><br><span class="line">2 0</span><br><span class="line">2 1</span><br><span class="line">3 3</span><br><span class="line">1 0</span><br><span class="line">2 1</span><br><span class="line">0 2</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">Case 1: 2</span><br><span class="line">0 1</span><br><span class="line">Case 2: 2</span><br><span class="line">0 1 2</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		2000 ms</span><br><span class="line">Memory limit	32768 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>这题题目短，题意清晰，输入输出简单明了，但实现起来挺复杂的。</p>
<h3 id="强连通分量-Strongly-Connected-Component-SCC"><a href="#强连通分量-Strongly-Connected-Component-SCC" class="headerlink" title="强连通分量 (Strongly Connected Component, SCC)"></a>强连通分量 (Strongly Connected Component, SCC)</h3><p>有向图中，尽可能多的若干顶点组成的子图中，这些顶点都是相互可到达的，则这些顶点成为一个强连通分量。</p>
<p><img src="https://i.loli.net/2020/04/20/bG9QVDgWOsL5aSd.png" alt="SCC.png"></p>
<p>如上图所示，有3个强连通分量，分别是<code>{A, B, C}</code>, <code>{D, E, H}</code>, <code>{F, G}</code>。</p>
<h3 id="DFS序"><a href="#DFS序" class="headerlink" title="DFS序"></a>DFS序</h3><p>前序：第一次到达点 <em>x</em> 的次序，用<code>d[x]</code>表示<br>后序：<em>x</em> 点遍历完成的次序，即回溯时间，用 <code>f[x]</code> 表示<br>逆后序：后序序列的逆序</p>
<p>以上图为例，用DFS遍历：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Edge</th>
<th style="text-align:center">Current Node</th>
<th style="text-align:center">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center"><code>A</code></td>
<td style="text-align:center"><code>d[A] = 1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>A → B</code></td>
<td style="text-align:center"><code>B</code></td>
<td style="text-align:center"><code>d[B] = 2</code></td>
</tr>
<tr>
<td style="text-align:center"><code>B → C</code></td>
<td style="text-align:center"><code>C</code></td>
<td style="text-align:center"><code>d[C] = 3</code></td>
</tr>
<tr>
<td style="text-align:center"><code>C → A</code></td>
<td style="text-align:center"><code>C</code></td>
<td style="text-align:center">Reached</td>
</tr>
<tr>
<td style="text-align:center"><code>C → H</code></td>
<td style="text-align:center"><code>H</code></td>
<td style="text-align:center"><code>d[H] = 4</code></td>
</tr>
<tr>
<td style="text-align:center"><code>H → E</code></td>
<td style="text-align:center"><code>E</code></td>
<td style="text-align:center"><code>d[E] = 5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>E → D</code></td>
<td style="text-align:center"><code>D</code></td>
<td style="text-align:center"><code>d[D] = 6</code></td>
</tr>
<tr>
<td style="text-align:center"><code>D → E</code></td>
<td style="text-align:center"><code>D</code></td>
<td style="text-align:center">Reached</td>
</tr>
<tr>
<td style="text-align:center"><code>D → F</code></td>
<td style="text-align:center"><code>F</code></td>
<td style="text-align:center"><code>d[F] = 7</code></td>
</tr>
<tr>
<td style="text-align:center"><code>F → G</code></td>
<td style="text-align:center"><code>G</code></td>
<td style="text-align:center"><code>d[G] = 8</code></td>
</tr>
<tr>
<td style="text-align:center"><code>G → F</code></td>
<td style="text-align:center"><code>G</code></td>
<td style="text-align:center">Reached</td>
</tr>
<tr>
<td style="text-align:center"><code>G</code>遍历结束</td>
<td style="text-align:center"><code>G</code></td>
<td style="text-align:center"><code>f[G] = 1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>F</code>遍历结束</td>
<td style="text-align:center"><code>F</code></td>
<td style="text-align:center"><code>f[F] = 2</code></td>
</tr>
<tr>
<td style="text-align:center"><code>D</code>遍历结束</td>
<td style="text-align:center"><code>D</code></td>
<td style="text-align:center"><code>f[D] = 3</code></td>
</tr>
<tr>
<td style="text-align:center"><code>E → G</code></td>
<td style="text-align:center"><code>E</code></td>
<td style="text-align:center">Reached</td>
</tr>
<tr>
<td style="text-align:center"><code>E → H</code></td>
<td style="text-align:center"><code>E</code></td>
<td style="text-align:center">Reached</td>
</tr>
<tr>
<td style="text-align:center"><code>E</code>遍历结束</td>
<td style="text-align:center"><code>E</code></td>
<td style="text-align:center"><code>f[E] = 4</code></td>
</tr>
<tr>
<td style="text-align:center"><code>H</code>遍历结束</td>
<td style="text-align:center"><code>H</code></td>
<td style="text-align:center"><code>f[H] = 5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>C</code>遍历结束</td>
<td style="text-align:center"><code>C</code></td>
<td style="text-align:center"><code>f[C] = 6</code></td>
</tr>
<tr>
<td style="text-align:center"><code>B → H</code></td>
<td style="text-align:center"><code>B</code></td>
<td style="text-align:center">Reached</td>
</tr>
<tr>
<td style="text-align:center"><code>B</code>遍历结束</td>
<td style="text-align:center"><code>B</code></td>
<td style="text-align:center"><code>f[B] = 7</code></td>
</tr>
<tr>
<td style="text-align:center"><code>A</code>遍历结束</td>
<td style="text-align:center"><code>A</code></td>
<td style="text-align:center"><code>f[A] = 8</code></td>
</tr>
</tbody>
</table>
</div>
<p>得到前序序列：<code>{A, B, C, H, E, D, F, G}</code><br>后序序列：<code>{G, F, D, E, H, C, B, A}</code><br>逆后序序列：<code>{A, B, C, H, E, D, F, G}</code></p>
<h3 id="Kosaraju-Algorithm"><a href="#Kosaraju-Algorithm" class="headerlink" title="Kosaraju Algorithm"></a>Kosaraju Algorithm</h3><p>Kosaraju算法用于找出图中所有的SCC。</p>
<p>以上图为例，DFS先求出原图的逆后序序列<code>{A, B, C, H, E, D, F, G}</code>，然后根据逆后序序列遍历反图(如下图)：</p>
<p><img src="https://i.loli.net/2020/04/20/6ONKC39YtgrvMhq.png" alt="SCC_temp_04.20.png"></p>
<p>Step 1: 从A开始遍历，得到第一个SCC<code>{A, C, B}</code></p>
<p><img src="https://i.loli.net/2020/04/20/uVgFhpRynEq8xjS.png" alt="SCC_temp_001.png"></p>
<p>Step 2: 从H开始遍历，得到第二个SCC<code>{H, E, D}</code></p>
<p><img src="https://i.loli.net/2020/04/20/mIy6ucDhkPvV7Td.png" alt="SCC_temp_002.png"></p>
<p>Step 3: 从F开始遍历，得到第三个SCC<code>{F, G}</code></p>
<p><img src="https://i.loli.net/2020/04/20/WFCYswl1pjGb8fe.png" alt="SCC_temp_003.png"></p>
<h3 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h3><p>投票选举，A认为B合适(<code>A→B</code>的有向边)，B认为C合适(<code>B→C</code>的有向边)，则A也认为C合适(传递性)。因此投票可能形成多个环路。</p>
<p>先求出共有多少个SCC，每一个SCC内，每个节点的票数 = 该SCC的节点数 - 1(除去自己)；<br>对于每个SCC，都可进行缩点，记作<code>SCC[i]</code>，其值为内节点的票数。<br>若SCC<sub><em>i</em></sub>对SCC<sub><em>j</em></sub>可达，且由 <em>i</em> 指向 <em>j</em>，则<code>SCC[j] += SCC[i]</code>(传递性)。</p>
<p>票数最多的人，一定出现在出度为0的SCC中。</p>
<p>总共需要2次DFS求出强连通分量，1次DFS找出票数最高的即出度为0的强连通分量，然后再从这个SCC中找出票数最高的点，即答案。</p>
<p>本题综合性很强，很容易<code>TLE</code>或<code>MLE</code>。本来用的<code>cin</code>，后来用<code>scanf</code>才过……</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ele;</span><br><span class="line">	node* next;</span><br><span class="line">	node() &#123; ele = <span class="number">-1</span>; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">	node(<span class="keyword">int</span> e) :ele(e) &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	node* header;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	linkedList() &#123; header = <span class="literal">NULL</span>; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">	~linkedList() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size</span>; &#125;</span><br><span class="line">	<span class="function">node* <span class="title">getHeader</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> ele)</span> </span>&#123;</span><br><span class="line">		node* p = <span class="keyword">new</span> node(ele);</span><br><span class="line">		<span class="keyword">if</span> (header == <span class="literal">NULL</span>)</span><br><span class="line">			header = p;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			node* temp = header;</span><br><span class="line">			node* temp2 = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				temp2 = temp;</span><br><span class="line">				temp = temp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			temp2-&gt;next = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">size</span>++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		node* temp = header;</span><br><span class="line">		node* ttemp = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			ttemp = temp;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">			ttemp = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		header = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">delete</span> temp;</span><br><span class="line">		<span class="keyword">delete</span> ttemp;</span><br><span class="line">		<span class="keyword">delete</span> header;</span><br><span class="line">		<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	linkedList arr1[maxN];</span><br><span class="line">	linkedList arr2[maxN];</span><br><span class="line">	linkedList arr[maxN];</span><br><span class="line">	<span class="keyword">int</span> inDeg[maxN];</span><br><span class="line">	<span class="keyword">bool</span> reach1[maxN];</span><br><span class="line">	<span class="keyword">int</span> inv[maxN];</span><br><span class="line">	<span class="keyword">int</span> invCnt;</span><br><span class="line">	<span class="keyword">int</span> color[maxN];</span><br><span class="line">	<span class="keyword">int</span> scc[maxN];</span><br><span class="line">	<span class="keyword">int</span> sccCnt;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">	<span class="keyword">int</span> ans[maxN];</span><br><span class="line">	<span class="keyword">bool</span> reach2[maxN];</span><br><span class="line">	<span class="keyword">int</span> s;</span><br><span class="line">	<span class="keyword">int</span> res[maxN];</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	graph() &#123; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">	graph(<span class="keyword">int</span> n) &#123; <span class="built_in">size</span> = n; initialize(); &#125;</span><br><span class="line">	~graph() &#123;  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		sccCnt = <span class="number">0</span>;</span><br><span class="line">		s = <span class="number">0</span>;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		invCnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">			inDeg[i] = <span class="number">0</span>;</span><br><span class="line">			reach1[i] = <span class="literal">false</span>;</span><br><span class="line">			color[i] = <span class="number">0</span>;</span><br><span class="line">			scc[i] = <span class="number">0</span>;</span><br><span class="line">			ans[i] = <span class="number">0</span>;</span><br><span class="line">			res[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;</span><br><span class="line">		arr1[p1].add(p2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">invertedAdd</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;</span><br><span class="line">		arr2[p1].add(p2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;</span><br><span class="line">		arr[p1].add(p2);</span><br><span class="line">		inDeg[p2]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">		reach1[s] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (node* p = arr1[s].getHeader(); p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">			<span class="keyword">int</span> ele = p-&gt;ele;</span><br><span class="line">			<span class="keyword">if</span> (!reach1[ele])</span><br><span class="line">				dfs1(ele);</span><br><span class="line">		&#125;</span><br><span class="line">		inv[++invCnt] = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> sccCnt)</span> </span>&#123;</span><br><span class="line">		color[s] = sccCnt;</span><br><span class="line">		scc[sccCnt]++;</span><br><span class="line">		<span class="keyword">for</span> (node* p = arr2[s].getHeader(); p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">			<span class="keyword">int</span> ele = p-&gt;ele;</span><br><span class="line">			<span class="keyword">if</span> (!color[ele])</span><br><span class="line">				dfs2(ele, sccCnt);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>; i++)</span><br><span class="line">			<span class="keyword">if</span> (!reach1[i])</span><br><span class="line">				dfs1(i);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = inv[i];</span><br><span class="line">			<span class="keyword">if</span> (!color[x]) &#123;</span><br><span class="line">				sccCnt++;</span><br><span class="line">				dfs2(x, sccCnt);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		reach2[x] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (node* p = arr[x].getHeader(); p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">			<span class="keyword">int</span> ele = p-&gt;ele;</span><br><span class="line">			<span class="keyword">if</span> (!reach2[ele]) &#123;</span><br><span class="line">				ans[s] += scc[ele];</span><br><span class="line">				dfs3(ele);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		kosaraju();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (node* p = arr2[i].getHeader(); p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">				<span class="keyword">int</span> ele = p-&gt;ele;</span><br><span class="line">				<span class="keyword">if</span> (color[i] == color[ele])</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				ADD(color[i], color[ele]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sccCnt; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (inDeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">memset</span>(reach2, <span class="literal">false</span>, maxN);</span><br><span class="line">				ans[i] += (scc[i] - <span class="number">1</span>);</span><br><span class="line">				s = i;</span><br><span class="line">				dfs3(i);</span><br><span class="line">				count = <span class="built_in">max</span>(count, ans[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sccCnt; i++)</span><br><span class="line">			<span class="keyword">if</span> (ans[i] == count)</span><br><span class="line">				res[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (res[color[i]])</span><br><span class="line">				<span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%d"</span>, i - <span class="number">1</span>);</span><br><span class="line">					pos++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">" %d"</span>, i - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	scanf_s(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">1</span>; ii &lt;= t; ii++) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		scanf_s(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="function">graph <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> p1, p2;</span><br><span class="line">			scanf_s(<span class="string">"%d%d"</span>, &amp;p1, &amp;p2);</span><br><span class="line">			G.add(p1 + <span class="number">1</span>, p2 + <span class="number">1</span>);</span><br><span class="line">			G.invertedAdd(p2 + <span class="number">1</span>, p1 + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> r = G.solve();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ii, r);</span><br><span class="line">		G.solve2();</span><br><span class="line">		G.~graph();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>强连通分量</tag>
        <tag>Kosaraju</tag>
      </tags>
  </entry>
  <entry>
    <title>目录管理器</title>
    <url>/2020/04/17/%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="目录管理器"><a href="#目录管理器" class="headerlink" title="目录管理器"></a><strong>目录管理器</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写一个目录管理器。</span><br><span class="line">初始时，硬盘是空的，命令行的当前目录为根目录 root。</span><br><span class="line">目录管理器可以理解为要维护一棵有根树结构，每个目录的儿子必须保持字典序。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:center">类型</th>
<th>实现</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MKDIR s</code></td>
<td style="text-align:center">操作</td>
<td>在当前目录下创建一个子目录 <em>s</em>，<em>s</em> 是一个字符串</td>
<td>创建成功输出 “<code>OK</code>“；若当前目录下已有该子目录则输出 “<code>ERR</code>“</td>
</tr>
<tr>
<td><code>RM s</code></td>
<td style="text-align:center">操作</td>
<td>在当前目录下删除子目录 <em>s</em>，<em>s</em> 是一个字符串</td>
<td>删除成功输出 “<code>OK</code>“；若当前目录下该子目录不存在则输出 “<code>ERR</code>“</td>
</tr>
<tr>
<td><code>CD s</code></td>
<td style="text-align:center">操作</td>
<td>进入一个子目录 <em>s</em>，<em>s</em> 是一个字符串(执行后，当前目录可能会改变)</td>
<td>进入成功输出 “<code>OK</code>“；若当前目录下该子目录不存在则输出 “<code>ERR</code>“<br>特殊地，若 <em>s</em> 等于 “<code>..</code>“ 则表示返回上级目录，同理，返回成功输出 “<code>OK</code>“，返回失败（当前目录已是根目录没有上级目录）则输出 “<code>ERR</code>“</td>
</tr>
<tr>
<td><code>SZ</code></td>
<td style="text-align:center">询问</td>
<td>输出当前目录的大小</td>
<td>也即输出 <code>1+当前目录的子目录数</code></td>
</tr>
<tr>
<td><code>LS</code></td>
<td style="text-align:center">询问</td>
<td>输出多行表示当前目录的 “直接子目录” 名</td>
<td>若没有子目录，则输出 “<code>EMPTY</code>“；若<code>子目录数</code>∈ [1,10] 则全部输出；若<code>子目录数</code>大于 10，则输出前 5 个，再输出一行 “<code>...</code>“，输出后 5 个。</td>
</tr>
<tr>
<td><code>TREE</code></td>
<td style="text-align:center">询问</td>
<td>输出多行表示以当前目录为根的子树的前序遍历结果</td>
<td>若没有后代目录，则输出 “<code>EMPTY</code>“；若 <code>后代目录数+1 (当前目录)</code> ∈ [1,10] 则全部输出；若<code>后代目录数+1 (当前目录)</code> 大于 10，则输出前 5 个，再输出一行 “<code>...</code>“，输出后 5 个。若目录结构如<code>图1</code>，当前目录为 “<code>root</code>“ 执行结果如<code>图2</code></td>
</tr>
<tr>
<td><code>UNDO</code></td>
<td style="text-align:center">特殊</td>
<td>撤销操作</td>
<td>撤销最近一个 “成功执行” 的操作（即成功的<code>MKDIR</code>或<code>RM</code>或<code>CD</code>）的影响，撤销成功输出 “<code>OK</code>“ , 没有操作用于撤销则输出 “<code>ERR</code>“</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://i.loli.net/2020/04/17/vehRy68qGgoIu9a.png" alt="directory_manager_01.png"></p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入文件包含多组测试数据，第一行输入一个整数表示测试数据的组数 T (T ≤ 20)；</span><br><span class="line">每组测试数据的第一行输入一个整数表示该组测试数据的命令总数 Q (Q ≤ 1e5)；</span><br><span class="line">每组测试数据的 2 ~ Q+1 行为具体的操作(MKDIR、RM 操作总数不超过 5000)；</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每组测试数据的输出结果间需要输出一行空行。注意大小写。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">1</span><br><span class="line">22</span><br><span class="line">MKDIR dira</span><br><span class="line">CD dirb</span><br><span class="line">CD dira</span><br><span class="line">MKDIR a</span><br><span class="line">MKDIR b</span><br><span class="line">MKDIR c</span><br><span class="line">CD ..</span><br><span class="line">MKDIR dirb</span><br><span class="line">CD dirb</span><br><span class="line">MKDIR x</span><br><span class="line">CD ..</span><br><span class="line">MKDIR dirc</span><br><span class="line">CD dirc</span><br><span class="line">MKDIR y</span><br><span class="line">CD ..</span><br><span class="line">SZ</span><br><span class="line">LS</span><br><span class="line">TREE</span><br><span class="line">RM dira</span><br><span class="line">TREE</span><br><span class="line">UNDO</span><br><span class="line">TREE</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">OK</span><br><span class="line">ERR</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">9</span><br><span class="line">dira</span><br><span class="line">dirb</span><br><span class="line">dirc</span><br><span class="line">root</span><br><span class="line">dira</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">dirb</span><br><span class="line">x</span><br><span class="line">dirc</span><br><span class="line">y</span><br><span class="line">OK</span><br><span class="line">root</span><br><span class="line">dirb</span><br><span class="line">x</span><br><span class="line">dirc</span><br><span class="line">y</span><br><span class="line">OK</span><br><span class="line">root</span><br><span class="line">dira</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">dirb</span><br><span class="line">x</span><br><span class="line">dirc</span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		6000 ms</span><br><span class="line">Memory limit	1048576 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>挺复杂的，分步骤操作。</p>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>先考虑输入，输入主要是操作跟操作的路径，所以用<code>map</code>标记输入的是什么操作，共 7 个<code>case</code>。</p>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>接下来就是7个功能的实现了，可以先把大体框图<code>class</code>写出来，具体怎么实现先丢在一边。</p>
<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>然后是考虑怎么实现这棵目录树的问题。仔细读题，它得有返回上一级的功能，所以结构体内得存有指针指向其父节点；还得输出当前目录大小，所以结构体内得有一个<code>size</code>记录当前目录大小。<br>但是问题又来了，一个目录下有多个文件夹，每个文件夹下又有多个文件夹，所以<code>size</code>不应该只记录当前文件夹下文件夹的个数，还得算入所有子文件夹的个数，所以可以用一个函数维持这个<code>size</code>，从变更的孩子节点开始，每次往上一级变更<code>size</code>，直到<code>root</code>。<br>文件目录是英文单词，得用<code>map</code>对其标记(同时也Alphabetically sorted)，将这些指向孩子的指针储存起来。</p>
<h3 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h3><p>最后就是实现这7大功能了。</p>
<p>类里面放个指针指向根目录，再放个指针指向当前所在文件夹的目录。</p>
<p><code>MKDIR s</code>：新建节点直接插入，同时维护<code>size</code>(+1)，返回<code>true</code>/<code>false</code>。</p>
<p><code>RM s</code>：找到当前路径是否存在该文件夹，存在则删除指针，同时维护<code>size</code>(- 1 × 删除的大小)，返回<code>true</code>/<code>false</code>。</p>
<p><code>CD s</code>：找到当前路径是否存在该文件夹，存在则改变当前目录的指针，指向这，返回<code>true</code>/<code>false</code>。</p>
<p><code>SZ</code>：因为有储存了，直接输出就好了。</p>
<p><code>LS</code>：遍历当前目录的直接子目录，直接根据题意输出就好了。</p>
<p><code>TREE</code>：前序遍历，结果用<code>vector</code>储存，根据题意输出。</p>
<p><code>UNDO</code>：中文题意可能有歧义，直接看英文题意：只有成功的<code>MKDIR</code>、<code>RM</code>、<code>CD</code>才可以撤销；可多次撤销；没得再撤销了就<code>ERR</code>了。<br>可以用一个栈(<code>stack&lt;pair&lt;操作, 操作用于的指针&gt;&gt;</code>)储存每次成功的<code>MKDIR</code>、<code>RM</code>和<code>CD</code>，每次撤销取栈顶，撤销<code>MKDIR</code>就<code>RM</code>之，撤销<code>RM</code>就<code>MKDIR</code>之(必须用指针, 不可直接新建目录，否则子文件夹全部丢失)，撤销<code>CD</code>就进入储存的<code>CD</code>地址。</p>
<h3 id="Step-5-细节处理"><a href="#Step-5-细节处理" class="headerlink" title="Step 5  细节处理"></a>Step 5  细节处理</h3><p>跑一下，<code>TLE</code>了……原因是一直<code>TREE</code>操作太耗时，太多次就超时了。</p>
<p>可以采用懒更新的方式，因为它每次<code>TREE</code>的结果可能是相同的，可以用一个<code>bool updated</code>记录当前是否更新了树，即若操作是成功的<code>MKDIR</code>/<code>RM</code>/<code>CD</code>/<code>UNDO</code>，则需要重新遍历，每次遍历完之后，将<code>updated</code>置于<code>false</code>。减少了遍历的次数，耗时也就降下来了。</p>
<h3 id="再再再后来……"><a href="#再再再后来……" class="headerlink" title="再再再后来……"></a>再再再后来……</h3><p>之后就面临的<code>WA</code>的疯狂调试……(好难纠错啊)</p>
<p>先是解决了上面提到的撤回<code>RM</code>操作不能直接<code>MKDIR</code>新目录的问题，然后是若第一个指令是<code>TREE</code>但前序序列是空的(没加入<code>root</code>), 因此输出<code>&#39;EMPTY&#39;</code>时判断条件(前序序列的<code>size</code> = 1)会出错。</p>
<p>还有就是若当前目录与其子目录中某个文件夹同名，<code>RM</code>会有很大的问题，因为我本来是写了个<code>find()</code>函数，从当前目录开始，不断向子目录找同名文件夹，<code>RM</code>直接调用的<code>find()</code>，因为刚开始读题的时候我脑子里是认为把所有子目录都算进去了……</p>
<p>还有个<code>WA</code>找了好久……反复读题后，发现<code>CD</code>是进入当前子目录，我又调用<code>find()</code>函数了……(自己随手写了个<code>find()</code>函数把自己坑了好几次😵，最终<code>AC</code>的结果就是<code>find()</code>完全用不上🤧)</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>认真读题，反复读题！若有英文原题，建议先看英文题面！</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt; children;</span><br><span class="line">	node* parent;</span><br><span class="line">	<span class="keyword">int</span> sz;</span><br><span class="line">	node() &#123; name = <span class="string">""</span>; parent = <span class="literal">NULL</span>; sz = <span class="number">0</span>; &#125;</span><br><span class="line">	node(<span class="built_in">string</span> nm, node* par) :name(nm), parent(par) &#123; sz = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">directory</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	node* root;</span><br><span class="line">	node* cur;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; posOrder;</span><br><span class="line">	<span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, node*&gt;&gt; opeS;</span><br><span class="line">	<span class="keyword">bool</span> updated;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	directory() &#123; root = <span class="keyword">new</span> node(<span class="string">"root"</span>, <span class="literal">NULL</span>); cur = root; updated = <span class="literal">false</span>; &#125;</span><br><span class="line">	~directory() &#123; <span class="comment">/*clear();*/</span> &#125;</span><br><span class="line">	<span class="function">node* <span class="title">find</span><span class="params">(node* curr, <span class="built_in">string</span> idx)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">		q.push(curr);</span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">			node* p = q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;name == idx)</span><br><span class="line">				<span class="keyword">return</span> p;</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = p-&gt;children.<span class="built_in">begin</span>();</span><br><span class="line">				it != p-&gt;children.<span class="built_in">end</span>(); ++it)</span><br><span class="line">				q.push(it-&gt;second);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(node* curr, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">		curr-&gt;sz += delta;</span><br><span class="line">		<span class="keyword">if</span> (curr != root)</span><br><span class="line">			<span class="built_in">maintain</span>(curr-&gt;parent, delta);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> sub)</span> </span>&#123;</span><br><span class="line">		node* par = cur;</span><br><span class="line">		<span class="keyword">if</span> (par-&gt;children.<span class="built_in">find</span>(sub) != par-&gt;children.<span class="built_in">end</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		node* child = <span class="keyword">new</span> node(sub, par);</span><br><span class="line">		par-&gt;children.insert(make_pair(sub, child));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">maintain</span>(cur, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		opeS.push(make_pair(<span class="number">0</span>, child));</span><br><span class="line">		updated = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="built_in">string</span> sub)</span> </span>&#123;</span><br><span class="line">		node* par = cur;</span><br><span class="line">		<span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = par-&gt;children.<span class="built_in">find</span>(sub);</span><br><span class="line">		<span class="keyword">if</span> (it == par-&gt;children.<span class="built_in">end</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		node* child = par-&gt;children[sub];</span><br><span class="line"></span><br><span class="line">		par-&gt;children.erase(it);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">maintain</span>(cur, <span class="number">-1</span> * child-&gt;sz);</span><br><span class="line"></span><br><span class="line">		opeS.push(make_pair(<span class="number">1</span>, child));</span><br><span class="line">		updated = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">enter</span><span class="params">(<span class="built_in">string</span> sub)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (sub == <span class="string">".."</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cur == root)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			opeS.push(make_pair(<span class="number">2</span>, cur));</span><br><span class="line">			cur = cur-&gt;parent;</span><br><span class="line">			updated = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = cur-&gt;children.<span class="built_in">find</span>(sub);</span><br><span class="line">			<span class="keyword">if</span> (it == cur-&gt;children.<span class="built_in">end</span>())</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">			opeS.push(make_pair(<span class="number">2</span>, cur));</span><br><span class="line">			cur = it-&gt;second;</span><br><span class="line">			updated = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">curSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cur-&gt;sz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">currOutput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> theSize = cur-&gt;children.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">if</span> (theSize == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"EMPTY"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (theSize &gt;= <span class="number">1</span> &amp;&amp; theSize &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = cur-&gt;children.<span class="built_in">begin</span>();</span><br><span class="line">				it != cur-&gt;children.<span class="built_in">end</span>(); ++it)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (theSize &gt; <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = cur-&gt;children.<span class="built_in">begin</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				it++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator itt = cur-&gt;children.<span class="built_in">end</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">				itt--;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; itt-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				itt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">posTra</span><span class="params">(node* curr)</span> </span>&#123;</span><br><span class="line">		posOrder.push_back(curr-&gt;name);</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = curr-&gt;children.<span class="built_in">begin</span>();</span><br><span class="line">			it != curr-&gt;children.<span class="built_in">end</span>(); ++it)</span><br><span class="line">			posTra(it-&gt;second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (updated || posOrder.empty()) &#123;</span><br><span class="line">			posOrder.<span class="built_in">clear</span>();</span><br><span class="line">			posTra(cur);</span><br><span class="line">		&#125;</span><br><span class="line">		updated = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">int</span> theSize = posOrder.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">if</span> (theSize == <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"EMPTY"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (theSize &gt; <span class="number">1</span> &amp;&amp; theSize &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != theSize; i++)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; posOrder[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (theSize &gt; <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; posOrder[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = theSize - <span class="number">5</span>; i != theSize; i++)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; posOrder[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (opeS.empty())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		updated = <span class="literal">true</span>;</span><br><span class="line">		pair&lt;<span class="keyword">int</span>, node*&gt; pS = opeS.top();</span><br><span class="line">		opeS.pop();</span><br><span class="line">		<span class="keyword">if</span> (pS.first == <span class="number">0</span>) &#123;</span><br><span class="line">			node* dest = pS.second;</span><br><span class="line">			<span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = cur-&gt;children.<span class="built_in">find</span>(dest-&gt;name);</span><br><span class="line">			<span class="keyword">if</span> (it == cur-&gt;children.<span class="built_in">end</span>())</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">			cur-&gt;children.erase(it);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">maintain</span>(cur, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pS.first == <span class="number">1</span>) &#123;</span><br><span class="line">			node* dest = pS.second;</span><br><span class="line">			<span class="keyword">if</span> (cur-&gt;children.<span class="built_in">find</span>(dest-&gt;name) != cur-&gt;children.<span class="built_in">end</span>())</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">			cur-&gt;children.insert(make_pair(dest-&gt;name, dest));</span><br><span class="line"></span><br><span class="line">			<span class="built_in">maintain</span>(cur, dest-&gt;sz);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pS.first == <span class="number">2</span>) &#123;</span><br><span class="line">			cur = pS.second;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		node* p0 = cur;</span><br><span class="line">		<span class="keyword">delete</span> p0;</span><br><span class="line">		node* p1 = root;</span><br><span class="line">		<span class="keyword">delete</span> p1;</span><br><span class="line">		root = <span class="literal">NULL</span>;</span><br><span class="line">		cur = <span class="literal">NULL</span>;</span><br><span class="line">		posOrder.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">while</span> (!opeS.empty())</span><br><span class="line">			opeS.pop();</span><br><span class="line">		p0 = <span class="literal">NULL</span>;</span><br><span class="line">		p1 = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; Cmap;</span><br><span class="line">	Cmap[<span class="string">"MKDIR"</span>] = <span class="number">0</span>;</span><br><span class="line">	Cmap[<span class="string">"RM"</span>] = <span class="number">1</span>;</span><br><span class="line">	Cmap[<span class="string">"CD"</span>] = <span class="number">2</span>;</span><br><span class="line">	Cmap[<span class="string">"SZ"</span>] = <span class="number">3</span>;</span><br><span class="line">	Cmap[<span class="string">"LS"</span>] = <span class="number">4</span>;</span><br><span class="line">	Cmap[<span class="string">"TREE"</span>] = <span class="number">5</span>;</span><br><span class="line">	Cmap[<span class="string">"UNDO"</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">int</span> forEmptyOutput = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (forEmptyOutput &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> Q;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">		directory D;</span><br><span class="line">		<span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">			<span class="built_in">string</span> cmder;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; cmder;</span><br><span class="line">			<span class="keyword">switch</span> (Cmap[cmder]) &#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0</span>: &#123; <span class="comment">// make sub directory</span></span><br><span class="line">					<span class="built_in">string</span> s;</span><br><span class="line">					<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">					<span class="keyword">bool</span> result = D.insert(s);</span><br><span class="line">					<span class="keyword">if</span> (result)</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; <span class="string">"OK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">if</span> (!result)</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERR"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">1</span>: &#123; <span class="comment">// delete sub directory</span></span><br><span class="line">					<span class="built_in">string</span> s;</span><br><span class="line">					<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">					<span class="keyword">bool</span> result = D.<span class="built_in">remove</span>(s);</span><br><span class="line">					<span class="keyword">if</span> (result)</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; <span class="string">"OK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">if</span> (!result)</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERR"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">2</span>: &#123; <span class="comment">// enter sub directory s</span></span><br><span class="line">					<span class="built_in">string</span> s;</span><br><span class="line">					<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">					<span class="keyword">bool</span> result = D.enter(s);</span><br><span class="line">					<span class="keyword">if</span> (result)</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; <span class="string">"OK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">if</span> (!result)</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERR"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">3</span>: &#123; <span class="comment">// output temporary size</span></span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; D.curSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">4</span>: &#123; <span class="comment">// output direct sub directory names</span></span><br><span class="line">					D.currOutput();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">5</span>: &#123; <span class="comment">// posTraversal</span></span><br><span class="line">					D.output();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">6</span>: &#123; <span class="comment">// undo MKDIR/RM/CD</span></span><br><span class="line">					<span class="keyword">bool</span> result = D.undo();</span><br><span class="line">					<span class="keyword">if</span> (result)</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; <span class="string">"OK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">if</span> (!result)</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERR"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		forEmptyOutput++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原题链接🔗"><a href="#原题链接🔗" class="headerlink" title="原题链接🔗"></a><strong>原题链接🔗</strong></h2><p><a href="https://icpcarchive.ecs.baylor.edu/external/78/7843.pdf" target="_blank" rel="noopener">https://icpcarchive.ecs.baylor.edu/external/78/7843.pdf</a></p>
]]></content>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>贪婪算法 选数问题</title>
    <url>/2020/03/06/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95-%E9%80%89%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="选数问题"><a href="#选数问题" class="headerlink" title="选数问题"></a><strong>选数问题</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given n positive numbers, ZJM can select exactly K of them that sums to S. Now ZJM wonders how many ways to get it!</span><br><span class="line">_______________________________________________________</span><br><span class="line">给出n个正数，选出其中K个，使其总和为S —— 问共有多少种方法？</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The first line, an integer T ≤ 100, indicates the number of test cases. For each case, there are two lines. The first line, three integers indicate n, K and S. The second line, n integers indicate the positive numbers.</span><br><span class="line">Remember that k ≤ n ≤ 16 and all numbers can be stored in 32-bit integer. </span><br><span class="line">_______________________________________________________</span><br><span class="line">第一行，一个整数 T (T ≤ 100), 表示数据组数。</span><br><span class="line">对于每组数据，接下来两行，第一行：3个整数 n, K, S。第二行：n 个正整数。</span><br><span class="line">k ≤ n ≤ 16。所有数都能存在32位寄存器中。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">For each case, an integer indicate the answer in a independent line.</span><br><span class="line">____________________________</span><br><span class="line">对于每组数据，独立一行输出答案。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input: </span><br><span class="line">1</span><br><span class="line">10 3 10</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		3000 ms</span><br><span class="line">Memory limit	262144 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>组合问题。<br>n个选出K个，共有${n \choose K}$种组合，然后从这些组合中选出符合数之和为S的情况即可。<br><del>由于这是A题，暴力求解，不要太在意时间复杂度🙄。</del><br>利用递归，每次枚举一个数加入到<code>res</code>数组中，递归之后由于每次加入的数不同，会产生多个分支。在这些分支上最终生成的数组就是这n个数的所有含有K个元素的子集，对这些子集元素求和判断是否为S即可。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*贪婪算法 每次都把可行的数加入到res数组中，加入的数达到n个后，求和*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">greedy</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> n, <span class="keyword">int</span> K, <span class="keyword">int</span> S, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == n) &#123;<span class="comment">//总的n个数，已经全部考虑了</span></span><br><span class="line">		<span class="keyword">if</span> (res.<span class="built_in">size</span>() == K) &#123;<span class="comment">//新数组已经达到要求的K个数时</span></span><br><span class="line">			<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != K; j++)</span><br><span class="line">				sum += res.at(j);<span class="comment">//求这些数的和</span></span><br><span class="line">			<span class="keyword">if</span> (sum == S)<span class="comment">//该情况可行 达成目标</span></span><br><span class="line">				total++;<span class="comment">//计数 + 1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//递归枚举每个数，生成子集</span></span><br><span class="line">	greedy(arr, n, K, S, i + <span class="number">1</span>, res);</span><br><span class="line">	res.push_back(arr[i]);</span><br><span class="line">	greedy(arr, n, K, S, i + <span class="number">1</span>, res);</span><br><span class="line">	res.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> n, K, S;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K &gt;&gt; S;<span class="comment">//n个数 选出K个 其和为S</span></span><br><span class="line">		<span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">5</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr[j];</span><br><span class="line">		total = <span class="number">0</span>;<span class="comment">//共有total种方案</span></span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">		greedy(arr, n, K, S, <span class="number">0</span>, v);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪婪算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪婪算法-区间选点问题</title>
    <url>/2020/03/19/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="区间选点问题"><a href="#区间选点问题" class="headerlink" title="区间选点问题"></a><strong>区间选点问题</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数轴上有 n 个闭区间 [ai, bi]。取尽量少的点，使得每个区间内都至少有一个点（不同区间内含的点可以是同一个）</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行1个整数 N（N ≤ 100）</span><br><span class="line">第 2~N+1 行，每行两个整数 a,b（a, b ≤ 100）</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个整数，代表选点的数目</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">2</span><br><span class="line">1 5</span><br><span class="line">4 6</span><br><span class="line">Output: </span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">2 5</span><br><span class="line">4 6</span><br><span class="line">Output: </span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	262144 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>按<code>b</code>的大小，将这些区间升序排序；当<code>b</code>相同时，按<code>a</code>降序。<br>排序完之后，将这些区间遍历，每次计数<code>count</code>增加时，证明这个区间与前面的区间没有重叠部分，因此可以把这个区间的<code>b</code>端作为接下来要判断的区间的判断点。<br>如果某区间与前一区间有重叠，那么一定有<code>该区间的a端 ≤ 上一区间的b端</code>且<code>该区间的b端 ≥ 上一区间的b端</code>。</p>
<p>如果第一字典不是<code>b</code>，而是<code>a</code>，按升序排列呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;第一字典为b</span><br><span class="line">    (X)___________</span><br><span class="line">(Y)________________________</span><br><span class="line">                      (Z)_________</span><br><span class="line">X和Y可共计1点, Z再算1点，总数共2点</span><br><span class="line">-----------------------------------------</span><br><span class="line">&gt;&gt;&gt;第一字典为a</span><br><span class="line">(Y)________________________</span><br><span class="line">    (X)___________</span><br><span class="line">                      (Z)_________</span><br><span class="line">X的a在Y的b前面，但X的b也在Y前面。</span><br><span class="line">情况一：</span><br><span class="line">if条件不考虑X的b，则Y与X归类，标记点仍为Y的b</span><br><span class="line">Z也会与Y归类。总数共计1点(Wrong Answer)</span><br><span class="line">情况二：</span><br><span class="line">if条件考虑X的b，Y不与X归类，计数+1，标记点变成X的b</span><br><span class="line">X明显不能与Z归类，计数+1，标记Z的b，到尾了，计数+1</span><br><span class="line">总数共计3点(Wrong Answer)</span><br><span class="line"></span><br><span class="line">标记点若改成a端呢？</span><br><span class="line">由于按a升序，按a端一定无法判断2个区间是否重叠！</span><br></pre></td></tr></table></figure>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*两点 表示区间*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">range</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	range(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b) :a(_a), b(_b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dotRange</span><span class="params">(<span class="built_in">vector</span>&lt;range&gt; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//按b升序 按a降序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != v.<span class="built_in">size</span>() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v.at(j).b &gt; v.at(j + <span class="number">1</span>).b)</span><br><span class="line">				swap(v.at(j), v.at(j + <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">if</span> (v.at(j).b == v.at(j + <span class="number">1</span>).b)</span><br><span class="line">				<span class="keyword">if</span> (v.at(j).a &lt; v.at(j + <span class="number">1</span>).a)</span><br><span class="line">					swap(v.at(j), v.at(j + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> dot = v.at(<span class="number">0</span>).b;<span class="comment">//排序后从头开始遍历 把第一个区间的末端作为判断点</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;<span class="comment">//计数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v.at(i).a &lt;= dot &amp;&amp; v.at(i).b &gt;= dot) &#123;<span class="comment">//与本次标记区间有重叠 无需计数</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//到了没有重叠的区间 可计数</span></span><br><span class="line">			count++;</span><br><span class="line">			dot = v.at(i).b;<span class="comment">//并以该区间的末端作为接下来的区间判断点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;range&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="function">range <span class="title">r</span><span class="params">(a, b)</span></span>;</span><br><span class="line">		v.push_back(r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dotRange(v) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪婪算法</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫问题 广度优先搜索</title>
    <url>/2020/03/05/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="迷宫问题-广度优先搜索"><a href="#迷宫问题-广度优先搜索" class="headerlink" title="迷宫问题: 广度优先搜索"></a><strong>迷宫问题: 广度优先搜索</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">东东有一张地图，想通过地图找到妹纸。地图显示，0表示可以走，1表示不可以走，左上角是入口，右下角是妹纸，这两个位置保证为0。既然已经知道了地图，那么东东找到妹纸就不难了，请你编一个程序，写出东东找到妹纸的最短路线。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入是一个5 × 5的二维数组，仅由0、1两数字组成，表示法阵地图。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出若干行，表示从左上角到右下角的最短路径依次经过的坐标，格式如样例所示。数据保证有唯一解。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input: </span><br><span class="line">0 1 0 0 0</span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 0 0 1 0</span><br><span class="line">0 1 0 1 0</span><br><span class="line"></span><br><span class="line">output: </span><br><span class="line">(0, 0)</span><br><span class="line">(1, 0)</span><br><span class="line">(2, 0)</span><br><span class="line">(3, 0)</span><br><span class="line">(3, 1)</span><br><span class="line">(3, 2)</span><br><span class="line">(2, 2)</span><br><span class="line">(1, 2)</span><br><span class="line">(0, 2)</span><br><span class="line">(0, 3)</span><br><span class="line">(0, 4)</span><br><span class="line">(1, 4)</span><br><span class="line">(2, 4)</span><br><span class="line">(3, 4)</span><br><span class="line">(4, 4)</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>广度优先搜索(BFS)：<br>从起始点开始遍历，先从相邻的点找起，如果可行，则加入生成的路径，同时已经加入的点不会再次访问。比如题中样例，BFS生成的路径用2表示，则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 0 0 0				2 1 2 2 2</span><br><span class="line">0 1 0 1 0				2 1 2 1 2</span><br><span class="line">0 1 0 1 0		→		2 1 2 1 2</span><br><span class="line">0 0 0 1 0				2 2 2 1 2</span><br><span class="line">0 1 0 1 0				0 1 2 1 2</span><br></pre></td></tr></table></figure>
<p>再比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 0 0 0				2 1 2 2 2</span><br><span class="line">0 1 0 1 0				2 1 2 1 2</span><br><span class="line">0 0 0 1 0		→		2 2 2 1 2</span><br><span class="line">0 1 0 1 1				0 1 2 1 1</span><br><span class="line">0 1 0 0 0				0 1 2 2 2</span><br></pre></td></tr></table></figure>
<p>同时这也产生了一个问题：没必要走的点加入了路径中！广搜产生的分支好比一棵树的枝干的枝杈，主枝一直往前延申直到终点，但分支也随之产生去探寻分支的终点，直到某个枝杈到达了目标终点，才能分辨出谁是主枝，剩下的才是分支。</p>
<p>所以通过终点，往回退，避开产生的分支，最后走回起点，这样就生成了最终路径。</p>
<p>详见代码。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*点的结构体  表示(x, y)坐标*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">int</span> dis;<span class="comment">//用于记录原点到当前点路径上的距离</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于上下左右移动*/</span></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> reach[<span class="number">5</span>][<span class="number">5</span>];<span class="comment">//标记到达的数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; path;<span class="comment">//生成路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">neighbour</span><span class="params">(<span class="built_in">point</span> a, <span class="built_in">point</span> b)</span> </span>&#123;<span class="comment">//判断两点是否相邻(上、下、左、右)</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">abs</span>(a.x - b.x) == <span class="number">1</span> &amp;&amp; a.y == b.y) || (<span class="built_in">abs</span>(a.y - b.y) == <span class="number">1</span> &amp;&amp; a.x == b.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> maze[<span class="number">5</span>][<span class="number">5</span>])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化点坐标</span></span><br><span class="line">	<span class="built_in">point</span> dot;</span><br><span class="line">	dot.x = <span class="number">0</span>;</span><br><span class="line">	dot.y = <span class="number">0</span>;</span><br><span class="line">	dot.dis = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="built_in">point</span>&gt; q;<span class="comment">//队列 用于记录走过的点与下一可行点 保证先进先出</span></span><br><span class="line">	q.push(dot);<span class="comment">//起点(0, 0)开始，入队</span></span><br><span class="line">	reach[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//(0, 0)已走过</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="built_in">point</span> curr = q.front();<span class="comment">//从队首取点，保证先进先出</span></span><br><span class="line">		path.push_back(curr);<span class="comment">//点可行 记入生成路径</span></span><br><span class="line">		q.pop();<span class="comment">//取走后就要出队</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;<span class="comment">//从取走的点开始上下左右判断可不可以走</span></span><br><span class="line">			<span class="keyword">int</span> x = curr.x + dx[i];</span><br><span class="line">			<span class="keyword">int</span> y = curr.y + dy[i];</span><br><span class="line">			<span class="comment">/*若在图边界内 且 非墙 且 还没走*/</span></span><br><span class="line">			<span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">5</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; <span class="number">5</span></span><br><span class="line">				&amp;&amp; maze[x][y] != <span class="number">1</span> &amp;&amp; reach[x][y] != <span class="number">1</span>) &#123;</span><br><span class="line">				reach[x][y] = <span class="number">1</span>;<span class="comment">//reached</span></span><br><span class="line">				curr.x = x, curr.y = y;</span><br><span class="line">				curr.dis++;</span><br><span class="line">				q.push(curr);<span class="comment">//可行 入队</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maze[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; maze[i][j];<span class="comment">//录入迷宫</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">			reach[i][j] = <span class="number">0</span>;<span class="comment">//初始化所有点未到达</span></span><br><span class="line"></span><br><span class="line">	bfs(maze);<span class="comment">//生成路径</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != path.<span class="built_in">size</span>(); ++i)<span class="comment">//从生成路径中寻找终点的位置</span></span><br><span class="line">		<span class="keyword">if</span> (path.at(i).x == <span class="number">4</span> &amp;&amp; path.at(i).y == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">end</span> = i;<span class="comment">//是终点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">end</span> != path.<span class="built_in">size</span>() - <span class="number">1</span>)<span class="comment">//如果终点不是生成路径的最后一个点的话</span></span><br><span class="line">		path.erase(path.<span class="built_in">begin</span>() + <span class="built_in">end</span> + <span class="number">1</span>, path.<span class="built_in">end</span>());<span class="comment">//后面的分支就可以移除了</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*从终点开始往前找路径*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = path.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!neighbour(path.at(i), path.at(i - <span class="number">1</span>)) ||</span><br><span class="line">			(path.at(i).dis - path.at(i - <span class="number">1</span>).dis != <span class="number">1</span>))</span><br><span class="line">         <span class="comment">/* 若前后的点非相邻点 或相邻两点距原点的路径距离差非1 */</span></span><br><span class="line">			path.erase(path.<span class="built_in">begin</span>() + i - <span class="number">1</span>);<span class="comment">//这个点可删除</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != path.<span class="built_in">size</span>(); ++i)<span class="comment">//输出</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; path.at(i).x &lt;&lt; <span class="string">", "</span> &lt;&lt; path.at(i).y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>贪婪算法-区间覆盖问题</title>
    <url>/2020/03/19/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="区间覆盖问题"><a href="#区间覆盖问题" class="headerlink" title="区间覆盖问题"></a><strong>区间覆盖问题</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数轴上有 n (1 ≤ n ≤ 25000) 个闭区间 [ai, bi]，选择尽量少的区间覆盖一条指定线段 [1, t] ( 1 ≤ t ≤ 1,000,000)。</span><br><span class="line">覆盖整点，即[1,2]+[3,4]可以覆盖[1,4]。</span><br><span class="line">不可能办到输出-1</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行：N 和 T</span><br><span class="line">第二行至 N+1 行: 每一行一个闭区间。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择的区间的数目，不可能办到输出-1</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">3 10</span><br><span class="line">1 7</span><br><span class="line">3 6</span><br><span class="line">6 10</span><br><span class="line">Output: </span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	65536 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>这道题<code>WA</code>了好多次，主要是整点覆盖比较坑，是要在录入时就进行<code>始端-1</code>或者<code>末端+1</code>，还是在<code>if</code>条件判断的时候考虑整点，容易出错，可能会多考虑了区间比如<code>[1, 2]</code>和<code>[4, 5]</code> (2往后延长到3, 4往前延长到3)。还有录入的时候我进行了裁剪，我怕<code>[-2, 1]</code>裁剪成<code>[1, 1]</code>会影响对<code>[2, 3]</code>的判断，就选择了在<code>if</code>处判断整点，而没有选择延长区间。</p>
<p>首先对区间a升序，a相同时按b降序，保证每次能选到的区间最长。每次标记一个区间的起点<code>begin</code>和终点<code>end</code>，再从接下来的区间中选取起点落在<code>[begin, end+1]</code>范围内的，可行就选取最长的，然后更新起点<code>begin</code>和终点<code>end</code>，计数 + 1，如此循环，直到遇到目标终点<code>t</code>。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*区间 [a, b] */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">range</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	range(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b) :a(_a), b(_b) &#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> range r)<span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (a == r.a)</span><br><span class="line">			<span class="keyword">return</span> b &gt; r.b;</span><br><span class="line">		<span class="keyword">return</span> a &lt; r.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeCover</span><span class="params">(<span class="built_in">vector</span>&lt;range&gt; v, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//按a升序 按b降序</span></span><br><span class="line">	sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (v.at(<span class="number">0</span>).a &gt; <span class="number">1</span>)<span class="comment">//起始不是 1，一定不能办到</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//标记当前选取区间的起点，终点</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">1</span>, <span class="built_in">end</span> = v.at(<span class="number">0</span>).b, pos = <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">end</span> != t) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">begin</span> = <span class="built_in">end</span> + <span class="number">1</span>;<span class="comment">//下一个标记的起始点为本次标记终点+1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v.at(i).a &gt; <span class="built_in">begin</span>) &#123;<span class="comment">//遇到了第一个起始点 &gt; 标记起始点的</span></span><br><span class="line">				pos = i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (v.at(i).a &lt;= <span class="built_in">begin</span> &amp;&amp; v.at(i).b &gt;= <span class="built_in">end</span>) &#123;<span class="comment">//可选区间</span></span><br><span class="line">				temp = i;<span class="comment">//记录当前标号</span></span><br><span class="line">				<span class="built_in">end</span> = v.at(i).b;<span class="comment">//更新标记末端</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">begin</span> &gt; <span class="built_in">end</span>) &#123;<span class="comment">//标记了下一个区间的起始点 但没有找到此区间</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//这个标记的区间可行</span></span><br><span class="line">			pos = temp + <span class="number">1</span>;<span class="comment">//从那个标记的标号开始 进行下一次循环</span></span><br><span class="line">			count++;<span class="comment">//计数+1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, t;</span><br><span class="line">	scanf_s(<span class="string">"%d%d"</span>, &amp;n, &amp;t);</span><br><span class="line">	<span class="built_in">vector</span>&lt;range&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		scanf_s(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="keyword">if</span> ((a &gt;= <span class="number">1</span> &amp;&amp; a &lt;= t) || (b &gt;= <span class="number">1</span> &amp;&amp; b &lt;= t)) &#123;<span class="comment">//先对输入进行裁剪</span></span><br><span class="line">			<span class="keyword">if</span> (a &lt; <span class="number">1</span>)<span class="comment">//合法区间 但 a &lt; 1，可令 a = 1</span></span><br><span class="line">				a = <span class="number">1</span>;</span><br><span class="line">			<span class="function">range <span class="title">r</span><span class="params">(a, b)</span></span>;</span><br><span class="line">			v.push_back(r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> res = rangeCover(v, t);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪婪算法</tag>
      </tags>
  </entry>
  <entry>
    <title>路径解析</title>
    <url>/2020/04/03/%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="路径解析"><a href="#路径解析" class="headerlink" title="路径解析"></a><strong>路径解析</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在操作系统中，数据通常以文件的形式存储在文件系统中。文件系统一般采用层次化的组织形式，由目录（或者文件夹）和文件构成，形成一棵树的形状。文件有内容，用于存储数据。目录是容器，可包含文件或其他目录。同一个目录下的所有文件和目录的名字各不相同，不同目录下可以有名字相同的文件或目录。</span><br><span class="line">　　为了指定文件系统中的某个文件，需要用路径来定位。在类 Unix 系统（Linux、Max OS X、FreeBSD等）中，路径由若干部分构成，每个部分是一个目录或者文件的名字，相邻两个部分之间用 &#x2F; 符号分隔。</span><br><span class="line">　　有一个特殊的目录被称为根目录，是整个文件系统形成的这棵树的根节点，用一个单独的 &#x2F; 符号表示。在操作系统中，有当前目录的概念，表示用户目前正在工作的目录。根据出发点可以把路径分为两类：</span><br><span class="line">　　 绝对路径：以 &#x2F; 符号开头，表示从根目录开始构建的路径。</span><br><span class="line">　　 相对路径：不以 &#x2F; 符号开头，表示从当前目录开始构建的路径。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    例如，有一个文件系统的结构如下图所示。在这个文件系统中，有根目录 &#x2F; 和其他普通目录 d1、d2、d3、d4，以及文件 f1、f2、f3、f1、f4。其中，两个 f1 是同名文件，但在不同的目录下。</span><br><span class="line">&#x2F; -+- d1 -+- f1</span><br><span class="line">   |      \- f2</span><br><span class="line">   |</span><br><span class="line">   \- d2 -+- d3 --- f3</span><br><span class="line">          |</span><br><span class="line">          +- d4 --- f1</span><br><span class="line">          |</span><br><span class="line">          \- f4</span><br><span class="line">　　对于 d4 目录下的 f1 文件，可以用绝对路径 &#x2F;d2&#x2F;d4&#x2F;f1 来指定。如果当前目录是 &#x2F;d2&#x2F;d3，这个文件也可以用相对路径 ..&#x2F;d4&#x2F;f1 来指定，这里 .. 表示上一级目录（注意，根目录的上一级目录是它本身）。还有 . 表示本目录，例如 &#x2F;d1&#x2F;.&#x2F;f1 指定的就是 &#x2F;d1&#x2F;f1。注意，如果有多个连续的 &#x2F; 出现，其效果等同于一个 &#x2F;，例如 &#x2F;d1&#x2F;&#x2F;&#x2F;f1 指定的也是 &#x2F;d1&#x2F;f1。</span><br><span class="line">　　本题会给出一些路径，要求对于每个路径，给出正规化以后的形式。一个路径经过正规化操作后，其指定的文件不变，但是会变成一个不包含 . 和 .. 的绝对路径，且不包含连续多个 &#x2F; 符号。如果一个路径以 &#x2F; 结尾，那么它代表的一定是一个目录，正规化操作要去掉结尾的 &#x2F;。若这个路径代表根目录，则正规化操作的结果是 &#x2F;。若路径为空字符串，则正规化操作的结果是当前目录。</span><br></pre></td></tr></table></figure>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行包含一个整数 P，表示需要进行正规化操作的路径个数。</span><br><span class="line">第二行包含一个字符串，表示当前目录。</span><br><span class="line">以下 P 行，每行包含一个字符串，表示需要进行正规化操作的路径。</span><br><span class="line"></span><br><span class="line">1 ≤ P ≤ 10。</span><br><span class="line">文件和目录的名字只包含大小写字母、数字和小数点 .、减号 - 以及下划线 _。</span><br><span class="line">不会有文件或目录的名字是 . 或 .. ，它们具有题目描述中给出的特殊含义。</span><br><span class="line">输入的所有路径每个长度不超过 1000 个字符。</span><br><span class="line">输入的当前目录保证是一个经过正规化操作后的路径。</span><br><span class="line">对于前 30% 的测试用例，需要正规化的路径的组成部分不包含 . 和 .. 。</span><br><span class="line">对于前 60% 的测试用例，需要正规化的路径都是绝对路径。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">共 P 行，每行一个字符串，表示经过正规化操作后的路径，顺序与输入对应。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input: </span><br><span class="line">7</span><br><span class="line">&#x2F;d2&#x2F;d3</span><br><span class="line">&#x2F;d2&#x2F;d4&#x2F;f1</span><br><span class="line">..&#x2F;d4&#x2F;f1</span><br><span class="line">&#x2F;d1&#x2F;.&#x2F;f1</span><br><span class="line">&#x2F;d1&#x2F;&#x2F;&#x2F;f1</span><br><span class="line">&#x2F;d1&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;d1&#x2F;..&#x2F;..&#x2F;d2</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&#x2F;d2&#x2F;d4&#x2F;f1</span><br><span class="line">&#x2F;d2&#x2F;d4&#x2F;f1</span><br><span class="line">&#x2F;d1&#x2F;f1</span><br><span class="line">&#x2F;d1&#x2F;f1</span><br><span class="line">&#x2F;d1</span><br><span class="line">&#x2F;</span><br><span class="line">&#x2F;d2</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	262144 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>题目很长，但是只要提取出以下关键点即可: </p>
<ol>
<li><code>/</code> 表示根目录</li>
<li><strong>绝对路径</strong>以 <code>/</code> 符号开头，表示从<strong>根目录</strong>开始构建的路径。</li>
<li><strong>相对路径</strong>不以 <code>/</code> 符号开头，表示从<strong>当前目录</strong>开始构建的路径。</li>
<li><code>..</code> 表示上一级目录，根目录的上一级目录是它<strong>本身</strong></li>
<li><code>/d1/./f1</code> = <code>/d1/f1</code>，即<code>/./</code> = <code>/</code></li>
<li><code>/d1///f1</code> = <code>/d1/f1</code>，即<code>/// = /</code></li>
<li>路径以 <code>/</code> 结尾，那么它代表的一定是一个目录，正规化操作要去掉结尾的 <code>/</code></li>
<li>若这个路径代表根目录，则正规化操作的结果是 <code>/</code></li>
<li>若路径为空字符串，则正规化操作的结果是当前目录</li>
<li>文件和目录的名字只包含大小写字母、数字和小数点 <code>.</code>、减号 <code>-</code> 以及下划线 <code>_</code>。</li>
<li>不会有文件或目录的名字是 <code>.</code> 或 <code>..</code> ，它们具有题目描述中给出的特殊含义。</li>
</ol>
<p>先是处理绝对路径与相对路径的问题：相对路径不以<code>/</code>开头，所以可以把相对路径变成绝对路径，即把当前路径加在相对路径前，就变成了绝对路径，接下来就变成了处理绝对路径的问题。</p>
<p>首先是处理多个<code>/</code>的问题，可以利用<code>/</code>将字符串分隔成多个目录或文件，储存到数组中，最后输出时再把数组元素前加上<code>/</code>即可。</p>
<p>然后就是处理<code>.</code>跟<code>..</code>，由于前面已经把<code>/</code>去除，结果所有字串存在数组里，接下来只要去除<code>..</code>跟上级目录、去除<code>.</code>就行。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> root, <span class="built_in">string</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a[<span class="number">0</span>] != <span class="string">'/'</span>)</span><br><span class="line">		a = root + <span class="string">'/'</span> + a;<span class="comment">//相对路径变成绝对路径</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">	<span class="built_in">string</span> temp = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">bool</span> found = <span class="literal">true</span>;<span class="comment">//标记是否遇到 '/', 便于处理以 '/' 结尾</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] == <span class="string">'/'</span> || i == a.<span class="built_in">size</span>()) &#123;<span class="comment">//遇到了 '/' 或到头了</span></span><br><span class="line">			<span class="keyword">if</span> (found == <span class="literal">false</span>) &#123;<span class="comment">// 不是连续出现的 '/'</span></span><br><span class="line">				found = <span class="literal">true</span>;</span><br><span class="line">				v.push_back(temp);</span><br><span class="line">				temp.<span class="built_in">clear</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//没遇到 '/' 就一路通行，将字符一个一个加入temp</span></span><br><span class="line">			found = <span class="literal">false</span>;</span><br><span class="line">			temp += a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>();) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v[i] == <span class="string">".."</span>) &#123;<span class="comment">//遇到了 '..'</span></span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;<span class="comment">//擦除 '..' 和上级</span></span><br><span class="line">				i--;</span><br><span class="line">				v.erase(v.<span class="built_in">begin</span>() + i);</span><br><span class="line">				v.erase(v.<span class="built_in">begin</span>() + i);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				v.erase(v.<span class="built_in">begin</span>() + i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (v[i] == <span class="string">"."</span>)<span class="comment">//遇到了一个'.'</span></span><br><span class="line">			v.erase(v.<span class="built_in">begin</span>() + i);<span class="comment">//直接去掉</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			i++;<span class="comment">//指针前进</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">if</span> (v.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">		res = <span class="string">"/"</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			res += <span class="string">"/"</span>;</span><br><span class="line">			res+= v[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">	<span class="built_in">string</span> curr;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; curr;</span><br><span class="line">	<span class="built_in">cin</span>.ignore();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != p; i++) &#123;</span><br><span class="line">		<span class="built_in">string</span> a;</span><br><span class="line">		getline(<span class="built_in">cin</span>, a);</span><br><span class="line">		<span class="built_in">string</span> b = convert(curr, a);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>预测名次</title>
    <url>/2020/04/15/%E9%A2%84%E6%B5%8B%E5%90%8D%E6%AC%A1/</url>
    <content><![CDATA[<h1 id="猫猫比赛-预测名次"><a href="#猫猫比赛-预测名次" class="headerlink" title="猫猫比赛-预测名次"></a><strong>猫猫比赛-预测名次</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一共有 N 只猫猫，编号依次为1, 2, 3, …, N 进行比赛，求字典序最小的名次序列。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入有若干组，每组中的第一行为二个数 N (1 ≤ N ≤ 500), M；其中 N 表示猫猫的个数，M 表示接着有 M 行的输入数据。接下来的 M 行数据中，每行也有两个整数 P1, P2 表示即编号为 P1 的猫猫赢了编号为 P2 的猫猫。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出一个符合要求的排名。输出时猫猫的编号之间有空格，最后一名后面没有空格!</span><br><span class="line"></span><br><span class="line">其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">1 2 4 3</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	32768 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>比赛问题，若A胜B，A胜C，B胜C，则A的名次在B、C的前面，B的名次在C的前面，可以构成有向无环图，因此可以使用拓扑排序。</p>
<p>集合<code>U</code>为点集，每次选出入度为零的点<code>s</code>，加入结果集合<code>S</code>中，并从<code>U</code>中删除<code>s</code>，并修改<code>s</code>指向的点的入度，以此循环，直至<code>U</code>为空。</p>
<p>由于每次选的入度为零的点有多个，本题要求以字典序输出，因此可用优先级队列储存每次选取的入度为零的点，然后进行BFS，遍历全图。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ele;</span><br><span class="line">	node* next;</span><br><span class="line">	node() &#123; ele = <span class="number">-1</span>; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">	node(<span class="keyword">int</span> e) :ele(e) &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	node* header;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	linkedList() &#123; header = <span class="literal">NULL</span>; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">	~linkedList() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size</span>; &#125;</span><br><span class="line">	<span class="function">node* <span class="title">getHeader</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> ele)</span> </span>&#123;</span><br><span class="line">		node* p = <span class="keyword">new</span> node(ele);</span><br><span class="line">		<span class="keyword">if</span> (header == <span class="literal">NULL</span>)</span><br><span class="line">			header = p;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			node* temp = header;</span><br><span class="line">			node* temp2 = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				temp2 = temp;</span><br><span class="line">				temp = temp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			temp2-&gt;next = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">size</span>++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		node* temp = header;</span><br><span class="line">		node* ttemp = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			ttemp = temp;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">			ttemp = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		header = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">delete</span> temp;</span><br><span class="line">		<span class="keyword">delete</span> ttemp;</span><br><span class="line">		<span class="keyword">delete</span> header;</span><br><span class="line">		<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	linkedList arr[maxN];</span><br><span class="line">	<span class="keyword">int</span> inDeg[maxN];</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	graph() &#123; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">	graph(<span class="keyword">int</span> n) &#123; <span class="built_in">size</span> = n; setIN(); &#125;</span><br><span class="line">	~graph() &#123;  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setIN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">size</span>; i++)</span><br><span class="line">			inDeg[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;</span><br><span class="line">		arr[p1].add(p2);</span><br><span class="line">		inDeg[p2]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>; i++)</span><br><span class="line">			<span class="keyword">if</span> (inDeg[i] == <span class="number">0</span>)</span><br><span class="line">				q.push(i);<span class="comment">//所有入度为零的点入队</span></span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = q.top();<span class="comment">//选出队首元素 开始遍历</span></span><br><span class="line">			q.pop();</span><br><span class="line">			ans.push_back(x);</span><br><span class="line">			<span class="keyword">for</span> (node* p = arr[x].getHeader(); p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">				<span class="keyword">int</span> ele = p-&gt;ele;</span><br><span class="line">				inDeg[ele]--;<span class="comment">//与之相邻的点入度 -1</span></span><br><span class="line">				<span class="keyword">if</span> (inDeg[ele] == <span class="number">0</span>)<span class="comment">//入度为零 可入队</span></span><br><span class="line">					q.push(ele);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span> (!(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m).eof()) &#123;</span><br><span class="line">		<span class="function">graph <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> p1, p2;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">			G.add(p1, p2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = G.topoSort();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v[v.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>预测胜负</title>
    <url>/2020/04/06/%E9%A2%84%E6%B5%8B%E8%83%9C%E8%B4%9F/</url>
    <content><![CDATA[<h1 id="预测胜负"><a href="#预测胜负" class="headerlink" title="预测胜负"></a><strong>预测胜负</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N 个人玩一个游戏，每两个人都要进行一场比赛。</span><br><span class="line">已知 M 个胜负关系，每个关系为 A B，表示 A 比 B 强， 胜负关系具有传递性。</span><br><span class="line">试问有多少场比赛的胜负无法预先得知？</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行给出数据组数。</span><br><span class="line">每组数据第一行给出 N 和 M（1 ≤ N, M ≤ 500）。</span><br><span class="line">接下来 M 行，每行给出 A B，表示 A 可以胜过 B。</span><br></pre></td></tr></table></figure>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于每一组数据，判断有多少场比赛的胜负不能预先得知。</span><br><span class="line">注意 (a, b) 与 (b, a) 等价，即每一个二元组只被计算一次。</span><br></pre></td></tr></table></figure>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">3</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">Output: </span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time limit		1000 ms</span><br><span class="line">Memory limit	32768 kB</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>Floyd算法：用于寻找加权图中顶点间最短路径的算法。在 n × n 的矩阵 <code>M</code> 中，<code>M[i][j]</code>表示顶点<code>i</code>到顶点<code>j</code>的距离，然后对矩阵进行 <code>n</code> 次更新，第 <code>k</code> 次更新时，如果<code>M[i][j]</code> &gt; <code>M[i][k] + M[k][j]</code>，则更新为<code>M[i][k] + M[k][j]</code>。</p>
<p>本题可用二维数组来表示每个人之间的胜负关系，初始时值为0，表示关系不明。<br>由于胜负关系具有传递性，比如a &gt; b, b &gt; c, 则 a &gt; c，因此可用Floyd算法更新任意两人之间的胜负关系：<br>若<code>arr[a][b] = 1</code>，则a胜b；<br>若<code>arr[a][b] = 0</code>，则a与b胜负关系不明；<br>若<code>arr[a][b] = 1</code>且<code>arr[b][c] = 1</code>，则<code>arr[a][c] = 1</code>；<br>若<code>arr[a][b] = 0</code>且<code>arr[b][a] = 0</code>，则a与b的胜负关系无法预先判断。</p>
<p>所以最后确定多少场无法预知结果的比赛，只需计算<code>arr[a][b] = 0 &amp;&amp; arr[b][a] == 0 &amp;&amp; a != b</code>的个数，结果再除以2即可。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i0 = <span class="number">0</span>; i0 &lt; t; i0++) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> arr[maxN][maxN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> a, b;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			arr[a][b] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Floyd 算法</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				<span class="keyword">if</span> (arr[j][i] == <span class="number">1</span>)<span class="comment">//已知道了两人关系 再进行更新第三人</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">						<span class="keyword">if</span> (arr[i][k] == <span class="number">1</span>)</span><br><span class="line">							arr[j][k] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				<span class="keyword">if</span> (i != j &amp;&amp; arr[i][j] == <span class="number">0</span> &amp;&amp; arr[j][i] == <span class="number">0</span>)</span><br><span class="line">					count++;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; count / <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// i 求了一遍，j 又求了一遍，所以要减半</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Floyd</tag>
      </tags>
  </entry>
</search>
