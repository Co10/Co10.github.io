<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>荒芜知地</title>
  
  <subtitle>无人 唯知</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="co10.github.io/"/>
  <updated>2020-04-20T10:50:41.936Z</updated>
  <id>co10.github.io/</id>
  
  <author>
    <name>K</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>炉石传说</title>
    <link href="co10.github.io/2020/04/18/%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4/"/>
    <id>co10.github.io/2020/04/18/%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4/</id>
    <published>2020-04-18T15:42:48.000Z</published>
    <updated>2020-04-20T10:50:41.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="炉石传说-CSP201609-3"><a href="#炉石传说-CSP201609-3" class="headerlink" title="炉石传说 - CSP201609-3"></a><strong>炉石传说 - CSP201609-3</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">《炉石传说：魔兽英雄传》（Hearthstone: Heroes of Warcraft，简称炉石传说）是暴雪娱乐开发的一款集换式卡牌游戏（如下图所示）。游戏在一个战斗棋盘上进行，由两名玩家轮流进行操作，本题所使用的炉石传说游戏的简化规则如下：</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://i.loli.net/2020/04/18/bUldetRrg5aPp3f.jpg" alt="hearthstone.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">　　* 玩家会控制一些角色，每个角色有自己的生命值和攻击力。当生命值小于等于 0 时，该角色死亡。角色分为英雄和随从。</span><br><span class="line">　　* 玩家各控制一个英雄，游戏开始时，英雄的生命值为 30，攻击力为 0。当英雄死亡时，游戏结束，英雄未死亡的一方获胜。</span><br><span class="line">　　* 玩家可在游戏过程中召唤随从。棋盘上每方都有 7 个可用于放置随从的空位，从左到右一字排开，被称为战场。当随从死亡时，它将被从战场上移除。</span><br><span class="line">　　* 游戏开始后，两位玩家轮流进行操作，每个玩家的连续一组操作称为一个回合。</span><br><span class="line">　　* 每个回合中，当前玩家可进行零个或者多个以下操作：</span><br><span class="line">　　1) 召唤随从：玩家召唤一个随从进入战场，随从具有指定的生命值和攻击力。</span><br><span class="line">　　2) 随从攻击：玩家控制自己的某个随从攻击对手的英雄或者某个随从。</span><br><span class="line">　　3) 结束回合：玩家声明自己的当前回合结束，游戏将进入对手的回合。该操作一定是一个回合的最后一个操作。</span><br><span class="line">　　* 当随从攻击时，攻击方和被攻击方会同时对彼此造成等同于自己攻击力的伤害。受到伤害的角色的生命值将会减少，数值等同于受到的伤害。例如，随从 X 的生命值为 HX、攻击力为 AX，随从 Y 的生命值为 HY、攻击力为 AY，如果随从 X 攻击随从 Y，则攻击发生后随从 X 的生命值变为 HX - AY，随从 Y 的生命值变为 HY - AX。攻击发生后，角色的生命值可以为负数。</span><br><span class="line">　　本题将给出一个游戏的过程，要求编写程序模拟该游戏过程并输出最后的局面。</span><br></pre></td></tr></table></figure><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　输入第一行是一个整数 n (0 ≤ n ≤ 1000)，表示操作的个数。接下来 n 行，每行描述一个操作，格式如下：</span><br><span class="line">　　&lt;action&gt; &lt;arg1&gt; &lt;arg2&gt; ...</span><br><span class="line">　　其中&lt;action&gt;表示操作类型，是一个字符串，共有 3 种：summon表示召唤随从，attack表示随从攻击，end表示结束回合。这 3 种操作的具体格式如下：</span><br><span class="line">　　* summon &lt;position&gt; &lt;attack&gt; &lt;health&gt;：当前玩家在位置&lt;position&gt;召唤一个生命值为&lt;health&gt;、攻击力为&lt;attack&gt;的随从。其中&lt;position&gt;是一个 1 到 7 的整数，表示召唤的随从出现在战场上的位置，原来该位置及右边的随从都将顺次向右移动一位; 随从的初始生命值为 1 到 100 的整数，攻击力为 0 到 100 的整数。</span><br><span class="line">　　* attack &lt;attacker&gt; &lt;defender&gt;：当前玩家的角色&lt;attacker&gt;攻击对方的角色 &lt;defender&gt;。&lt;attacker&gt;是 1 到 7 的整数，表示发起攻击的本方随从编号，&lt;defender&gt;是 0 到 7 的整数，表示被攻击的对方角色，0 表示攻击对方英雄，1 到 7 表示攻击对方随从的编号。</span><br><span class="line">　　* end：当前玩家结束本回合。</span><br><span class="line">　　注意：随从的编号会随着游戏的进程发生变化，当召唤一个随从时，玩家指定召唤该随从放入战场的位置，此时，原来该位置及右边的所有随从编号都会增加 1。而当一个随从死亡时，它右边的所有随从编号都会减少 1。任意时刻，战场上的随从总是从1开始连续编号。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　输出共 5 行。</span><br><span class="line">　　第 1 行包含一个整数，表示这 n 次操作后（以下称为 T 时刻）游戏的胜负结果，1 表示先手玩家获胜，-1 表示后手玩家获胜，0 表示游戏尚未结束，还没有人获胜。</span><br><span class="line">　　第 2 行包含一个整数，表示 T 时刻先手玩家的英雄的生命值。</span><br><span class="line">　　第 3 行包含若干个整数，第一个整数 p 表示 T 时刻先手玩家在战场上存活的随从个数，之后 p 个整数，分别表示这些随从在 T 时刻的生命值（按照从左往右的顺序）。</span><br><span class="line">　　第 4 行和第 5 行与第 2 行和第 3 行类似，只是将玩家从先手玩家换为后手玩家。</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">8</span><br><span class="line">summon 1 3 6</span><br><span class="line">summon 2 4 2</span><br><span class="line">end</span><br><span class="line">summon 1 4 5</span><br><span class="line">summon 1 2 1</span><br><span class="line">attack 1 2</span><br><span class="line">end</span><br><span class="line">attack 1 1</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">0</span><br><span class="line">30</span><br><span class="line">1 2</span><br><span class="line">30</span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">Explain: </span><br><span class="line">　　按照样例输入从第 2 行开始逐行的解释如下：</span><br><span class="line">　　1. 先手玩家在位置 1 召唤一个生命值为 6、攻击力为 3 的随从 A，是本方战场上唯一的随从。</span><br><span class="line">　　2. 先手玩家在位置 2 召唤一个生命值为 2、攻击力为 4 的随从 B，出现在随从 A 的右边。</span><br><span class="line">　　3. 先手玩家回合结束。</span><br><span class="line">　　4. 后手玩家在位置 1 召唤一个生命值为 5、攻击力为 4 的随从 C，是本方战场上唯一的随从。</span><br><span class="line">　　5. 后手玩家在位置 1 召唤一个生命值为 1、攻击力为 2 的随从 D，出现在随从 C 的左边。</span><br><span class="line">　　6. 随从 D 攻击随从 B，双方均死亡。</span><br><span class="line">　　7. 后手玩家回合结束。</span><br><span class="line">　　8. 随从 A 攻击随从 C，双方的生命值都降低至 2。</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit262144 kb</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>又是一道长题，长题必坑我。</p><h3 id="Step-1-处理Arguments"><a href="#Step-1-处理Arguments" class="headerlink" title="Step 1  处理Arguments"></a>Step 1  处理Arguments</h3><p>3种指令：<code>summon</code>, <code>attack</code>, <code>end</code>。根据首字母都不同，直接<code>switch(cmder[0])</code>就行，3个<code>case</code>，主函数差不多写完了。(这边的<code>end</code>容易乍一看以为是结束战斗然后输出的意思，然而<code>end</code>并没有调用输出，所以要看中间输出测试自己写的对不对的话，自己再写个<code>case</code>去调用输出就行)</p><h3 id="Step-2-结构构造"><a href="#Step-2-结构构造" class="headerlink" title="Step 2  结构构造"></a>Step 2  结构构造</h3><p>根据题意，关键字<code>HP</code>跟<code>AT</code>，英雄的<code>HP</code>为30，<code>AT</code>为0；随从HP跟AT随机，不用初始化。用结构体储存，同时用二位数组储存英雄+随从，第一维表示开始时的先手玩家，第二维表示开始时的后手玩家。每一维的数组第0位存放英雄，第1至7位存放随从。</p><p>用一个<code>cur</code>变量(取值0或1)表示这一轮轮到谁了，换人时异或1就行。</p><h3 id="Step-3-类的实现"><a href="#Step-3-类的实现" class="headerlink" title="Step 3  类的实现"></a>Step 3  类的实现</h3><p>我本来是用数组写的，可是后面一直<code>WA</code>，我就搞不明白哪里出了问题，后来用了<code>vector</code>重新写了一遍(后来证明并不是数组出现了问题)。这边只说数组实现(因为<code>vector</code>没啥好说的，<code>insert()</code>和<code>erase()</code>直接用就行了)。</p><p><code>summon</code>：位置只可能是1至7，若召唤的位置有随从，则其与后面的全部后移，我用了不断的<code>swap</code>(见代码)，同时标记<code>swap</code>过后最后一个位置为<code>true</code>表示这边有随从。</p><p><code>attack</code>：先攻击，计算血量，双方都会扣血(可以扣0滴血，比如攻击了英雄)，就是说攻击必定反噬。然后判断死亡：若英雄死了，则结束战斗；若随从死了，则这个位置标记false，同时判断后面有没有随从，若有，则不断的<code>swap</code>(见代码)，直至<code>swap</code>的最后没人。</p><p><code>end</code>：换人，就是<code>cur^1</code>，我本来没用的异或，所以写的<code>if()</code>条件句。</p><p><code>Output</code>：根据题意输出。</p><p>随从数目我用<code>sz[2]</code>数组记录(先手玩家，后手玩家)，不记录英雄，每次<code>summon</code>则<code>+1</code>，<code>attack</code>若有随从死了则<code>-1</code>。</p><h3 id="有些坑"><a href="#有些坑" class="headerlink" title="有些坑"></a>有些坑</h3><p>我定义的数组第一维是储存先手/后手玩家，第二位是英雄/随从，结果由于<code>i</code>和<code>1</code>太像了，我在输出的时候把后手玩家的2个维度搞反了，也是不好发现……</p><p>题意问题挺大的。</p><p>“当英雄死亡时，游戏结束”。我就想着写一个判断，若有一方的英雄死了，则直接<code>break</code>，不进行接下来的输入……结果题目设置的意思就是，若有英雄死亡，则最后一次输入一定是英雄死亡的那一回合，设置的刚刚好……</p><p>“攻击发生后，角色的生命值可以为负数”。我手贱的就把英雄的生命值置零了。因为这个，我卡在80分卡了好久，一直没想通哪里<code>WA</code>了……(哪有游戏的最终显示结果是生命为负啊，血条最后都归零了……)<br>多读题多读题多读题。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><h3 id="vector实现"><a href="#vector实现" class="headerlink" title="vector实现"></a><code>vector</code>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">role</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> HP;</span><br><span class="line"><span class="keyword">int</span> AT;</span><br><span class="line">role() &#123; HP = <span class="number">0</span>; AT = <span class="number">0</span>; &#125;</span><br><span class="line">role(<span class="keyword">int</span> hp, <span class="keyword">int</span> att) :HP(hp), AT(att) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hearthstone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;role&gt; hs[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">hearthstone() &#123;</span><br><span class="line">cur = <span class="number">0</span>;</span><br><span class="line"><span class="function">role <span class="title">hero</span><span class="params">(<span class="number">30</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">hs[<span class="number">0</span>].push_back(hero);</span><br><span class="line">hs[<span class="number">1</span>].push_back(hero);</span><br><span class="line">&#125;</span><br><span class="line">~hearthstone() &#123;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">summon</span><span class="params">(<span class="keyword">int</span> pos, role r)</span> </span>&#123;</span><br><span class="line">hs[cur].insert(hs[cur].<span class="built_in">begin</span>() + pos, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">hs[cur][a].HP -= hs[cur ^ <span class="number">1</span>][d].AT;</span><br><span class="line">hs[cur ^ <span class="number">1</span>][d].HP -= hs[cur][a].AT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hs[cur][a].HP &lt;= <span class="number">0</span>)</span><br><span class="line">hs[cur].erase(hs[cur].<span class="built_in">begin</span>() + a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//if (hs[cur ^ 1][d].HP &lt;= 0 &amp;&amp; d == 0)</span></span><br><span class="line"><span class="comment">//hs[cur ^ 1][d].HP = 0;//手贱的置零</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hs[cur ^ <span class="number">1</span>][d].HP &lt;= <span class="number">0</span> &amp;&amp; d != <span class="number">0</span>)</span><br><span class="line">hs[cur ^ <span class="number">1</span>].erase(hs[cur ^ <span class="number">1</span>].<span class="built_in">begin</span>() + d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">curEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cur ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (hs[<span class="number">0</span>][<span class="number">0</span>].HP &lt;= <span class="number">0</span>)</span><br><span class="line">res = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (hs[<span class="number">1</span>][<span class="number">0</span>].HP &lt;= <span class="number">0</span>)</span><br><span class="line">res = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != hs[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hs[<span class="number">0</span>][<span class="number">0</span>].HP &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hs[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; hs[<span class="number">0</span>][i].HP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != hs[<span class="number">1</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hs[<span class="number">1</span>][<span class="number">0</span>].HP &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hs[<span class="number">1</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; hs[<span class="number">1</span>][i].HP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">hearthstone HS;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="built_in">string</span> cmder;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; cmder;</span><br><span class="line"><span class="keyword">switch</span> (cmder[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>: &#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">position</span>, attack, health;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; <span class="built_in">position</span> &gt;&gt; attack &gt;&gt; health;</span><br><span class="line"><span class="function">role <span class="title">sv</span><span class="params">(health, attack)</span></span>;</span><br><span class="line">HS.summon(<span class="built_in">position</span>, sv);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>: &#123;</span><br><span class="line"><span class="keyword">int</span> attacker, defender;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; attacker &gt;&gt; defender;</span><br><span class="line">HS.attack(attacker, defender);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>: &#123;</span><br><span class="line">HS.curEnd();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">HS.output();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">role</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> HP;</span><br><span class="line"><span class="keyword">int</span> AT;</span><br><span class="line">role() &#123; HP = <span class="number">0</span>; AT = <span class="number">0</span>; &#125;</span><br><span class="line">role(<span class="keyword">int</span> hp, <span class="keyword">int</span> att) :HP(hp), AT(att) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hearthstone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> curPlayer;</span><br><span class="line"><span class="keyword">int</span> wPlayer;</span><br><span class="line">role servant[<span class="number">2</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> exist[<span class="number">2</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> sz[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">hearthstone() &#123;</span><br><span class="line"><span class="function">role <span class="title">h</span><span class="params">(<span class="number">30</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">servant[<span class="number">0</span>][<span class="number">0</span>] = h;</span><br><span class="line">servant[<span class="number">1</span>][<span class="number">0</span>] = h;</span><br><span class="line">sz[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">sz[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">curPlayer = <span class="number">0</span>;</span><br><span class="line">wPlayer = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">exist[i][j] = <span class="literal">false</span>;</span><br><span class="line">exist[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">exist[<span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">~hearthstone() &#123;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">summon</span><span class="params">(<span class="keyword">int</span> pos, role sv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ipos = pos;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (exist[curPlayer][i]) &#123;</span><br><span class="line">swap(sv, servant[curPlayer][i]);</span><br><span class="line">ipos++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">servant[curPlayer][ipos] = sv;</span><br><span class="line">exist[curPlayer][ipos] = <span class="literal">true</span>;</span><br><span class="line">sz[curPlayer]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shift</span><span class="params">(<span class="keyword">int</span> playerWho, <span class="keyword">int</span> curPos)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = curPos; i &lt; <span class="number">8</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (exist[playerWho][i + <span class="number">1</span>]) &#123;</span><br><span class="line">swap(exist[playerWho][i], exist[playerWho][i + <span class="number">1</span>]);</span><br><span class="line">swap(servant[playerWho][i], servant[playerWho][i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Attack</span></span><br><span class="line">servant[wPlayer][d].HP -= servant[curPlayer][a].AT;</span><br><span class="line">servant[curPlayer][a].HP -= servant[wPlayer][d].AT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// calculate hero HP, if dead, break</span></span><br><span class="line"><span class="keyword">if</span> (servant[wPlayer][<span class="number">0</span>].HP &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//servant[wPlayer][0].HP = 0;//这个必须删了</span></span><br><span class="line">exist[wPlayer][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// calculate HP, if dead, shift</span></span><br><span class="line"><span class="keyword">if</span> (servant[wPlayer][d].HP &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">exist[wPlayer][d] = <span class="literal">false</span>;</span><br><span class="line">sz[wPlayer]--;</span><br><span class="line"><span class="keyword">if</span> (exist[wPlayer][d + <span class="number">1</span>])</span><br><span class="line">shift(wPlayer, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (servant[curPlayer][a].HP &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">exist[curPlayer][a] = <span class="literal">false</span>;</span><br><span class="line">sz[curPlayer]--;</span><br><span class="line"><span class="keyword">if</span> (exist[curPlayer][a + <span class="number">1</span>])</span><br><span class="line">shift(curPlayer, a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">curEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">swap(curPlayer, wPlayer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">theEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (exist[<span class="number">0</span>][<span class="number">0</span>] == <span class="literal">false</span> || exist[<span class="number">1</span>][<span class="number">0</span>] == <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!exist[<span class="number">0</span>][<span class="number">0</span>] &amp;&amp; exist[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (!exist[<span class="number">1</span>][<span class="number">0</span>] &amp;&amp; exist[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (exist[<span class="number">0</span>][<span class="number">0</span>] &amp;&amp; exist[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (!exist[<span class="number">0</span>][<span class="number">0</span>] &amp;&amp; !exist[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; servant[<span class="number">0</span>][<span class="number">0</span>].HP &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sz[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (exist[<span class="number">0</span>][i])</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; servant[<span class="number">0</span>][i].HP;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; servant[<span class="number">1</span>][<span class="number">0</span>].HP &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sz[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (exist[<span class="number">1</span>][i])</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; servant[<span class="number">1</span>][i].HP;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*void testOutput() &#123;</span></span><br><span class="line"><span class="comment">if (exist[0][0] == false)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "-1" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">if (exist[1][0] == false)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "1" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">if (exist[0][0] &amp;&amp; exist[1][0])</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "0" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cout &lt;&lt; "hero1: " &lt;&lt; servant[0][0].HP &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; sz[0] &lt;&lt; ":";</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt; 8; i++)</span></span><br><span class="line"><span class="comment">if (exist[0][i])</span></span><br><span class="line"><span class="comment">cout &lt;&lt; " (" &lt;&lt; servant[0][i].HP &lt;&lt;", "&lt;&lt; servant[0][i].AT &lt;&lt; ")";</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cout &lt;&lt; "hero2: " &lt;&lt; servant[1][0].HP &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; sz[1] &lt;&lt; ":";</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt; 8; i++)</span></span><br><span class="line"><span class="comment">if (exist[1][i])</span></span><br><span class="line"><span class="comment">cout &lt;&lt; " (" &lt;&lt; servant[1][i].HP &lt;&lt; ", " &lt;&lt; servant[1][i].AT &lt;&lt; ")";</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl &lt;&lt; "----------" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; action;</span><br><span class="line">action[<span class="string">"summon"</span>] = <span class="number">0</span>;</span><br><span class="line">action[<span class="string">"attack"</span>] = <span class="number">1</span>;</span><br><span class="line">action[<span class="string">"end"</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//action["res"] = 3;</span></span><br><span class="line">hearthstone hs;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="comment">//if (hs.theEnd())</span></span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="built_in">string</span> cmder;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; cmder;</span><br><span class="line"><span class="keyword">switch</span> (action[cmder]) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">position</span>, attack, health;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; <span class="built_in">position</span> &gt;&gt; attack &gt;&gt; health;</span><br><span class="line"><span class="function">role <span class="title">sv</span><span class="params">(health, attack)</span></span>;</span><br><span class="line">hs.summon(<span class="built_in">position</span>, sv);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line"><span class="keyword">int</span> attacker, defender;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; attacker &gt;&gt; defender;</span><br><span class="line">hs.attack(attacker, defender);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">hs.curEnd();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*case 3: &#123;</span></span><br><span class="line"><span class="comment">hs.testOutput();</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">hs.output();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;炉石传说-CSP201609-3&quot;&gt;&lt;a href=&quot;#炉石传说-CSP201609-3&quot; class=&quot;headerlink&quot; title=&quot;炉石传说 - CSP201609-3&quot;&gt;&lt;/a&gt;&lt;strong&gt;炉石传说 - CSP201609-3&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;《炉石传说：魔兽英雄传》（Hearthstone: Heroes of Warcraft，简称炉石传说）是暴雪娱乐开发的一款集换式卡牌游戏（如下图所示）。游戏在一个战斗棋盘上进行，由两名玩家轮流进行操作，本题所使用的炉石传说游戏的简化规则如下：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>公园长凳</title>
    <link href="co10.github.io/2020/04/17/%E5%85%AC%E5%9B%AD%E9%95%BF%E5%87%B3/"/>
    <id>co10.github.io/2020/04/17/%E5%85%AC%E5%9B%AD%E9%95%BF%E5%87%B3/</id>
    <published>2020-04-17T03:37:29.000Z</published>
    <updated>2020-04-20T08:29:54.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公园长凳"><a href="#公园长凳" class="headerlink" title="公园长凳"></a><strong>公园长凳</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">公园有 x 条长凳。第 i 个长凳上坐着 ai 个人。这时候又有 y 个人将来到公园，他们将选择坐在某些公园中的长凳上，那么当这 y 个人坐下后，记 k &#x3D; 所有椅子上的人数的最大值，那么 k 可能的最大值 mx 和最小值 mn 分别是多少。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行包含一个整数 x (1 ≤ x ≤ 100) 表示公园中长椅的数目</span><br><span class="line">第二行包含一个整数 y (1 ≤ y ≤ 1000) 表示有 y 个人来到公园</span><br><span class="line">接下来 x 个整数 ai (1 ≤ ai ≤ 100)，表示初始时公园长椅上坐着的人数</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出 mn 和 mx</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">6 13</span><br><span class="line"></span><br><span class="line">Explain:</span><br><span class="line">最初三张椅子的人数分别为 1 6 1</span><br><span class="line">接下来来了 7 个人。</span><br><span class="line">可能出现的情况为 &#123;1, 6, 8&#125;, &#123;1, 7, 7&#125;, …, &#123;8, 6, 1&#125;</span><br><span class="line">相对应的 k 分别为 8, 7, …, 8</span><br><span class="line">其中，状态 &#123;1, 13, 1&#125; 的 k &#x3D; 13，为 mx</span><br><span class="line">状态 &#123;4, 6, 5&#125; 和状态 &#123;5, 6, 4&#125; 的 k &#x3D; 6，为 mn</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit262144 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>咋一看，貌似挺简单，直接对 <em>x</em><sub><em>i</em></sub> 排序，则 mx = <em>x</em><sub>max</sub> + <em>y</em>，mn = <em>x</em><sub>min</sub> + <em>y</em>，太简单了……后来写着写着猛地发现想错了，去看了下样例解释：emm，原来没那么简单。</p><p>不过mx求法挺简单的，就是 mx = <em>x</em><sub>max</sub> + <em>y</em>，mn 麻烦了点而已。</p><p>不难发现，<em>x</em><sub><em>i</em></sub> 排序后可以看作非减的一排柱形图，可以用 <em>y</em> (分割成 <em>n</em> 个部分)对其填充，记 <em>temp</em> = 所有柱子填充成最高柱子所需的量，则有两种情况：<em>y</em> 够分配给 <em>temp<em>；</em>y</em> 不够分配给 <em>temp</em>。如下图所示：</p><p><img src="https://i.loli.net/2020/04/20/B893IjctAs54gdQ.png" alt="bench_001.png"></p><p>对于 <em>y</em> ≤ <em>temp*，则 mn = *x</em><sub>max</sub>；对于 <em>y</em> &gt; <em>temp*，mn = *x</em><sub>max</sub> + ⌈超出部分/<em>x</em>⌉。</p><p>所以这题也不难啊。</p><p>不过<code>WA</code>了一次，原因是我没对<code>差值结果/x</code>取<code>double</code>再取<code>ceil</code>，而是直接<code>int</code>取<code>ceil</code>，相当于没取<code>ceil</code>，没用。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">v.push_back(a);</span><br><span class="line">&#125;</span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">int</span> theMAX = v[v.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> mn, mx;</span><br><span class="line">mx = y + theMAX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); i++)</span><br><span class="line">temp += (theMAX - v[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp &gt;= y)</span><br><span class="line">mn = theMAX;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; y) &#123;</span><br><span class="line"><span class="keyword">int</span> overFlow = y - temp;</span><br><span class="line"><span class="keyword">int</span> incrs = <span class="built_in">ceil</span>((<span class="keyword">double</span>) overFlow / x);</span><br><span class="line">mn = theMAX + incrs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mn &lt;&lt; <span class="string">" "</span> &lt;&lt; mx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;公园长凳&quot;&gt;&lt;a href=&quot;#公园长凳&quot; class=&quot;headerlink&quot; title=&quot;公园长凳&quot;&gt;&lt;/a&gt;&lt;strong&gt;公园长凳&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;公园有 x 条长凳。第 i 个长凳上坐着 ai 个人。这时候又有 y 个人将来到公园，他们将选择坐在某些公园中的长凳上，那么当这 y 个人坐下后，记 k &amp;#x3D; 所有椅子上的人数的最大值，那么 k 可能的最大值 mx 和最小值 mn 分别是多少。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>扑克牌again</title>
    <link href="co10.github.io/2020/04/17/%E6%89%91%E5%85%8B%E7%89%8Cagain/"/>
    <id>co10.github.io/2020/04/17/%E6%89%91%E5%85%8B%E7%89%8Cagain/</id>
    <published>2020-04-17T03:36:22.000Z</published>
    <updated>2020-04-20T07:53:27.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="又打牌"><a href="#又打牌" class="headerlink" title="又打牌"></a><strong>又打牌</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">打牌新规则：</span><br><span class="line">👉所有扑克牌只按数字来算大小，忽略花色。</span><br><span class="line">👉每张扑克牌的大小由一个值表示。A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K 分别指代 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13。</span><br><span class="line">👉每个玩家抽得 5 张扑克牌，组成一手牌。(每种扑克牌的张数是无限的)</span><br></pre></td></tr></table></figure><a id="more"></a><p>一手牌有不同类型，并且有大小之分。<br>比如一手牌 α, β，要么 α &gt; β，要么 α &lt; β，要么 α = β。</p><p>对于不同类型的一手牌，其值的大小即下面的标号；对于同类型的一手牌，根据组成这手牌的 5 张牌不同，其值不同。下面依次列举了这手牌的形成规则：</p><ol><li>大牌：这手牌不符合下面任一个形成规则。如果 <em>α</em> 和 <em>β</em> 都是大牌，那么定义它们的大小为组成这手牌的 5 张牌的大小总和。</li><li>对子：5 张牌中有 2 张牌的值相等。如果 <em>α</em> 和 <em>β</em> 都是对子，比较这个 “对子” 的大小，如果 <em>α</em> 和 <em>β</em> 的 “对子” 大小相等，那么比较剩下 3 张牌的总和。</li><li>两对：5 张牌中有两个不同的对子。如果 <em>α</em> 和 <em>β</em> 都是两对，先比较双方较大的那个对子，如果相等，再比较双方较小的那个对子，如果还相等，只能比较 5 张牌中的最后那张牌组不成对子的牌。</li><li>三个：5 张牌中有 3 张牌的值相等。如果 <em>α</em> 和 <em>β</em> 都是 “三个”，比较这个 “三个” 的大小，如果 <em>α</em> 和 <em>β</em> 的 “三个” 大小相等，那么比较剩下 2 张牌的总和。</li><li>三带二：5 张牌中有 3 张牌的值相等，另外 2 张牌值也相等。如果 α 和 β 都是 “三带二”，先比较它们的 “三个” 的大小，如果相等，再比较 “对子” 的大小。</li><li>炸弹：5 张牌中有 4 张牌的值相等。如果 <em>α</em> 和 <em>β</em> 都是 “炸弹”，比较 “炸弹” 的大小，如果相等，比较剩下那张牌的大小。</li><li>顺子：5 张牌中形成 <em>x</em>, <em>x</em>+1, <em>x</em>+2, <em>x</em>+3, <em>x</em>+4。如果 <em>α</em> 和 <em>β</em> 都是 “顺子”，直接比较两个顺子的最大值。</li><li>龙顺：5 张牌分别为 10、J、Q、K、A。</li></ol><p>要求输出一个排行榜。排行榜按照选手们的 “一手牌” 大小进行排序，如果两个选手的牌相等，那么人名字典序小的排在前面。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入包含多组数据。每组输入开头一个整数 n (1 ≤ n ≤ 100000)，表明全场共多少人。</span><br><span class="line">随后是 n 行，每行一个字符串 s1 和 s2 (1 ≤ |s1|,|s2| ≤ 10)， s1 是对应人的名字，s2 是他手里的牌情况。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每组测试数据，输出 n 行，即这次全场人的排名。</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">3</span><br><span class="line">DongDong AAA109</span><br><span class="line">ZJM 678910</span><br><span class="line">Hrz 678910</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">Hrz</span><br><span class="line">ZJM</span><br><span class="line">DongDong</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit262144 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>又是打牌，又是又臭又长的题干，又是中间麻烦的字符串处理过程……这种题目不算难，就是要反复读题，中间处理过程多检查几遍，不然容易<code>WA</code>。</p><h3 id="分步处理"><a href="#分步处理" class="headerlink" title="分步处理"></a>分步处理</h3><p>长题可以分成多步骤解决，这题的主要步骤就是：</p><ol><li>手牌字符串转整型数组，并排序</li><li>根据题意判断手牌牌型，并记录第 <em>n</em> 关键字(第一关键字是牌型的编号)，存到结构体内</li><li>1 大牌：啥也不是，第二关键字是5张牌的和</li><li>2 对子：2等3不等，第二关键字是这个”2”，第三关键字是这个3张牌的和</li><li>3 两对：2等+2等+1，第二关键字是大的”2”，第三关键字是较小的”2”，第四关键字是这个”1”</li><li>4 三个：3等2不等，第二关键字是这个”3”，第三关键字是这个2张牌的和</li><li>5 三带二：3等+2等，第二关键字是这个”3”，第三关键字是这个”2”</li><li>6 炸弹：4等+1，第二关键字是这个”4”，第三关键字是这个”1”</li><li>7 顺子：形如”1 2 3 4 5””A B C D E”，第二关键字是这个”5”(“E”)</li><li>8 龙顺：手牌为10、J、Q、K、A，即数组<code>[1, 10, 11, 12, 13]</code></li><li>将所有人的手牌排序，输出人名</li></ol><h3 id="逐个攻破"><a href="#逐个攻破" class="headerlink" title="逐个攻破"></a>逐个攻破</h3><p>整体思路清晰后，就一一实现：</p><p><code>String</code>转<code>int Array[]</code>：对于10特殊处理，扫到 ‘10’ 的 ‘1’ 就存入10，对于 ‘10’ 的 ‘0’ 不做处理，因为扫不到其它的 1 (A、J、Q、K)。</p><p>判断牌型：用一个<code>int sameCnt</code>记录相同牌有几张(用 <em>a</em><sub><em>i</em></sub> 跟 <em>a</em><sub><em>i</em>+1</sub> 对比，所以<code>sameCnt = 各组相同张数和 - 1</code>)，并用一个<code>vector&lt;int&gt;</code>存放相同牌，然后可依此大致分为3大组：</p><table><thead><tr><th align="center">Type</th><th align="center">Sample</th><th align="center">sameCnt</th><th align="center">vector</th></tr></thead><tbody><tr><td align="center">对子</td><td align="center"><code>[[A A] B C D]</code><br><code>[B [A A] C D]</code><br><code>[B C [A A] D]</code><br><code>[B C D [A A]]</code></td><td align="center">1</td><td align="center"><code>[A]</code></td></tr><tr><td align="center">两对</td><td align="center"><code>[[A A] [B B] C]</code><br><code>[[A A] C [B B]]</code><br><code>[C [A A] [B B]]</code></td><td align="center">2</td><td align="center"><code>[A, B]</code></td></tr><tr><td align="center">三个</td><td align="center"><code>[[A A A] B C]</code><br><code>[B [A A A] C]</code><br><code>[B C [A A A]]</code></td><td align="center">2</td><td align="center"><code>[A, A]</code></td></tr><tr><td align="center">三带二</td><td align="center"><code>[[A A A] [B B]]</code><br><code>[[B B] [A A A]]</code></td><td align="center">3</td><td align="center"><code>[A, A, B]</code><br><code>[B, A, A]</code></td></tr><tr><td align="center">炸弹</td><td align="center"><code>[[A A A A] B]</code><br><code>[B [A A A A]]</code></td><td align="center">3</td><td align="center"><code>[A, A, A]</code></td></tr><tr><td align="center">顺子</td><td align="center"><code>[x, x+1, x+2, x+3, x+4]</code></td><td align="center">0</td><td align="center">EMPTY</td></tr><tr><td align="center">龙顺</td><td align="center"><code>[1, 10, 11, 12, 13]</code></td><td align="center">0</td><td align="center">EMPTY</td></tr><tr><td align="center">大牌</td><td align="center"><code>[A B C D E]</code></td><td align="center">0</td><td align="center">EMPTY</td></tr></tbody></table><p>每个大组里根据<code>vector</code>就可以把牌型再细分出来了，同时记录第 <em>n</em> 关键字。(详见代码)</p><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>自己随便出几组数据测试没啥问题，不过提交还是<code>WA</code>了，所以仔细再读了题目，发觉也没漏了啥条件，再反复看看了代码，利用中间输出，测试是哪一大步出错了？测了测也没啥错误啊……</p><p>找了好久才发现判断大牌的<code>for</code>循坏条件把<code>i &lt; 5</code>写成<code>i &lt; 4</code>……因为前面算<code>sameCnt</code>的时候条件是<code>i &lt; 4</code>，我貌似直接 copy-paste 了……</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poker</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> theLevel;</span><br><span class="line"><span class="keyword">int</span> firstKey, secondKey, thirdKey;</span><br><span class="line">poker(<span class="built_in">string</span> na, <span class="keyword">int</span> lvl, <span class="keyword">int</span> fK, <span class="keyword">int</span> sK, <span class="keyword">int</span> tK): name(na),</span><br><span class="line">theLevel(lvl), firstKey(fK), secondKey(sK), thirdKey(tK) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">poker <span class="title">level</span><span class="params">(<span class="built_in">string</span> name, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sameCnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[i] == p[i + <span class="number">1</span>]) &#123;</span><br><span class="line">sameCnt++;</span><br><span class="line">v.push_back(p[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 2 of 5 is equal</span></span><br><span class="line"><span class="keyword">if</span> (sameCnt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> firstKey = v.at(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> secondKey = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i] != firstKey)</span><br><span class="line">secondKey += p[i];</span><br><span class="line"><span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">2</span>, firstKey, secondKey, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> po;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sameCnt == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// (3) 2 and 2 of 5 each is equal</span></span><br><span class="line"><span class="keyword">if</span> (v.at(<span class="number">0</span>) != v.at(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> firstKey = v.at(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> secondKey = v.at(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> thirdKey = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i] != firstKey &amp;&amp; p[i] != secondKey)</span><br><span class="line">thirdKey = p[i];</span><br><span class="line"><span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">3</span>, firstKey, secondKey, thirdKey)</span></span>;</span><br><span class="line"><span class="keyword">return</span> po;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 3 of 5 is equal</span></span><br><span class="line"><span class="keyword">if</span> (v.at(<span class="number">0</span>) == v.at(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> firstKey = v.at(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> secondKey = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i] != firstKey)</span><br><span class="line">secondKey += p[i];</span><br><span class="line"><span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">4</span>, firstKey, secondKey, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> po;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sameCnt == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">// (5) 3 of 5 &amp; 2 of 5</span></span><br><span class="line"><span class="keyword">if</span> (v.at(<span class="number">0</span>) != v.at(<span class="number">2</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> firstKey = v.at(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> secondKey = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (v.at(<span class="number">0</span>) != v.at(<span class="number">1</span>))</span><br><span class="line">secondKey = v.at(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (v.at(<span class="number">0</span>) == v.at(<span class="number">1</span>))</span><br><span class="line">secondKey = v.at(<span class="number">2</span>);</span><br><span class="line"><span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">5</span>, firstKey, secondKey, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> po;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6) 4 of 5 is equal</span></span><br><span class="line"><span class="keyword">if</span> (v.at(<span class="number">0</span>) == v.at(<span class="number">2</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> firstKey = v.at(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> secondKey = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">0</span>] == firstKey)</span><br><span class="line">secondKey = p[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">0</span>] != firstKey)</span><br><span class="line">secondKey = p[<span class="number">0</span>];</span><br><span class="line"><span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">6</span>, firstKey, secondKey, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> po;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sameCnt == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// (7) shunza</span></span><br><span class="line"><span class="keyword">if</span> ((p[<span class="number">0</span>] + <span class="number">1</span> == p[<span class="number">1</span>]) &amp;&amp; (p[<span class="number">1</span>] + <span class="number">1</span> == p[<span class="number">2</span>]) &amp;&amp;</span><br><span class="line">(p[<span class="number">2</span>] + <span class="number">1</span> == p[<span class="number">3</span>]) &amp;&amp; (p[<span class="number">3</span>] + <span class="number">1</span> == p[<span class="number">4</span>])) &#123;</span><br><span class="line"><span class="keyword">int</span> firstKey = p[<span class="number">4</span>];</span><br><span class="line"><span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">7</span>, firstKey, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> po;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (8) 10, J, Q, K, A</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="number">10</span> &amp;&amp; p[<span class="number">2</span>] == <span class="number">11</span></span><br><span class="line">&amp;&amp; p[<span class="number">3</span>] == <span class="number">12</span> &amp;&amp; p[<span class="number">4</span>] == <span class="number">13</span>) &#123;</span><br><span class="line">poker po(name, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> po;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) none of above</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> firstKey = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">firstKey += p[i];</span><br><span class="line"><span class="function">poker <span class="title">po</span><span class="params">(name, <span class="number">1</span>, firstKey, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> po;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; poke;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; pMap;</span><br><span class="line">pMap[<span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">50</span>; i &lt;= <span class="number">57</span>; i++)</span><br><span class="line">pMap[i] = i - <span class="number">48</span>;</span><br><span class="line">pMap[<span class="string">'1'</span>] = <span class="number">10</span>;</span><br><span class="line">pMap[<span class="string">'J'</span>] = <span class="number">11</span>;</span><br><span class="line">pMap[<span class="string">'Q'</span>] = <span class="number">12</span>;</span><br><span class="line">pMap[<span class="string">'K'</span>] = <span class="number">13</span>;</span><br><span class="line">pMap[<span class="string">'0'</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> res = pMap[s[i]];</span><br><span class="line"><span class="keyword">if</span> (res != <span class="number">0</span>)</span><br><span class="line">poke.push_back(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(poke.<span class="built_in">begin</span>(), poke.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> poke;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> poker&amp; p1, <span class="keyword">const</span> poker&amp; p2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p1.theLevel == p2.theLevel) &#123;</span><br><span class="line"><span class="keyword">if</span> (p1.firstKey == p2.firstKey) &#123;</span><br><span class="line"><span class="keyword">if</span> (p1.secondKey == p2.secondKey) &#123;</span><br><span class="line"><span class="keyword">if</span> (p1.thirdKey == p2.thirdKey) &#123;</span><br><span class="line"><span class="keyword">return</span> p1.name.compare(p2.name) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p1.thirdKey &gt; p2.thirdKey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p1.secondKey &gt; p2.secondKey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p1.firstKey &gt; p2.firstKey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p1.theLevel &gt; p2.theLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (!(<span class="built_in">cin</span> &gt;&gt; n).eof()) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;poker&gt; v;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="built_in">string</span> s1, s2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p = convert(s2);</span><br><span class="line">poker po = level(s1, p);</span><br><span class="line">v.push_back(po);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[i].name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;又打牌&quot;&gt;&lt;a href=&quot;#又打牌&quot; class=&quot;headerlink&quot; title=&quot;又打牌&quot;&gt;&lt;/a&gt;&lt;strong&gt;又打牌&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;打牌新规则：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;👉所有扑克牌只按数字来算大小，忽略花色。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;👉每张扑克牌的大小由一个值表示。A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K 分别指代 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;👉每个玩家抽得 5 张扑克牌，组成一手牌。(每种扑克牌的张数是无限的)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>目录管理器</title>
    <link href="co10.github.io/2020/04/17/%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>co10.github.io/2020/04/17/%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E5%99%A8/</id>
    <published>2020-04-17T03:32:52.000Z</published>
    <updated>2020-04-20T09:49:15.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录管理器"><a href="#目录管理器" class="headerlink" title="目录管理器"></a><strong>目录管理器</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">写一个目录管理器。</span><br><span class="line">初始时，硬盘是空的，命令行的当前目录为根目录 root。</span><br><span class="line">目录管理器可以理解为要维护一棵有根树结构，每个目录的儿子必须保持字典序。</span><br></pre></td></tr></table></figure><a id="more"></a><table><thead><tr><th>命令</th><th align="center">类型</th><th>实现</th><th>说明</th></tr></thead><tbody><tr><td><code>MKDIR s</code></td><td align="center">操作</td><td>在当前目录下创建一个子目录 <em>s</em>，<em>s</em> 是一个字符串</td><td>创建成功输出 “<code>OK</code>“；若当前目录下已有该子目录则输出 “<code>ERR</code>“</td></tr><tr><td><code>RM s</code></td><td align="center">操作</td><td>在当前目录下删除子目录 <em>s</em>，<em>s</em> 是一个字符串</td><td>删除成功输出 “<code>OK</code>“；若当前目录下该子目录不存在则输出 “<code>ERR</code>“</td></tr><tr><td><code>CD s</code></td><td align="center">操作</td><td>进入一个子目录 <em>s</em>，<em>s</em> 是一个字符串(执行后，当前目录可能会改变)</td><td>进入成功输出 “<code>OK</code>“；若当前目录下该子目录不存在则输出 “<code>ERR</code>“<br>特殊地，若 <em>s</em> 等于 “<code>..</code>“ 则表示返回上级目录，同理，返回成功输出 “<code>OK</code>“，返回失败（当前目录已是根目录没有上级目录）则输出 “<code>ERR</code>“</td></tr><tr><td><code>SZ</code></td><td align="center">询问</td><td>输出当前目录的大小</td><td>也即输出 <code>1+当前目录的子目录数</code></td></tr><tr><td><code>LS</code></td><td align="center">询问</td><td>输出多行表示当前目录的 “直接子目录” 名</td><td>若没有子目录，则输出 “<code>EMPTY</code>“；若<code>子目录数</code>∈ [1,10] 则全部输出；若<code>子目录数</code>大于 10，则输出前 5 个，再输出一行 “<code>...</code>“，输出后 5 个。</td></tr><tr><td><code>TREE</code></td><td align="center">询问</td><td>输出多行表示以当前目录为根的子树的前序遍历结果</td><td>若没有后代目录，则输出 “<code>EMPTY</code>“；若 <code>后代目录数+1 (当前目录)</code> ∈ [1,10] 则全部输出；若<code>后代目录数+1 (当前目录)</code> 大于 10，则输出前 5 个，再输出一行 “<code>...</code>“，输出后 5 个。若目录结构如<code>图1</code>，当前目录为 “<code>root</code>“ 执行结果如<code>图2</code></td></tr><tr><td><code>UNDO</code></td><td align="center">特殊</td><td>撤销操作</td><td>撤销最近一个 “成功执行” 的操作（即成功的<code>MKDIR</code>或<code>RM</code>或<code>CD</code>）的影响，撤销成功输出 “<code>OK</code>“ , 没有操作用于撤销则输出 “<code>ERR</code>“</td></tr></tbody></table><p><img src="https://i.loli.net/2020/04/17/vehRy68qGgoIu9a.png" alt="directory_manager_01.png"></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入文件包含多组测试数据，第一行输入一个整数表示测试数据的组数 T (T ≤ 20)；</span><br><span class="line">每组测试数据的第一行输入一个整数表示该组测试数据的命令总数 Q (Q ≤ 1e5)；</span><br><span class="line">每组测试数据的 2 ~ Q+1 行为具体的操作(MKDIR、RM 操作总数不超过 5000)；</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每组测试数据的输出结果间需要输出一行空行。注意大小写。</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">1</span><br><span class="line">22</span><br><span class="line">MKDIR dira</span><br><span class="line">CD dirb</span><br><span class="line">CD dira</span><br><span class="line">MKDIR a</span><br><span class="line">MKDIR b</span><br><span class="line">MKDIR c</span><br><span class="line">CD ..</span><br><span class="line">MKDIR dirb</span><br><span class="line">CD dirb</span><br><span class="line">MKDIR x</span><br><span class="line">CD ..</span><br><span class="line">MKDIR dirc</span><br><span class="line">CD dirc</span><br><span class="line">MKDIR y</span><br><span class="line">CD ..</span><br><span class="line">SZ</span><br><span class="line">LS</span><br><span class="line">TREE</span><br><span class="line">RM dira</span><br><span class="line">TREE</span><br><span class="line">UNDO</span><br><span class="line">TREE</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">OK</span><br><span class="line">ERR</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">9</span><br><span class="line">dira</span><br><span class="line">dirb</span><br><span class="line">dirc</span><br><span class="line">root</span><br><span class="line">dira</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">dirb</span><br><span class="line">x</span><br><span class="line">dirc</span><br><span class="line">y</span><br><span class="line">OK</span><br><span class="line">root</span><br><span class="line">dirb</span><br><span class="line">x</span><br><span class="line">dirc</span><br><span class="line">y</span><br><span class="line">OK</span><br><span class="line">root</span><br><span class="line">dira</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">dirb</span><br><span class="line">x</span><br><span class="line">dirc</span><br><span class="line">y</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit6000 ms</span><br><span class="line">Memory limit1048576 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>挺复杂的，分步骤操作。</p><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>先考虑输入，输入主要是操作跟操作的路径，所以用<code>map</code>标记输入的是什么操作，共 7 个<code>case</code>。</p><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>接下来就是7个功能的实现了，可以先把大体框图<code>class</code>写出来，具体怎么实现先丢在一边。</p><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>然后是考虑怎么实现这棵目录树的问题。仔细读题，它得有返回上一级的功能，所以结构体内得存有指针指向其父节点；还得输出当前目录大小，所以结构体内得有一个<code>size</code>记录当前目录大小。<br>但是问题又来了，一个目录下有多个文件夹，每个文件夹下又有多个文件夹，所以<code>size</code>不应该只记录当前文件夹下文件夹的个数，还得算入所有子文件夹的个数，所以可以用一个函数维持这个<code>size</code>，从变更的孩子节点开始，每次往上一级变更<code>size</code>，直到<code>root</code>。<br>文件目录是英文单词，得用<code>map</code>对其标记(同时也Alphabetically sorted)，将这些指向孩子的指针储存起来。</p><h3 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h3><p>最后就是实现这7大功能了。</p><p>类里面放个指针指向根目录，再放个指针指向当前所在文件夹的目录。</p><p><code>MKDIR s</code>：新建节点直接插入，同时维护<code>size</code>(+1)，返回<code>true</code>/<code>false</code>。</p><p><code>RM s</code>：找到当前路径是否存在该文件夹，存在则删除指针，同时维护<code>size</code>(- 1 × 删除的大小)，返回<code>true</code>/<code>false</code>。</p><p><code>CD s</code>：找到当前路径是否存在该文件夹，存在则改变当前目录的指针，指向这，返回<code>true</code>/<code>false</code>。</p><p><code>SZ</code>：因为有储存了，直接输出就好了。</p><p><code>LS</code>：遍历当前目录的直接子目录，直接根据题意输出就好了。</p><p><code>TREE</code>：前序遍历，结果用<code>vector</code>储存，根据题意输出。</p><p><code>UNDO</code>：中文题意可能有歧义，直接看英文题意：只有成功的<code>MKDIR</code>、<code>RM</code>、<code>CD</code>才可以撤销；可多次撤销；没得再撤销了就<code>ERR</code>了。<br>可以用一个栈(<code>stack&lt;pair&lt;操作, 操作用于的指针&gt;&gt;</code>)储存每次成功的<code>MKDIR</code>、<code>RM</code>和<code>CD</code>，每次撤销取栈顶，撤销<code>MKDIR</code>就<code>RM</code>之，撤销<code>RM</code>就<code>MKDIR</code>之(必须用指针, 不可直接新建目录，否则子文件夹全部丢失)，撤销<code>CD</code>就进入储存的<code>CD</code>地址。</p><h3 id="Step-5-细节处理"><a href="#Step-5-细节处理" class="headerlink" title="Step 5  细节处理"></a>Step 5  细节处理</h3><p>跑一下，<code>TLE</code>了……原因是一直<code>TREE</code>操作太耗时，太多次就超时了。</p><p>可以采用懒更新的方式，因为它每次<code>TREE</code>的结果可能是相同的，可以用一个<code>bool updated</code>记录当前是否更新了树，即若操作是成功的<code>MKDIR</code>/<code>RM</code>/<code>CD</code>/<code>UNDO</code>，则需要重新遍历，每次遍历完之后，将<code>updated</code>置于<code>false</code>。减少了遍历的次数，耗时也就降下来了。</p><h3 id="再再再后来……"><a href="#再再再后来……" class="headerlink" title="再再再后来……"></a>再再再后来……</h3><p>之后就面临的<code>WA</code>的疯狂调试……(好难纠错啊)</p><p>先是解决了上面提到的撤回<code>RM</code>操作不能直接<code>MKDIR</code>新目录的问题，然后是若第一个指令是<code>TREE</code>但前序序列是空的(没加入<code>root</code>), 因此输出<code>&#39;EMPTY&#39;</code>时判断条件(前序序列的<code>size</code> = 1)会出错。</p><p>还有就是若当前目录与其子目录中某个文件夹同名，<code>RM</code>会有很大的问题，因为我本来是写了个<code>find()</code>函数，从当前目录开始，不断向子目录找同名文件夹，<code>RM</code>直接调用的<code>find()</code>，因为刚开始读题的时候我脑子里是认为把所有子目录都算进去了……</p><p>还有个<code>WA</code>找了好久……反复读题后，发现<code>CD</code>是进入当前子目录，我又调用<code>find()</code>函数了……(自己随手写了个<code>find()</code>函数把自己坑了好几次😵，最终<code>AC</code>的结果就是<code>find()</code>完全用不上🤧)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>认真读题，反复读题！若有英文原题，建议先看英文题面！</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt; children;</span><br><span class="line">node* parent;</span><br><span class="line"><span class="keyword">int</span> sz;</span><br><span class="line">node() &#123; name = <span class="string">""</span>; parent = <span class="literal">NULL</span>; sz = <span class="number">0</span>; &#125;</span><br><span class="line">node(<span class="built_in">string</span> nm, node* par) :name(nm), parent(par) &#123; sz = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">directory</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">node* root;</span><br><span class="line">node* cur;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; posOrder;</span><br><span class="line"><span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, node*&gt;&gt; opeS;</span><br><span class="line"><span class="keyword">bool</span> updated;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">directory() &#123; root = <span class="keyword">new</span> node(<span class="string">"root"</span>, <span class="literal">NULL</span>); cur = root; updated = <span class="literal">false</span>; &#125;</span><br><span class="line">~directory() &#123; <span class="comment">/*clear();*/</span> &#125;</span><br><span class="line"><span class="function">node* <span class="title">find</span><span class="params">(node* curr, <span class="built_in">string</span> idx)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">q.push(curr);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">node* p = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (p-&gt;name == idx)</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = p-&gt;children.<span class="built_in">begin</span>();</span><br><span class="line">it != p-&gt;children.<span class="built_in">end</span>(); ++it)</span><br><span class="line">q.push(it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(node* curr, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">curr-&gt;sz += delta;</span><br><span class="line"><span class="keyword">if</span> (curr != root)</span><br><span class="line"><span class="built_in">maintain</span>(curr-&gt;parent, delta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> sub)</span> </span>&#123;</span><br><span class="line">node* par = cur;</span><br><span class="line"><span class="keyword">if</span> (par-&gt;children.<span class="built_in">find</span>(sub) != par-&gt;children.<span class="built_in">end</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">node* child = <span class="keyword">new</span> node(sub, par);</span><br><span class="line">par-&gt;children.insert(make_pair(sub, child));</span><br><span class="line"></span><br><span class="line"><span class="built_in">maintain</span>(cur, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">opeS.push(make_pair(<span class="number">0</span>, child));</span><br><span class="line">updated = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="built_in">string</span> sub)</span> </span>&#123;</span><br><span class="line">node* par = cur;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = par-&gt;children.<span class="built_in">find</span>(sub);</span><br><span class="line"><span class="keyword">if</span> (it == par-&gt;children.<span class="built_in">end</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">node* child = par-&gt;children[sub];</span><br><span class="line"></span><br><span class="line">par-&gt;children.erase(it);</span><br><span class="line"></span><br><span class="line"><span class="built_in">maintain</span>(cur, <span class="number">-1</span> * child-&gt;sz);</span><br><span class="line"></span><br><span class="line">opeS.push(make_pair(<span class="number">1</span>, child));</span><br><span class="line">updated = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">enter</span><span class="params">(<span class="built_in">string</span> sub)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sub == <span class="string">".."</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur == root)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">opeS.push(make_pair(<span class="number">2</span>, cur));</span><br><span class="line">cur = cur-&gt;parent;</span><br><span class="line">updated = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = cur-&gt;children.<span class="built_in">find</span>(sub);</span><br><span class="line"><span class="keyword">if</span> (it == cur-&gt;children.<span class="built_in">end</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">opeS.push(make_pair(<span class="number">2</span>, cur));</span><br><span class="line">cur = it-&gt;second;</span><br><span class="line">updated = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">curSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cur-&gt;sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">currOutput</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> theSize = cur-&gt;children.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (theSize == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"EMPTY"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (theSize &gt;= <span class="number">1</span> &amp;&amp; theSize &lt;= <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = cur-&gt;children.<span class="built_in">begin</span>();</span><br><span class="line">it != cur-&gt;children.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (theSize &gt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = cur-&gt;children.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator itt = cur-&gt;children.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">itt--;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; itt-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">itt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">posTra</span><span class="params">(node* curr)</span> </span>&#123;</span><br><span class="line">posOrder.push_back(curr-&gt;name);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = curr-&gt;children.<span class="built_in">begin</span>();</span><br><span class="line">it != curr-&gt;children.<span class="built_in">end</span>(); ++it)</span><br><span class="line">posTra(it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (updated || posOrder.empty()) &#123;</span><br><span class="line">posOrder.<span class="built_in">clear</span>();</span><br><span class="line">posTra(cur);</span><br><span class="line">&#125;</span><br><span class="line">updated = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> theSize = posOrder.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (theSize == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"EMPTY"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (theSize &gt; <span class="number">1</span> &amp;&amp; theSize &lt;= <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != theSize; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; posOrder[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (theSize &gt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; posOrder[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = theSize - <span class="number">5</span>; i != theSize; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; posOrder[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (opeS.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">updated = <span class="literal">true</span>;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, node*&gt; pS = opeS.top();</span><br><span class="line">opeS.pop();</span><br><span class="line"><span class="keyword">if</span> (pS.first == <span class="number">0</span>) &#123;</span><br><span class="line">node* dest = pS.second;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, node*&gt;::iterator it = cur-&gt;children.<span class="built_in">find</span>(dest-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (it == cur-&gt;children.<span class="built_in">end</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">cur-&gt;children.erase(it);</span><br><span class="line"></span><br><span class="line"><span class="built_in">maintain</span>(cur, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pS.first == <span class="number">1</span>) &#123;</span><br><span class="line">node* dest = pS.second;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;children.<span class="built_in">find</span>(dest-&gt;name) != cur-&gt;children.<span class="built_in">end</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">cur-&gt;children.insert(make_pair(dest-&gt;name, dest));</span><br><span class="line"></span><br><span class="line"><span class="built_in">maintain</span>(cur, dest-&gt;sz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pS.first == <span class="number">2</span>) &#123;</span><br><span class="line">cur = pS.second;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">node* p0 = cur;</span><br><span class="line"><span class="keyword">delete</span> p0;</span><br><span class="line">node* p1 = root;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line">cur = <span class="literal">NULL</span>;</span><br><span class="line">posOrder.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">while</span> (!opeS.empty())</span><br><span class="line">opeS.pop();</span><br><span class="line">p0 = <span class="literal">NULL</span>;</span><br><span class="line">p1 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; Cmap;</span><br><span class="line">Cmap[<span class="string">"MKDIR"</span>] = <span class="number">0</span>;</span><br><span class="line">Cmap[<span class="string">"RM"</span>] = <span class="number">1</span>;</span><br><span class="line">Cmap[<span class="string">"CD"</span>] = <span class="number">2</span>;</span><br><span class="line">Cmap[<span class="string">"SZ"</span>] = <span class="number">3</span>;</span><br><span class="line">Cmap[<span class="string">"LS"</span>] = <span class="number">4</span>;</span><br><span class="line">Cmap[<span class="string">"TREE"</span>] = <span class="number">5</span>;</span><br><span class="line">Cmap[<span class="string">"UNDO"</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"><span class="keyword">int</span> forEmptyOutput = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">if</span> (forEmptyOutput &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> Q;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">directory D;</span><br><span class="line"><span class="keyword">while</span> (Q--) &#123;</span><br><span class="line"><span class="built_in">string</span> cmder;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; cmder;</span><br><span class="line"><span class="keyword">switch</span> (Cmap[cmder]) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: &#123; <span class="comment">// make sub directory</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="keyword">bool</span> result = D.insert(s);</span><br><span class="line"><span class="keyword">if</span> (result)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"OK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (!result)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ERR"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: &#123; <span class="comment">// delete sub directory</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="keyword">bool</span> result = D.<span class="built_in">remove</span>(s);</span><br><span class="line"><span class="keyword">if</span> (result)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"OK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (!result)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ERR"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: &#123; <span class="comment">// enter sub directory s</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="keyword">bool</span> result = D.enter(s);</span><br><span class="line"><span class="keyword">if</span> (result)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"OK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (!result)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ERR"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: &#123; <span class="comment">// output temporary size</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; D.curSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: &#123; <span class="comment">// output direct sub directory names</span></span><br><span class="line">D.currOutput();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: &#123; <span class="comment">// posTraversal</span></span><br><span class="line">D.output();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: &#123; <span class="comment">// undo MKDIR/RM/CD</span></span><br><span class="line"><span class="keyword">bool</span> result = D.undo();</span><br><span class="line"><span class="keyword">if</span> (result)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"OK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (!result)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ERR"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">forEmptyOutput++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原题链接🔗"><a href="#原题链接🔗" class="headerlink" title="原题链接🔗"></a><strong>原题链接🔗</strong></h2><p><a href="https://icpcarchive.ecs.baylor.edu/external/78/7843.pdf" target="_blank" rel="noopener">https://icpcarchive.ecs.baylor.edu/external/78/7843.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录管理器&quot;&gt;&lt;a href=&quot;#目录管理器&quot; class=&quot;headerlink&quot; title=&quot;目录管理器&quot;&gt;&lt;/a&gt;&lt;strong&gt;目录管理器&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;写一个目录管理器。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;初始时，硬盘是空的，命令行的当前目录为根目录 root。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;目录管理器可以理解为要维护一棵有根树结构，每个目录的儿子必须保持字典序。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="树" scheme="co10.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>班长竞选</title>
    <link href="co10.github.io/2020/04/17/%E7%8F%AD%E9%95%BF%E7%AB%9E%E9%80%89/"/>
    <id>co10.github.io/2020/04/17/%E7%8F%AD%E9%95%BF%E7%AB%9E%E9%80%89/</id>
    <published>2020-04-17T03:04:44.000Z</published>
    <updated>2020-04-20T06:48:00.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="班长竞选"><a href="#班长竞选" class="headerlink" title="班长竞选"></a><strong>班长竞选</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大学班级选班长，N 个同学均可以发表意见，若意见为 A B，则表示 A 认为 B 合适。意见具有传递性，即 A 认为 B 合适，B 认为 C 合适，则 A 也认为 C 合适。共有 M 条意见，求最高票数，并给出一份候选人名单，即所有得票最多的同学。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本题有多组数据。第一行 T 表示数据组数。每组数据开始有两个整数 N 和 M (2 ≤ n ≤ 5000, 0 &lt; m ≤ 30000)，接下来有 M 行包含两个整数 A 和 B (A ≠ B) 表示 A 认为 B 合适。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每组数据，第一行输出&quot;Case x: &quot;，x 表示数据的编号，从1开始，紧跟着是最高的票数。 接下来一行输出得票最多的同学的编号，用空格隔开，不忽略行末空格！</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">2</span><br><span class="line">4 3</span><br><span class="line">3 2</span><br><span class="line">2 0</span><br><span class="line">2 1</span><br><span class="line">3 3</span><br><span class="line">1 0</span><br><span class="line">2 1</span><br><span class="line">0 2</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">Case 1: 2</span><br><span class="line">0 1</span><br><span class="line">Case 2: 2</span><br><span class="line">0 1 2</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit2000 ms</span><br><span class="line">Memory limit32768 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>这题题目短，题意清晰，输入输出简单明了，但实现起来挺复杂的。</p><h3 id="强连通分量-Strongly-Connected-Component-SCC"><a href="#强连通分量-Strongly-Connected-Component-SCC" class="headerlink" title="强连通分量 (Strongly Connected Component, SCC)"></a>强连通分量 (Strongly Connected Component, SCC)</h3><p>有向图中，尽可能多的若干顶点组成的子图中，这些顶点都是相互可到达的，则这些顶点成为一个强连通分量。</p><p><img src="https://i.loli.net/2020/04/20/bG9QVDgWOsL5aSd.png" alt="SCC.png"></p><p>如上图所示，有3个强连通分量，分别是<code>{A, B, C}</code>, <code>{D, E, H}</code>, <code>{F, G}</code>。</p><h3 id="DFS序"><a href="#DFS序" class="headerlink" title="DFS序"></a>DFS序</h3><p>前序：第一次到达点 <em>x</em> 的次序，用<code>d[x]</code>表示<br>后序：<em>x</em> 点遍历完成的次序，即回溯时间，用 <code>f[x]</code> 表示<br>逆后序：后序序列的逆序</p><p>以上图为例，用DFS遍历：</p><table><thead><tr><th align="center">Edge</th><th align="center">Current Node</th><th align="center">Note</th></tr></thead><tbody><tr><td align="center">-</td><td align="center"><code>A</code></td><td align="center"><code>d[A] = 1</code></td></tr><tr><td align="center"><code>A → B</code></td><td align="center"><code>B</code></td><td align="center"><code>d[B] = 2</code></td></tr><tr><td align="center"><code>B → C</code></td><td align="center"><code>C</code></td><td align="center"><code>d[C] = 3</code></td></tr><tr><td align="center"><code>C → A</code></td><td align="center"><code>C</code></td><td align="center">Reached</td></tr><tr><td align="center"><code>C → H</code></td><td align="center"><code>H</code></td><td align="center"><code>d[H] = 4</code></td></tr><tr><td align="center"><code>H → E</code></td><td align="center"><code>E</code></td><td align="center"><code>d[E] = 5</code></td></tr><tr><td align="center"><code>E → D</code></td><td align="center"><code>D</code></td><td align="center"><code>d[D] = 6</code></td></tr><tr><td align="center"><code>D → E</code></td><td align="center"><code>D</code></td><td align="center">Reached</td></tr><tr><td align="center"><code>D → F</code></td><td align="center"><code>F</code></td><td align="center"><code>d[F] = 7</code></td></tr><tr><td align="center"><code>F → G</code></td><td align="center"><code>G</code></td><td align="center"><code>d[G] = 8</code></td></tr><tr><td align="center"><code>G → F</code></td><td align="center"><code>G</code></td><td align="center">Reached</td></tr><tr><td align="center"><code>G</code>遍历结束</td><td align="center"><code>G</code></td><td align="center"><code>f[G] = 1</code></td></tr><tr><td align="center"><code>F</code>遍历结束</td><td align="center"><code>F</code></td><td align="center"><code>f[F] = 2</code></td></tr><tr><td align="center"><code>D</code>遍历结束</td><td align="center"><code>D</code></td><td align="center"><code>f[D] = 3</code></td></tr><tr><td align="center"><code>E → G</code></td><td align="center"><code>E</code></td><td align="center">Reached</td></tr><tr><td align="center"><code>E → H</code></td><td align="center"><code>E</code></td><td align="center">Reached</td></tr><tr><td align="center"><code>E</code>遍历结束</td><td align="center"><code>E</code></td><td align="center"><code>f[E] = 4</code></td></tr><tr><td align="center"><code>H</code>遍历结束</td><td align="center"><code>H</code></td><td align="center"><code>f[H] = 5</code></td></tr><tr><td align="center"><code>C</code>遍历结束</td><td align="center"><code>C</code></td><td align="center"><code>f[C] = 6</code></td></tr><tr><td align="center"><code>B → H</code></td><td align="center"><code>B</code></td><td align="center">Reached</td></tr><tr><td align="center"><code>B</code>遍历结束</td><td align="center"><code>B</code></td><td align="center"><code>f[B] = 7</code></td></tr><tr><td align="center"><code>A</code>遍历结束</td><td align="center"><code>A</code></td><td align="center"><code>f[A] = 8</code></td></tr></tbody></table><p>得到前序序列：<code>{A, B, C, H, E, D, F, G}</code><br>后序序列：<code>{G, F, D, E, H, C, B, A}</code><br>逆后序序列：<code>{A, B, C, H, E, D, F, G}</code></p><h3 id="Kosaraju-Algorithm"><a href="#Kosaraju-Algorithm" class="headerlink" title="Kosaraju Algorithm"></a>Kosaraju Algorithm</h3><p>Kosaraju算法用于找出图中所有的SCC。</p><p>以上图为例，DFS先求出原图的逆后序序列<code>{A, B, C, H, E, D, F, G}</code>，然后根据逆后序序列遍历反图(如下图)：</p><p><img src="https://i.loli.net/2020/04/20/6ONKC39YtgrvMhq.png" alt="SCC_temp_04.20.png"></p><p>Step 1: 从A开始遍历，得到第一个SCC<code>{A, C, B}</code></p><p><img src="https://i.loli.net/2020/04/20/uVgFhpRynEq8xjS.png" alt="SCC_temp_001.png"></p><p>Step 2: 从H开始遍历，得到第二个SCC<code>{H, E, D}</code></p><p><img src="https://i.loli.net/2020/04/20/mIy6ucDhkPvV7Td.png" alt="SCC_temp_002.png"></p><p>Step 3: 从F开始遍历，得到第三个SCC<code>{F, G}</code></p><p><img src="https://i.loli.net/2020/04/20/WFCYswl1pjGb8fe.png" alt="SCC_temp_003.png"></p><h3 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h3><p>投票选举，A认为B合适(<code>A→B</code>的有向边)，B认为C合适(<code>B→C</code>的有向边)，则A也认为C合适(传递性)。因此投票可能形成多个环路。</p><p>先求出共有多少个SCC，每一个SCC内，每个节点的票数 = 该SCC的节点数 - 1(除去自己)；<br>对于每个SCC，都可进行缩点，记作<code>SCC[i]</code>，其值为内节点的票数。<br>若SCC<sub><em>i</em></sub>对SCC<sub><em>j</em></sub>可达，且由 <em>i</em> 指向 <em>j</em>，则<code>SCC[j] += SCC[i]</code>(传递性)。</p><p>票数最多的人，一定出现在出度为0的SCC中。</p><p>总共需要2次DFS求出强连通分量，1次DFS找出票数最高的即出度为0的强连通分量，然后再从这个SCC中找出票数最高的点，即答案。</p><p>本题综合性很强，很容易<code>TLE</code>或<code>MLE</code>。本来用的<code>cin</code>，后来用<code>scanf</code>才过……</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> ele;</span><br><span class="line">node* next;</span><br><span class="line">node() &#123; ele = <span class="number">-1</span>; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">node(<span class="keyword">int</span> e) :ele(e) &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">node* header;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">linkedList() &#123; header = <span class="literal">NULL</span>; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">~linkedList() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size</span>; &#125;</span><br><span class="line"><span class="function">node* <span class="title">getHeader</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> ele)</span> </span>&#123;</span><br><span class="line">node* p = <span class="keyword">new</span> node(ele);</span><br><span class="line"><span class="keyword">if</span> (header == <span class="literal">NULL</span>)</span><br><span class="line">header = p;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node* temp = header;</span><br><span class="line">node* temp2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">temp2 = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp2-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">size</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">node* temp = header;</span><br><span class="line">node* ttemp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ttemp = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">ttemp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">header = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">delete</span> ttemp;</span><br><span class="line"><span class="keyword">delete</span> header;</span><br><span class="line"><span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">linkedList arr1[maxN];</span><br><span class="line">linkedList arr2[maxN];</span><br><span class="line">linkedList arr[maxN];</span><br><span class="line"><span class="keyword">int</span> inDeg[maxN];</span><br><span class="line"><span class="keyword">bool</span> reach1[maxN];</span><br><span class="line"><span class="keyword">int</span> inv[maxN];</span><br><span class="line"><span class="keyword">int</span> invCnt;</span><br><span class="line"><span class="keyword">int</span> color[maxN];</span><br><span class="line"><span class="keyword">int</span> scc[maxN];</span><br><span class="line"><span class="keyword">int</span> sccCnt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">int</span> ans[maxN];</span><br><span class="line"><span class="keyword">bool</span> reach2[maxN];</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">int</span> res[maxN];</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">graph() &#123; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">graph(<span class="keyword">int</span> n) &#123; <span class="built_in">size</span> = n; initialize(); &#125;</span><br><span class="line">~graph() &#123;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sccCnt = <span class="number">0</span>;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">invCnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">inDeg[i] = <span class="number">0</span>;</span><br><span class="line">reach1[i] = <span class="literal">false</span>;</span><br><span class="line">color[i] = <span class="number">0</span>;</span><br><span class="line">scc[i] = <span class="number">0</span>;</span><br><span class="line">ans[i] = <span class="number">0</span>;</span><br><span class="line">res[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;</span><br><span class="line">arr1[p1].add(p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invertedAdd</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;</span><br><span class="line">arr2[p1].add(p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;</span><br><span class="line">arr[p1].add(p2);</span><br><span class="line">inDeg[p2]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">reach1[s] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (node* p = arr1[s].getHeader(); p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line"><span class="keyword">int</span> ele = p-&gt;ele;</span><br><span class="line"><span class="keyword">if</span> (!reach1[ele])</span><br><span class="line">dfs1(ele);</span><br><span class="line">&#125;</span><br><span class="line">inv[++invCnt] = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> sccCnt)</span> </span>&#123;</span><br><span class="line">color[s] = sccCnt;</span><br><span class="line">scc[sccCnt]++;</span><br><span class="line"><span class="keyword">for</span> (node* p = arr2[s].getHeader(); p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line"><span class="keyword">int</span> ele = p-&gt;ele;</span><br><span class="line"><span class="keyword">if</span> (!color[ele])</span><br><span class="line">dfs2(ele, sccCnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (!reach1[i])</span><br><span class="line">dfs1(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> x = inv[i];</span><br><span class="line"><span class="keyword">if</span> (!color[x]) &#123;</span><br><span class="line">sccCnt++;</span><br><span class="line">dfs2(x, sccCnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">reach2[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (node* p = arr[x].getHeader(); p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line"><span class="keyword">int</span> ele = p-&gt;ele;</span><br><span class="line"><span class="keyword">if</span> (!reach2[ele]) &#123;</span><br><span class="line">ans[s] += scc[ele];</span><br><span class="line">dfs3(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">kosaraju();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (node* p = arr2[i].getHeader(); p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line"><span class="keyword">int</span> ele = p-&gt;ele;</span><br><span class="line"><span class="keyword">if</span> (color[i] == color[ele])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">ADD(color[i], color[ele]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sccCnt; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (inDeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(reach2, <span class="literal">false</span>, maxN);</span><br><span class="line">ans[i] += (scc[i] - <span class="number">1</span>);</span><br><span class="line">s = i;</span><br><span class="line">dfs3(i);</span><br><span class="line">count = <span class="built_in">max</span>(count, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sccCnt; i++)</span><br><span class="line"><span class="keyword">if</span> (ans[i] == count)</span><br><span class="line">res[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (res[color[i]])</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, i - <span class="number">1</span>);</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d"</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">1</span>; ii &lt;= t; ii++) &#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">scanf_s(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="function">graph <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> p1, p2;</span><br><span class="line">scanf_s(<span class="string">"%d%d"</span>, &amp;p1, &amp;p2);</span><br><span class="line">G.add(p1 + <span class="number">1</span>, p2 + <span class="number">1</span>);</span><br><span class="line">G.invertedAdd(p2 + <span class="number">1</span>, p1 + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r = G.solve();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ii, r);</span><br><span class="line">G.solve2();</span><br><span class="line">G.~graph();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;班长竞选&quot;&gt;&lt;a href=&quot;#班长竞选&quot; class=&quot;headerlink&quot; title=&quot;班长竞选&quot;&gt;&lt;/a&gt;&lt;strong&gt;班长竞选&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;大学班级选班长，N 个同学均可以发表意见，若意见为 A B，则表示 A 认为 B 合适。意见具有传递性，即 A 认为 B 合适，B 认为 C 合适，则 A 也认为 C 合适。共有 M 条意见，求最高票数，并给出一份候选人名单，即所有得票最多的同学。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="DFS" scheme="co10.github.io/tags/DFS/"/>
    
      <category term="强连通分量" scheme="co10.github.io/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
      <category term="Kosaraju" scheme="co10.github.io/tags/Kosaraju/"/>
    
  </entry>
  
  <entry>
    <title>奇妙的序列</title>
    <link href="co10.github.io/2020/04/17/%E5%A5%87%E5%A6%99%E7%9A%84%E5%BA%8F%E5%88%97/"/>
    <id>co10.github.io/2020/04/17/%E5%A5%87%E5%A6%99%E7%9A%84%E5%BA%8F%E5%88%97/</id>
    <published>2020-04-17T02:36:00.000Z</published>
    <updated>2020-04-20T10:52:27.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="奇妙的序列"><a href="#奇妙的序列" class="headerlink" title="奇妙的序列"></a><strong>奇妙的序列</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有一个奇怪的无限序列: 112123123412345...... </span><br><span class="line">这个序列由连续正整数组成的若干部分构成，其中第一部分包含 1 至 1 之间的所有数字，第二部分包含 1 至 2 之间的所有数字，第三部分包含 1 至 3 之间的所有数字，第 i 部分总是包含 1 至 i 之间的所有数字。</span><br><span class="line">所以，这个序列的前 56 项会是11212312341234512345612345671234567812345678912345678910，其中第 1 项是 1，第 3 项是 2，第 20 项是 5，第 38 项是 2，第56项是 0。</span><br><span class="line">求第 k 项数字是多少。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入由多行组成。</span><br><span class="line">第一行一个整数 q 表示有 q 组询问 (1 ≤ q ≤ 500)</span><br><span class="line">接下来第 i+1 行表示第 i 个输入 ki，表示询问第 ki 项数字 (1 ≤ ki ≤ 1e18)</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出包含 q 行</span><br><span class="line">第 i 行输出对询问 ki 的输出结果。</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">20</span><br><span class="line">38</span><br><span class="line">56</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><table><thead><tr><th>数据点</th><th><em>q</em> (上限)</th><th><em>k</em> (上限)</th></tr></thead><tbody><tr><td>1, 2, 3</td><td>500</td><td>55</td></tr><tr><td>4, 5, 6</td><td>10<sup>4</sup></td><td>10<sup>6</sup></td></tr><tr><td>7, 8, 9, 10</td><td>500</td><td>10<sup>18</sup></td></tr></tbody></table><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit65536 kb</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><p>暴力代码，只有60%的分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line"><span class="built_in">stringstream</span> b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">b &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line">b &gt;&gt; a;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;奇妙的序列&quot;&gt;&lt;a href=&quot;#奇妙的序列&quot; class=&quot;headerlink&quot; title=&quot;奇妙的序列&quot;&gt;&lt;/a&gt;&lt;strong&gt;奇妙的序列&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;有一个奇怪的无限序列: 112123123412345...... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个序列由连续正整数组成的若干部分构成，其中第一部分包含 1 至 1 之间的所有数字，第二部分包含 1 至 2 之间的所有数字，第三部分包含 1 至 3 之间的所有数字，第 i 部分总是包含 1 至 i 之间的所有数字。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所以，这个序列的前 56 项会是11212312341234512345612345671234567812345678912345678910，其中第 1 项是 1，第 3 项是 2，第 20 项是 5，第 38 项是 2，第56项是 0。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;求第 k 项数字是多少。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>平衡字符串Plus</title>
    <link href="co10.github.io/2020/04/17/%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2Plus/"/>
    <id>co10.github.io/2020/04/17/%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2Plus/</id>
    <published>2020-04-17T02:16:17.000Z</published>
    <updated>2020-04-19T15:32:45.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡字符串Plus"><a href="#平衡字符串Plus" class="headerlink" title="平衡字符串Plus"></a><strong>平衡字符串Plus</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，字符串中包括26个大写字母和特殊字符&#39;?&#39;，特殊字符&#39;?&#39;可以代表任何一个大写字母。</span><br><span class="line">是否存在一个位置连续的且由26个大写字母组成的子串，在这个子串中每个字母出现且仅出现一次，如果存在，请输出从左侧算起的第一个出现的符合要求的子串，并且要求，如果有多组解同时符合位置最靠左，则输出字典序最小的那个解；如果不存在，输出-1。</span><br><span class="line"></span><br><span class="line">说明：字典序先按照第一个字母，以 A、B、C ...... Z 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，SIGH 和 SIGHT），那么把短者排在前。例如</span><br><span class="line">AB??EFGHIJKLMNOPQRSTUVWXYZ </span><br><span class="line"> </span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">ABDCEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">上面两种填法，都可以构成26个字母，但是我们要求字典序最小，只能取前者。</span><br><span class="line">注意，题目要求的是第一个出现的，字典序最小的！</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入只有一行，一个符合题目描述的字符串。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出只有一行，如果存在这样的子串，请输出，否则输出-1</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">ABC??FGHIJK???OPQR?TUVWXY?</span><br><span class="line">Output: </span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">AABCDEFGHIJKLMNOPQRSTUVW??M</span><br><span class="line">Output: </span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><table><thead><tr><th>数据点</th><th>字符串长度</th></tr></thead><tbody><tr><td>1, 2, 3</td><td>10</td></tr><tr><td>4, 5, 6</td><td>10<sup>4</sup></td></tr><tr><td>7, 8, 9, 10</td><td>10<sup>6</sup></td></tr></tbody></table><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit65536 kb</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>滑动窗口问题，窗口内26个字符，不断向右滑动；<br>每次对窗口内字符串判断，先记录26个字母的频率，若有其中一个字母频率&gt;1，则这个窗口一定不行，及时终止；若有字母的频率为0，则一定出现了’?’，记下这个字母；26个字符全扫一遍后，将’?’按字母表顺序全部替换为字母，返回字符串。<br>不断滑动窗口，直至出现第一个符合情况的字符串，按要求输出。</p><p>这样暴力求解，本来是想骗分的，没想到真的<code>AC</code>了……</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getN</span><span class="params">(<span class="keyword">char</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= <span class="number">65</span> &amp;&amp; a &lt;= <span class="number">90</span>)</span><br><span class="line"><span class="keyword">return</span> a - <span class="number">64</span>;<span class="comment">//标记A~Z：1~26</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//标记?：0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve1</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count[<span class="number">27</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">count[getN(s[i])]++;</span><br><span class="line"><span class="keyword">int</span> c0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> temp[<span class="number">27</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">string</span> t = <span class="string">"-1"</span>;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count[i] == <span class="number">0</span>) &#123;</span><br><span class="line">temp[c0] = i;</span><br><span class="line">c0++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> res = s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (res[i] == <span class="string">'?'</span>) &#123;</span><br><span class="line"><span class="keyword">char</span> cha = temp[c2] + <span class="number">64</span>;</span><br><span class="line">c2++;</span><br><span class="line">res[i] = cha;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve2</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">25</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> c = s.substr(i - <span class="number">25</span>, <span class="number">26</span>);</span><br><span class="line"><span class="built_in">string</span> res = solve1(c);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="string">"-1"</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (res.<span class="built_in">size</span>() == <span class="number">26</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve2(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;平衡字符串Plus&quot;&gt;&lt;a href=&quot;#平衡字符串Plus&quot; class=&quot;headerlink&quot; title=&quot;平衡字符串Plus&quot;&gt;&lt;/a&gt;&lt;strong&gt;平衡字符串Plus&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定一个字符串，字符串中包括26个大写字母和特殊字符&amp;#39;?&amp;#39;，特殊字符&amp;#39;?&amp;#39;可以代表任何一个大写字母。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;是否存在一个位置连续的且由26个大写字母组成的子串，在这个子串中每个字母出现且仅出现一次，如果存在，请输出从左侧算起的第一个出现的符合要求的子串，并且要求，如果有多组解同时符合位置最靠左，则输出字典序最小的那个解；如果不存在，输出-1。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明：字典序先按照第一个字母，以 A、B、C ...... Z 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，SIGH 和 SIGHT），那么把短者排在前。例如&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AB??EFGHIJKLMNOPQRSTUVWXYZ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ABDCEFGHIJKLMNOPQRSTUVWXYZ&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;上面两种填法，都可以构成26个字母，但是我们要求字典序最小，只能取前者。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意，题目要求的是第一个出现的，字典序最小的！&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="滑动窗口" scheme="co10.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>预测名次</title>
    <link href="co10.github.io/2020/04/15/%E9%A2%84%E6%B5%8B%E5%90%8D%E6%AC%A1/"/>
    <id>co10.github.io/2020/04/15/%E9%A2%84%E6%B5%8B%E5%90%8D%E6%AC%A1/</id>
    <published>2020-04-15T02:57:38.000Z</published>
    <updated>2020-04-20T03:39:36.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="猫猫比赛-预测名次"><a href="#猫猫比赛-预测名次" class="headerlink" title="猫猫比赛-预测名次"></a><strong>猫猫比赛-预测名次</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共有 N 只猫猫，编号依次为1, 2, 3, …, N 进行比赛，求字典序最小的名次序列。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入有若干组，每组中的第一行为二个数 N (1 ≤ N ≤ 500), M；其中 N 表示猫猫的个数，M 表示接着有 M 行的输入数据。接下来的 M 行数据中，每行也有两个整数 P1, P2 表示即编号为 P1 的猫猫赢了编号为 P2 的猫猫。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给出一个符合要求的排名。输出时猫猫的编号之间有空格，最后一名后面没有空格!</span><br><span class="line"></span><br><span class="line">其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">1 2 4 3</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit32768 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>比赛问题，若A胜B，A胜C，B胜C，则A的名次在B、C的前面，B的名次在C的前面，可以构成有向无环图，因此可以使用拓扑排序。</p><p>集合<code>U</code>为点集，每次选出入度为零的点<code>s</code>，加入结果集合<code>S</code>中，并从<code>U</code>中删除<code>s</code>，并修改<code>s</code>指向的点的入度，以此循环，直至<code>U</code>为空。</p><p>由于每次选的入度为零的点有多个，本题要求以字典序输出，因此可用优先级队列储存每次选取的入度为零的点，然后进行BFS，遍历全图。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> ele;</span><br><span class="line">node* next;</span><br><span class="line">node() &#123; ele = <span class="number">-1</span>; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">node(<span class="keyword">int</span> e) :ele(e) &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">node* header;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">linkedList() &#123; header = <span class="literal">NULL</span>; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">~linkedList() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size</span>; &#125;</span><br><span class="line"><span class="function">node* <span class="title">getHeader</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> ele)</span> </span>&#123;</span><br><span class="line">node* p = <span class="keyword">new</span> node(ele);</span><br><span class="line"><span class="keyword">if</span> (header == <span class="literal">NULL</span>)</span><br><span class="line">header = p;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node* temp = header;</span><br><span class="line">node* temp2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">temp2 = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp2-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">size</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">node* temp = header;</span><br><span class="line">node* ttemp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ttemp = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">ttemp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">header = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">delete</span> ttemp;</span><br><span class="line"><span class="keyword">delete</span> header;</span><br><span class="line"><span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">linkedList arr[maxN];</span><br><span class="line"><span class="keyword">int</span> inDeg[maxN];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">graph() &#123; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">graph(<span class="keyword">int</span> n) &#123; <span class="built_in">size</span> = n; setIN(); &#125;</span><br><span class="line">~graph() &#123;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIN</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">size</span>; i++)</span><br><span class="line">inDeg[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;</span><br><span class="line">arr[p1].add(p2);</span><br><span class="line">inDeg[p2]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (inDeg[i] == <span class="number">0</span>)</span><br><span class="line">q.push(i);<span class="comment">//所有入度为零的点入队</span></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top();<span class="comment">//选出队首元素 开始遍历</span></span><br><span class="line">q.pop();</span><br><span class="line">ans.push_back(x);</span><br><span class="line"><span class="keyword">for</span> (node* p = arr[x].getHeader(); p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line"><span class="keyword">int</span> ele = p-&gt;ele;</span><br><span class="line">inDeg[ele]--;<span class="comment">//与之相邻的点入度 -1</span></span><br><span class="line"><span class="keyword">if</span> (inDeg[ele] == <span class="number">0</span>)<span class="comment">//入度为零 可入队</span></span><br><span class="line">q.push(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">while</span> (!(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m).eof()) &#123;</span><br><span class="line"><span class="function">graph <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> p1, p2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">G.add(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = G.topoSort();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[v.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;猫猫比赛-预测名次&quot;&gt;&lt;a href=&quot;#猫猫比赛-预测名次&quot; class=&quot;headerlink&quot; title=&quot;猫猫比赛-预测名次&quot;&gt;&lt;/a&gt;&lt;strong&gt;猫猫比赛-预测名次&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;一共有 N 只猫猫，编号依次为1, 2, 3, …, N 进行比赛，求字典序最小的名次序列。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="拓扑排序" scheme="co10.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>区间选点Plus</title>
    <link href="co10.github.io/2020/04/14/%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9Plus/"/>
    <id>co10.github.io/2020/04/14/%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9Plus/</id>
    <published>2020-04-14T02:54:18.000Z</published>
    <updated>2020-04-20T10:59:26.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区间选点Plus"><a href="#区间选点Plus" class="headerlink" title="区间选点Plus"></a><strong>区间选点Plus</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个数轴上的 n 个区间，要求在数轴上选取最少的点使得第 i 个区间 [ai, bi] 里至少有 ci 个点。</span><br><span class="line">使用差分约束系统的解法解决这道题。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入第一行一个整数 n 表示区间的个数，接下来的 n 行，每一行两个用空格隔开的整数 a, b 表示区间的左右端点。1 ≤ n ≤ 50000， 0 ≤ ai ≤ bi ≤ 50000 并且 1 ≤ ci ≤ bi - ai + 1。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个整数表示最少选取的点的个数</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">5</span><br><span class="line">3 7 3</span><br><span class="line">8 10 3</span><br><span class="line">6 8 1</span><br><span class="line">1 3 1</span><br><span class="line">10 11 1</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit2000 ms</span><br><span class="line">Memory limit65536 kb</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><h3 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h3><p>差分约束系统中的每个约束条件$x_i - x_j ≤ c_k$都可变形成$x_i ≤ x_j + c_k$，这与单源最短路中的不等式dis[u] ≤ dis[v] + w非常相似。因此可以把 <em>x</em><sub><em>i</em></sub> 看作图中的节点，$x_i - x_j ≤ c_k$表示从节点 <em>i</em> 到节点 <em>j</em> 的一条权值为<em>c</em><sub><em>k</em></sub>的有向边。</p><p>设<code>dis[0] = 0</code>并向每一个点连一条边，跑单源最短路，若图中存在负环，则给定的差分约束系统无解，否则， <em>x</em><sub><em>i</em></sub> = dis[<em>i</em>]为该差分约束系统的一组解。</p><p>求存在负边的单源最短路可以用SPFA。</p><h3 id="本题解法"><a href="#本题解法" class="headerlink" title="本题解法"></a>本题解法</h3><p>用一个前缀和<code>sum[i]</code>表示区间<code>[begin, i]</code>之内选取的点的个数，则<code>sum[b] - sum[a] ≥ c</code>表示区间<code>[a, b]</code>内至少选取了<code>c</code>个点，<code>sum[i] - sum[i - 1]</code>表示第 <code>i</code> 个点选或不选，因此可以转化成差分约束的形式。</p><p><em>n</em> 个区间，可以看成 <em>n</em> 个差分约束，由 <em>a</em><sub><em>i</em></sub> 到 <em>b</em><sub><em>i</em></sub> + 1 的边，权重为 <em>c</em><sub><em>i</em></sub> ，加入到图中，但是并不能保证图的联通，因此每一个相邻的点之间要加入有向边<code>(i, i + 1, 0)</code>和<code>(i + 1, i, -1)</code>，即差分约束<code>0 ≤ sum[i + 1] - sum[i] ≤ 1</code>，即表示第 <code>i + 1</code> 个点选/不选(存在/不存在)。</p><p>本题求下界，所以SPFA要跑最长路，从所有区间的最左端点跑到最右端点即可。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> ele;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">node* next;</span><br><span class="line">node() &#123; ele = <span class="number">-1</span>; w = <span class="number">-2</span>; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">node(<span class="keyword">int</span> e, <span class="keyword">int</span> _w) :ele(e), w(_w) &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">node* header;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">linkedList() &#123; header = <span class="literal">NULL</span>; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">~linkedList() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size</span>; &#125;</span><br><span class="line"><span class="function">node* <span class="title">getHeader</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> ele, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">node* p = <span class="keyword">new</span> node(ele, w);</span><br><span class="line"><span class="keyword">if</span> (header == <span class="literal">NULL</span>)</span><br><span class="line">header = p;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node* temp = header;</span><br><span class="line">node* temp2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">temp2 = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp2-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">size</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">node* temp = header;</span><br><span class="line">node* ttemp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ttemp = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">ttemp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">header = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">delete</span> ttemp;</span><br><span class="line"><span class="keyword">delete</span> header;</span><br><span class="line"><span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxSize = <span class="number">50050</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">linkedList arr[maxSize];</span><br><span class="line"><span class="keyword">int</span> dis[maxSize];</span><br><span class="line"><span class="keyword">int</span> vis[maxSize];</span><br><span class="line"><span class="keyword">int</span> dots;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">graph() &#123; </span><br><span class="line">dots = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(dis, -maxN, maxSize);</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, maxSize);</span><br><span class="line">&#125;</span><br><span class="line">graph(<span class="keyword">int</span> n) &#123; </span><br><span class="line">dots = n;</span><br><span class="line"><span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(dis, -maxN, maxSize);</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, maxSize);</span><br><span class="line">&#125;</span><br><span class="line">~graph() &#123;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">arr[u].add(v, w);</span><br><span class="line"><span class="built_in">size</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= dots; i++) &#123;</span><br><span class="line">dis[i] = -maxN;</span><br><span class="line">vis[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">vis[s] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (node* p = arr[x].getHeader(); p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line"><span class="keyword">int</span> w = p-&gt;w;</span><br><span class="line"><span class="keyword">int</span> v = p-&gt;ele;</span><br><span class="line"><span class="keyword">if</span> (dis[v] &lt; dis[x] + w) &#123;</span><br><span class="line">dis[v] = dis[x] + w;</span><br><span class="line"><span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">q.push(v);</span><br><span class="line">vis[v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[e];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="function">graph <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = maxN, right = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line">scanf_s(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">G.add(a, b + <span class="number">1</span>, c);</span><br><span class="line">left = <span class="built_in">min</span>(left, a);</span><br><span class="line">right = <span class="built_in">max</span>(right, b + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">G.add(i + <span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line">G.add(i, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = G.spfa(left, right);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区间选点Plus&quot;&gt;&lt;a href=&quot;#区间选点Plus&quot; class=&quot;headerlink&quot; title=&quot;区间选点Plus&quot;&gt;&lt;/a&gt;&lt;strong&gt;区间选点Plus&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定一个数轴上的 n 个区间，要求在数轴上选取最少的点使得第 i 个区间 [ai, bi] 里至少有 ci 个点。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用差分约束系统的解法解决这道题。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="差分约束" scheme="co10.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
      <category term="SPFA" scheme="co10.github.io/tags/SPFA/"/>
    
  </entry>
  
  <entry>
    <title>序列操作</title>
    <link href="co10.github.io/2020/04/11/%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C/"/>
    <id>co10.github.io/2020/04/11/%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C/</id>
    <published>2020-04-11T02:15:29.000Z</published>
    <updated>2020-04-20T10:58:41.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a><strong>序列操作</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存在一个序列 a, 是否存在一个数 K, 使得一些数加上 K，一些数减去 K，一些数不变，使得整个序列中所有的数相等。</span><br><span class="line">其中对于序列中的每个位置上的数字，至多只能执行一次加运算或减运算或是对该位置不进行任何操作。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输⼊第一行是一个正整数 t 表示数据组数。</span><br><span class="line">接下来对于每组数据，输入的第一个正整数 n 表示序列 a 的长度，随后一行有 n 个整数，标号序列 a 。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出共包含 t 行，每组数据输出一行。对于每组数据，如果存在这样的 K，输出&quot;YES&quot;，否则输出&quot;NO&quot;。（输出不包含引号）</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><table><thead><tr><th>数据点(上限)</th><th><em>t</em></th><th><em>n</em></th><th><em>a</em><sub><em>i</em></sub></th></tr></thead><tbody><tr><td>1, 2</td><td>10</td><td>10</td><td>10</td></tr><tr><td>3, 4, 5</td><td>10</td><td>10<sup>3</sup></td><td>10<sup>9</sup></td></tr><tr><td>6, 7, 8, 9, 10</td><td>10</td><td>10<sup>4</sup></td><td>10<sup>15</sup></td></tr></tbody></table><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit65536 kb</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>操作只有，一些数加上<em>k</em>，一些数减去<em>k</em>，一些数不变，对于每一个数列，<em>k</em>恒定为一个数<em>k</em>或者其相反数。</p><p>可以把原数组排序，前面的数(小的数)加上<em>k</em>，中间的数不变，后面的数(大的数)减去<em>k</em>，所以一个数列中最多存在3个数：<em>x</em> - <em>k</em>, <em>x</em>, <em>x</em> + <em>k</em>，因此可以记录数列中有多少种不同的数。</p><p>如果不同的数种类 &gt; 3，则不存在<em>k</em>；<br>若种类 = 1 或 2，则一定存在<em>k</em>；<br>若种类 = 3，则可以记录不同数出现的位置，记下这3个不同数：若<code>(小的数+大的数)=2×中间的数</code>，则一定存在<em>k</em>，否则<em>k</em>不存在。</p><p>模拟的时候，没有注意数据范围，用的<code>int</code>，后面几组数据<code>WA</code>了，后来改成<code>long long</code> 就过了……所以一定要留意数据范围啊！</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">sort(a, a + n);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dif[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] != a[i - <span class="number">1</span>]) &#123;</span><br><span class="line">dif[count] = i;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x = a[dif[<span class="number">0</span>] - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> y = a[dif[<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> z = a[dif[<span class="number">1</span>]];</span><br><span class="line"><span class="keyword">if</span> (x + z != <span class="number">2</span> * y)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">1</span> || count == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii != t; ii++) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>* a = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[n + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">bool</span> ans = solve(a, n);</span><br><span class="line"><span class="keyword">if</span> (ans)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序列操作&quot;&gt;&lt;a href=&quot;#序列操作&quot; class=&quot;headerlink&quot; title=&quot;序列操作&quot;&gt;&lt;/a&gt;&lt;strong&gt;序列操作&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;存在一个序列 a, 是否存在一个数 K, 使得一些数加上 K，一些数减去 K，一些数不变，使得整个序列中所有的数相等。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其中对于序列中的每个位置上的数字，至多只能执行一次加运算或减运算或是对该位置不进行任何操作。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>城市穿梭</title>
    <link href="co10.github.io/2020/04/09/%E5%9F%8E%E5%B8%82%E7%A9%BF%E6%A2%AD/"/>
    <id>co10.github.io/2020/04/09/%E5%9F%8E%E5%B8%82%E7%A9%BF%E6%A2%AD/</id>
    <published>2020-04-09T02:46:03.000Z</published>
    <updated>2020-04-19T15:10:11.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a><strong>序列操作</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有 N 个商业城市，编号 1 ～ N，其中 1 号城市是首都。</span><br><span class="line">共有 M 条有向道路供商业城市相互往来。</span><br><span class="line">对每一个商业城市标记一个正整数，表示其繁荣程度，当有人沿道路从一个商业城市走到另一个商业城市时，会被收取 (目的地繁荣程度 – 出发地繁荣程度)^3 的税。</span><br><span class="line">求从首都出发，走到其他城市至少要交多少的税，如果总金额小于 3 或者无法到达请打出 &#39;?&#39;。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一行输入 T，表明共有 T 组数据。（1 ≤ T ≤ 50）</span><br><span class="line">对于每一组数据，第一行输入 N，表示点的个数。（1 ≤ N ≤ 200）</span><br><span class="line">第二行输入 N 个整数，表示 1 ～ N 点的权值 a[i]。（0 ≤ a[i] ≤ 20）</span><br><span class="line">第三行输入 M，表示有向道路的条数。（0 ≤ M ≤ 100000）</span><br><span class="line">接下来 M 行，每行有两个整数 A B，表示存在一条 A 到 B 的有向道路。</span><br><span class="line">接下来给出一个整数 Q，表示询问个数。（0 ≤ Q ≤ 100000）</span><br><span class="line">每一次询问给出一个 P，表示求 1 号点到 P 号点的最少税费。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个询问输出一行，如果不可达或税费小于 3 则输出 &#39;?&#39;。</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">6 7 8 9 10</span><br><span class="line">6</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">1 5</span><br><span class="line">5 4</span><br><span class="line">4 5</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">1 2 4 4 5 6 7 8 9 10</span><br><span class="line">10</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">1 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">7 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br><span class="line">2</span><br><span class="line">3 10</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">Case 1:</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">Case 2:</span><br><span class="line">?</span><br><span class="line">?</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit2000 ms</span><br><span class="line">Memory limit32768 kb</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>含有负边的单源最短路问题，可以用Bellman-Ford算法解决。</p><h3 id="Bellman-Ford-Algorithm"><a href="#Bellman-Ford-Algorithm" class="headerlink" title="Bellman-Ford Algorithm"></a>Bellman-Ford Algorithm</h3><p>从源点<code>s</code>开始，用<code>dis[]</code>数组初始化距离。<code>dis[s] = 0</code>，<code>dis[v] = +∞ (v ≠ s)</code>。<br>反复对边集<code>E</code>中的每条边进行松弛操作，使得点集<code>V</code>中的每个顶点v的最短距离估计值逼近其最短距离，共运行<code>|V|-1</code>次。<br>判断<code>E</code>中的每一条边的两个端点是否收敛，若有端点未收敛则无解，否则就将从源点可到达的<code>v</code>加入到<code>dis[v]</code>中。</p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">procedure <span class="title">BellmanFord</span><span class="params">(<span class="built_in">list</span> vertices, <span class="built_in">list</span> edges, vertex source)</span></span></span><br><span class="line"><span class="function">   <span class="comment">// 读入边和节点的列表并对distance和predecessor写入最短路径</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="comment">// 初始化图</span></span></span><br><span class="line"><span class="function">   <span class="keyword">for</span> each vertex v in vertices:</span></span><br><span class="line">       if v is source then distance[v] := 0</span><br><span class="line">       <span class="keyword">else</span> distance[v] := infinity</span><br><span class="line">       predecessor[v] := null</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对每一条边重复操作</span></span><br><span class="line">   <span class="keyword">for</span> i from <span class="number">1</span> to <span class="built_in">size</span>(vertices)<span class="number">-1</span>:</span><br><span class="line">       <span class="keyword">for</span> each edge (u, v) with weight w in edges:</span><br><span class="line">           <span class="keyword">if</span> distance[u] + w &lt; distance[v]:</span><br><span class="line">               distance[v] := distance[u] + w</span><br><span class="line">               predecessor[v] := u</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查是否有负权回路</span></span><br><span class="line">   <span class="keyword">for</span> each edge (u, v) with weight w in edges:</span><br><span class="line">       <span class="keyword">if</span> distance[u] + w &lt; distance[v]:</span><br><span class="line">           error <span class="string">"图包含具负权重的回路"</span></span><br></pre></td></tr></table></figure><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p><img src="https://i.loli.net/2020/04/19/wGkDTRb7ephASn6.png" alt="bford.png"></p><p>然而，Bellman-Ford算法的时间复杂度是<em>O</em>(|<em>V</em>|×|<em>E</em>|)，相比于Dijkstra太慢了，因此引入了队列优化的SPFA。</p><h3 id="Shortest-Path-Fast-Algorithm-SPFA"><a href="#Shortest-Path-Fast-Algorithm-SPFA" class="headerlink" title="Shortest Path Fast Algorithm (SPFA)"></a>Shortest Path Fast Algorithm (SPFA)</h3><p>SPFA总的期望时间复杂度为<em>O</em>(<em>n</em> log <em>n</em> log (<em>m</em>/<em>n</em>) + <em>m</em>)，基于实验获得的平均时间复杂度为<em>O</em>(2|<em>E</em>|)。(From <a href="[https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%BF%AB%E9%80%9F%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/最短路径快速算法)">Wikipedia</a>)</p><p>给定一个加权有向图<code>G</code>，从源点<code>s</code>开始，求到每个顶点<code>v</code>的最短路径<code>dis[v]</code>。<br>基本思路与Bellman-Ford相同，只不过SPFA使用了队列维护备选节点，仅有节点被松弛后才会放入队列中。即如果这轮<code>dis[i]</code>没有被更新，那么下一轮就没有必要更新所有从<code>i</code>出发的边。如果某一点入队 <em>n</em> 次则说明有负环。</p><h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">procedure Shortest-Path-Faster-Algorithm(G, s)</span><br><span class="line"> <span class="number">1</span>    <span class="keyword">for</span> each vertex v ≠ <span class="function">s in <span class="title">V</span><span class="params">(G)</span></span></span><br><span class="line"><span class="function"> 2        <span class="title">d</span><span class="params">(v)</span> :</span>= ∞</span><br><span class="line"> <span class="number">3</span>    d(s) := <span class="number">0</span></span><br><span class="line"> <span class="number">4</span>    offer s into Q</span><br><span class="line"> <span class="number">5</span>    <span class="keyword">while</span> Q is not empty</span><br><span class="line"> <span class="number">6</span>        u := poll Q</span><br><span class="line"> <span class="number">7</span>        <span class="function"><span class="keyword">for</span> each <span class="title">edge</span> <span class="params">(u, v)</span> in <span class="title">E</span><span class="params">(G)</span></span></span><br><span class="line"><span class="function"> 8            <span class="keyword">if</span> <span class="title">d</span><span class="params">(u)</span> + <span class="title">w</span><span class="params">(u, v)</span> &lt; <span class="title">d</span><span class="params">(v)</span> then</span></span><br><span class="line"><span class="function"> 9                <span class="title">d</span><span class="params">(v)</span> :</span>= d(u) + w(u, v)</span><br><span class="line"><span class="number">10</span>                <span class="keyword">if</span> v is not in Q then</span><br><span class="line"><span class="number">11</span>                    offer v into Q</span><br></pre></td></tr></table></figure><h3 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h3><p>根据繁荣程度，求出各个边的权值。题目要求从1到 i 的最短路径。若不可到达、可到达但税收小于3且不存在负环、可到达但存在负环则输出’<code>?</code>‘。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to, w;</span><br><span class="line">edge* next;</span><br><span class="line">edge() &#123; to = <span class="number">-1</span>; w = <span class="number">-1</span>; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">edge(<span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">int</span> _w) :to(<span class="keyword">_t</span>), w(_w) &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">edge* head;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">linkedList() &#123; head = <span class="literal">NULL</span>; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">~linkedList() &#123;</span><br><span class="line">edge* temp = head;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">edge* p = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">edge* <span class="title">getFirst</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge* node = <span class="keyword">new</span> edge(to, w);</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">head = node;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">edge* p = head;</span><br><span class="line">edge* pp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">pp = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pp-&gt;next = node;</span><br><span class="line"><span class="built_in">size</span>++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">linkedList arr[maxN];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">int</span> dis[maxN];</span><br><span class="line"><span class="keyword">bool</span> visit[maxN];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">graph() &#123; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">graph(<span class="keyword">int</span> n) :<span class="built_in">size</span>(n) &#123;  &#125;</span><br><span class="line">~graph() &#123;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">arr[a].add(b, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (edge* temp = arr[x].getFirst(); temp != <span class="literal">NULL</span>; temp = temp-&gt;next) &#123;</span><br><span class="line"><span class="keyword">int</span> y = temp-&gt;to;</span><br><span class="line"><span class="keyword">if</span> (!visit[y]) &#123;</span><br><span class="line">visit[y] = <span class="literal">true</span>;</span><br><span class="line">dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> inq[maxN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> cnt[maxN] = &#123; <span class="number">0</span> &#125;;<span class="comment">//记录访问每个点经过边的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">dis[i] = inf;</span><br><span class="line">visit[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">q.push(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> p = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">inq[p] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (edge* temp = arr[p].getFirst(); temp != <span class="literal">NULL</span>; temp = temp-&gt;next) &#123;</span><br><span class="line"><span class="keyword">int</span> dest = temp-&gt;to;</span><br><span class="line"><span class="keyword">int</span> weight = temp-&gt;w;</span><br><span class="line"><span class="keyword">if</span> (visit[dest])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (dis[dest] &gt; dis[p] + weight) &#123;</span><br><span class="line">dis[dest] = dis[p] + weight;</span><br><span class="line">cnt[dest] = cnt[p] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt[dest] &gt;= <span class="built_in">size</span>) &#123;<span class="comment">//说明存在负环</span></span><br><span class="line">visit[dest] = <span class="literal">true</span>;</span><br><span class="line">dfs(dest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!inq[dest]) &#123;</span><br><span class="line">q.push(dest);</span><br><span class="line">inq[dest] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visit[x] || dis[x] == inf || dis[x] &lt; <span class="number">3</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[x] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">1</span>; ii &lt;= t; ii++) &#123;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="function">graph <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">int</span>* W = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; W[i];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">int</span> w0 = W[b] - W[a];</span><br><span class="line"><span class="keyword">int</span> weight = w0 * w0 * w0;</span><br><span class="line">G.add(a, b, weight);</span><br><span class="line">&#125;</span><br><span class="line">G.spfa();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ii &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">G.output(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序列操作&quot;&gt;&lt;a href=&quot;#序列操作&quot; class=&quot;headerlink&quot; title=&quot;序列操作&quot;&gt;&lt;/a&gt;&lt;strong&gt;序列操作&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;有 N 个商业城市，编号 1 ～ N，其中 1 号城市是首都。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;共有 M 条有向道路供商业城市相互往来。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对每一个商业城市标记一个正整数，表示其繁荣程度，当有人沿道路从一个商业城市走到另一个商业城市时，会被收取 (目的地繁荣程度 – 出发地繁荣程度)^3 的税。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;求从首都出发，走到其他城市至少要交多少的税，如果总金额小于 3 或者无法到达请打出 &amp;#39;?&amp;#39;。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="SPFA" scheme="co10.github.io/tags/SPFA/"/>
    
      <category term="Bellman-Ford" scheme="co10.github.io/tags/Bellman-Ford/"/>
    
      <category term="最短路径" scheme="co10.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>快线换乘-最短路径</title>
    <link href="co10.github.io/2020/04/07/%E5%BF%AB%E7%BA%BF%E6%8D%A2%E4%B9%98-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>co10.github.io/2020/04/07/%E5%BF%AB%E7%BA%BF%E6%8D%A2%E4%B9%98-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</id>
    <published>2020-04-07T03:41:37.000Z</published>
    <updated>2020-04-19T13:08:38.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a><strong>最短路径</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">猫猫快线是市民从市内去喵星机场的首选交通工具。猫猫快线分为经济线和商业线两种，线路、速度和价钱都不同。TT 有一张商业线车票，可以坐一站商业线，而其他时候只能乘坐经济线。假设换乘时间忽略不计，你的任务是找一条去喵星机场最快的线路。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入包含多组数据。每组数据第一行为 3 个整数 N, S 和 E (2 ≤ N ≤ 500, 1 ≤ S, E ≤ 100)，即猫猫快线中的车站总数，起点和终点（即喵星机场所在站）编号。</span><br><span class="line"></span><br><span class="line">下一行包含一个整数 M (1 ≤ M ≤ 1000)，即经济线的路段条数。</span><br><span class="line"></span><br><span class="line">接下来有 M 行，每行 3 个整数 X, Y, Z (1 ≤ X, Y ≤ N, 1 ≤ Z ≤ 100)，表示 TT 可以乘坐经济线在车站 X 和车站 Y 之间往返，其中单程需要 Z 分钟。</span><br><span class="line"></span><br><span class="line">下一行为商业线的路段条数 K (1 ≤ K ≤ 1000)。</span><br><span class="line"></span><br><span class="line">接下来 K 行是商业线路段的描述，格式同经济线。</span><br><span class="line"></span><br><span class="line">所有路段都是双向的，但有可能必须使用商业车票才能到达机场。保证最优解唯一。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于每组数据，输出3行。第一行按访问顺序给出 TT 经过的各个车站（包括起点和终点），第二行是 TT 换乘商业线的车站编号（如果没有使用商业线车票，输出&quot;Ticket Not Used&quot;，不含引号），第三行是 TT 前往喵星机场花费的总时间。</span><br><span class="line"></span><br><span class="line">本题不忽略多余的空格和制表符，且每一组答案间要输出一个换行</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">4 1 4</span><br><span class="line">4</span><br><span class="line">1 2 2</span><br><span class="line">1 3 3</span><br><span class="line">2 4 4</span><br><span class="line">3 4 5</span><br><span class="line">1</span><br><span class="line">2 4 3</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">1 2 4</span><br><span class="line">2</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>不考虑商业线，这是一个没有负边的单源最短路问题，用Dijksta算法求解即可。</p><h3 id="Dijkstra-Algorithm"><a href="#Dijkstra-Algorithm" class="headerlink" title="Dijkstra Algorithm"></a>Dijkstra Algorithm</h3><p>引进两个集合<code>S</code>和<code>U</code>，<code>S</code>记录已求出的最短路径的顶点，<code>U</code>记录还未求出最短路径的顶点。</p><p>从一个起点<code>s</code>出发，初始时，<code>S</code>中只有<code>s</code>，<code>U</code>中有除<code>s</code>外的其它顶点且其距离为<code>s</code>到之的距离，不断的从<code>U</code>中选出距离最短的顶点<code>k</code>，并将<code>k</code>加入到<code>S</code>中，且从<code>U</code>中移除<code>k</code>。</p><p>然后更新<code>U</code>，<code>(s, v)</code>表示<code>s</code>到<code>v</code>的距离，若<code>(s, v) &gt; (s, k) + (k, v)</code>，则更新<code>(s, v)</code>。</p><p>不断重复以上操作，直至遍历完所有顶点。</p><h3 id="再看这道题"><a href="#再看这道题" class="headerlink" title="再看这道题"></a>再看这道题</h3><p>先不考虑商业线，从起点开始遍历，可以求出起点到每个点的最短距离<code>dis1[]</code>，再从终点开始遍历得到最短距离<code>dis2[]</code>。</p><p>考虑商业线，对于每一次输入的商业线<code>(u, v, w)</code>，对比一下<code>dis1[u]+dis2[v]+w</code>(由起点到<code>u</code>、由终点到<code>v</code>，且算上这条商业线的<code>w</code>)与<code>dis1[v]+dis2[u]+w</code>(起点→<code>v</code>、终点→<code>u</code>、商业线权重<code>w</code>)，取最小值，并用一个<code>ans</code>记录每一个的最小值，次次取最小，枚举完后记录的那个就是所取的商业线。<code>ans</code>再与不走商业线对比，最小值就是最终答案，根据题目格式输出。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, w;</span><br><span class="line">edge* next;</span><br><span class="line">edge() &#123; to = <span class="number">-1</span>; w = <span class="number">-1</span>; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">edge(<span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">int</span> _w) :to(<span class="keyword">_t</span>), w(_w) &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">edge* head;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">linkedList() &#123; head = <span class="literal">NULL</span>; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">~linkedList() &#123;</span><br><span class="line">edge* temp = head;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">edge* p = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">edge* <span class="title">getFirst</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge* node = <span class="keyword">new</span> edge(to, w);</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">head = node;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">edge* p = head;</span><br><span class="line">edge* pp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">pp = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pp-&gt;next = node;</span><br><span class="line"><span class="built_in">size</span>++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis1[maxN], dis2[maxN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接链表表示的图*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">linkedList arr[maxN];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">int</span> pre1[maxN];</span><br><span class="line"><span class="keyword">int</span> pre2[maxN];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">graph() &#123; <span class="built_in">size</span> = <span class="number">0</span>; &#125;</span><br><span class="line">graph(<span class="keyword">int</span> n) :<span class="built_in">size</span>(n) &#123;  &#125;</span><br><span class="line">~graph() &#123;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">arr[x].add(y, z);</span><br><span class="line">arr[y].add(x, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">bool</span> sta)</span> </span>&#123;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> reach[maxN] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sta) <span class="comment">//判断是否是初始车站</span></span><br><span class="line">dis1[i] = inf;</span><br><span class="line"><span class="keyword">if</span> (!sta)</span><br><span class="line">dis2[i] = inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sta)</span><br><span class="line">dis1[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!sta)</span><br><span class="line">dis2[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">q.push(make_pair(<span class="number">0</span>, s));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (reach[x])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">reach[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (edge* temp = arr[x].getFirst(); temp != <span class="literal">NULL</span>; temp = temp-&gt;next) &#123;<span class="comment">//遍历以当前点所有可能到达的最近车站，更新距离并记录前一车站以便输出</span></span><br><span class="line"><span class="keyword">int</span> dest = temp-&gt;to;</span><br><span class="line"><span class="keyword">int</span> weight = temp-&gt;w;</span><br><span class="line"><span class="keyword">if</span> (sta) &#123;</span><br><span class="line"><span class="keyword">if</span> (dis1[dest] &gt; dis1[x] + weight) &#123;</span><br><span class="line">dis1[dest] = dis1[x] + weight;</span><br><span class="line">pre1[dest] = x;</span><br><span class="line">q.push(make_pair(-dis1[dest], dest));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!sta) &#123;</span><br><span class="line"><span class="keyword">if</span> (dis2[dest] &gt; dis2[x] + weight) &#123;</span><br><span class="line">dis2[dest] = dis2[x] + weight;</span><br><span class="line">pre2[dest] = x;</span><br><span class="line">q.push(make_pair(-dis2[dest], dest));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output1</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s != cur)</span><br><span class="line">output1(s, pre1[cur]);</span><br><span class="line"><span class="keyword">if</span> (s == cur)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, cur);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d"</span>, cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output2</span><span class="params">(<span class="keyword">int</span> e, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (cur != e) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d"</span>, cur);</span><br><span class="line">cur = pre2[cur];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d"</span>, cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, s, e;<span class="comment">//车站总数 起点 终点</span></span><br><span class="line"><span class="keyword">bool</span> firstOutput = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;s, &amp;e) != EOF) &#123;</span><br><span class="line"><span class="keyword">if</span> (!firstOutput)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line"><span class="function">graph <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">G.add(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line">G.dijkstra(s, <span class="literal">true</span>);</span><br><span class="line">G.dijkstra(e, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line"><span class="keyword">int</span> ans = inf;</span><br><span class="line"><span class="keyword">int</span> d1, d2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;<span class="comment">//枚举每一条商业线</span></span><br><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line"><span class="keyword">if</span> (ans &gt; <span class="built_in">min</span>(dis1[x] + dis2[y] + z, dis2[x] + dis1[y] + z)) &#123;</span><br><span class="line">ans = <span class="built_in">min</span>(dis1[x] + dis2[y] + z, dis2[x] + dis1[y] + z);</span><br><span class="line"><span class="keyword">if</span> (dis1[x] + dis2[y] &gt; dis1[y] + dis2[x])</span><br><span class="line">swap(x, y);<span class="comment">//最终变成由s到x，y到e，便于输出</span></span><br><span class="line">d2 = x;</span><br><span class="line">d1 = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (firstOutput)</span><br><span class="line">firstOutput = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ans &lt; dis1[e]) &#123;<span class="comment">//使用了车票</span></span><br><span class="line">G.output1(s, d2);</span><br><span class="line">G.output2(e, d1);<span class="comment">//逆序输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>, d2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//没使用车票 直接输出</span></span><br><span class="line">ans = dis1[e];</span><br><span class="line">G.output1(s, e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nTicket Not Used\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;最短路径&quot;&gt;&lt;a href=&quot;#最短路径&quot; class=&quot;headerlink&quot; title=&quot;最短路径&quot;&gt;&lt;/a&gt;&lt;strong&gt;最短路径&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;猫猫快线是市民从市内去喵星机场的首选交通工具。猫猫快线分为经济线和商业线两种，线路、速度和价钱都不同。TT 有一张商业线车票，可以坐一站商业线，而其他时候只能乘坐经济线。假设换乘时间忽略不计，你的任务是找一条去喵星机场最快的线路。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Dijkstra" scheme="co10.github.io/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>预测胜负</title>
    <link href="co10.github.io/2020/04/06/%E9%A2%84%E6%B5%8B%E8%83%9C%E8%B4%9F/"/>
    <id>co10.github.io/2020/04/06/%E9%A2%84%E6%B5%8B%E8%83%9C%E8%B4%9F/</id>
    <published>2020-04-06T08:50:27.000Z</published>
    <updated>2020-04-06T14:43:57.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预测胜负"><a href="#预测胜负" class="headerlink" title="预测胜负"></a><strong>预测胜负</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">N 个人玩一个游戏，每两个人都要进行一场比赛。</span><br><span class="line">已知 M 个胜负关系，每个关系为 A B，表示 A 比 B 强， 胜负关系具有传递性。</span><br><span class="line">试问有多少场比赛的胜负无法预先得知？</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行给出数据组数。</span><br><span class="line">每组数据第一行给出 N 和 M（1 ≤ N, M ≤ 500）。</span><br><span class="line">接下来 M 行，每行给出 A B，表示 A 可以胜过 B。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于每一组数据，判断有多少场比赛的胜负不能预先得知。</span><br><span class="line">注意 (a, b) 与 (b, a) 等价，即每一个二元组只被计算一次。</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">3</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">Output: </span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit32768 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>Floyd算法：用于寻找加权图中顶点间最短路径的算法。在 n × n 的矩阵 <code>M</code> 中，<code>M[i][j]</code>表示顶点<code>i</code>到顶点<code>j</code>的距离，然后对矩阵进行 <code>n</code> 次更新，第 <code>k</code> 次更新时，如果<code>M[i][j]</code> &gt; <code>M[i][k] + M[k][j]</code>，则更新为<code>M[i][k] + M[k][j]</code>。</p><p>本题可用二维数组来表示每个人之间的胜负关系，初始时值为0，表示关系不明。<br>由于胜负关系具有传递性，比如a &gt; b, b &gt; c, 则 a &gt; c，因此可用Floyd算法更新任意两人之间的胜负关系：<br>若<code>arr[a][b] = 1</code>，则a胜b；<br>若<code>arr[a][b] = 0</code>，则a与b胜负关系不明；<br>若<code>arr[a][b] = 1</code>且<code>arr[b][c] = 1</code>，则<code>arr[a][c] = 1</code>；<br>若<code>arr[a][b] = 0</code>且<code>arr[b][a] = 0</code>，则a与b的胜负关系无法预先判断。</p><p>所以最后确定多少场无法预知结果的比赛，只需计算<code>arr[a][b] = 0 &amp;&amp; arr[b][a] == 0 &amp;&amp; a != b</code>的个数，结果再除以2即可。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i0 = <span class="number">0</span>; i0 &lt; t; i0++) &#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxN][maxN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">arr[a][b] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Floyd 算法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (arr[j][i] == <span class="number">1</span>)<span class="comment">//已知道了两人关系 再进行更新第三人</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line"><span class="keyword">if</span> (arr[i][k] == <span class="number">1</span>)</span><br><span class="line">arr[j][k] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (i != j &amp;&amp; arr[i][j] == <span class="number">0</span> &amp;&amp; arr[j][i] == <span class="number">0</span>)</span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count / <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// i 求了一遍，j 又求了一遍，所以要减半</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;预测胜负&quot;&gt;&lt;a href=&quot;#预测胜负&quot; class=&quot;headerlink&quot; title=&quot;预测胜负&quot;&gt;&lt;/a&gt;&lt;strong&gt;预测胜负&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;N 个人玩一个游戏，每两个人都要进行一场比赛。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;已知 M 个胜负关系，每个关系为 A B，表示 A 比 B 强， 胜负关系具有传递性。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;试问有多少场比赛的胜负无法预先得知？&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Floyd" scheme="co10.github.io/tags/Floyd/"/>
    
  </entry>
  
  <entry>
    <title>路径解析</title>
    <link href="co10.github.io/2020/04/03/%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90/"/>
    <id>co10.github.io/2020/04/03/%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90/</id>
    <published>2020-04-03T00:37:18.000Z</published>
    <updated>2020-04-03T02:47:36.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路径解析"><a href="#路径解析" class="headerlink" title="路径解析"></a><strong>路径解析</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在操作系统中，数据通常以文件的形式存储在文件系统中。文件系统一般采用层次化的组织形式，由目录（或者文件夹）和文件构成，形成一棵树的形状。文件有内容，用于存储数据。目录是容器，可包含文件或其他目录。同一个目录下的所有文件和目录的名字各不相同，不同目录下可以有名字相同的文件或目录。</span><br><span class="line">　　为了指定文件系统中的某个文件，需要用路径来定位。在类 Unix 系统（Linux、Max OS X、FreeBSD等）中，路径由若干部分构成，每个部分是一个目录或者文件的名字，相邻两个部分之间用 &#x2F; 符号分隔。</span><br><span class="line">　　有一个特殊的目录被称为根目录，是整个文件系统形成的这棵树的根节点，用一个单独的 &#x2F; 符号表示。在操作系统中，有当前目录的概念，表示用户目前正在工作的目录。根据出发点可以把路径分为两类：</span><br><span class="line">　　 绝对路径：以 &#x2F; 符号开头，表示从根目录开始构建的路径。</span><br><span class="line">　　 相对路径：不以 &#x2F; 符号开头，表示从当前目录开始构建的路径。</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    例如，有一个文件系统的结构如下图所示。在这个文件系统中，有根目录 &#x2F; 和其他普通目录 d1、d2、d3、d4，以及文件 f1、f2、f3、f1、f4。其中，两个 f1 是同名文件，但在不同的目录下。</span><br><span class="line">&#x2F; -+- d1 -+- f1</span><br><span class="line">   |      \- f2</span><br><span class="line">   |</span><br><span class="line">   \- d2 -+- d3 --- f3</span><br><span class="line">          |</span><br><span class="line">          +- d4 --- f1</span><br><span class="line">          |</span><br><span class="line">          \- f4</span><br><span class="line">　　对于 d4 目录下的 f1 文件，可以用绝对路径 &#x2F;d2&#x2F;d4&#x2F;f1 来指定。如果当前目录是 &#x2F;d2&#x2F;d3，这个文件也可以用相对路径 ..&#x2F;d4&#x2F;f1 来指定，这里 .. 表示上一级目录（注意，根目录的上一级目录是它本身）。还有 . 表示本目录，例如 &#x2F;d1&#x2F;.&#x2F;f1 指定的就是 &#x2F;d1&#x2F;f1。注意，如果有多个连续的 &#x2F; 出现，其效果等同于一个 &#x2F;，例如 &#x2F;d1&#x2F;&#x2F;&#x2F;f1 指定的也是 &#x2F;d1&#x2F;f1。</span><br><span class="line">　　本题会给出一些路径，要求对于每个路径，给出正规化以后的形式。一个路径经过正规化操作后，其指定的文件不变，但是会变成一个不包含 . 和 .. 的绝对路径，且不包含连续多个 &#x2F; 符号。如果一个路径以 &#x2F; 结尾，那么它代表的一定是一个目录，正规化操作要去掉结尾的 &#x2F;。若这个路径代表根目录，则正规化操作的结果是 &#x2F;。若路径为空字符串，则正规化操作的结果是当前目录。</span><br></pre></td></tr></table></figure><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一行包含一个整数 P，表示需要进行正规化操作的路径个数。</span><br><span class="line">第二行包含一个字符串，表示当前目录。</span><br><span class="line">以下 P 行，每行包含一个字符串，表示需要进行正规化操作的路径。</span><br><span class="line"></span><br><span class="line">1 ≤ P ≤ 10。</span><br><span class="line">文件和目录的名字只包含大小写字母、数字和小数点 .、减号 - 以及下划线 _。</span><br><span class="line">不会有文件或目录的名字是 . 或 .. ，它们具有题目描述中给出的特殊含义。</span><br><span class="line">输入的所有路径每个长度不超过 1000 个字符。</span><br><span class="line">输入的当前目录保证是一个经过正规化操作后的路径。</span><br><span class="line">对于前 30% 的测试用例，需要正规化的路径的组成部分不包含 . 和 .. 。</span><br><span class="line">对于前 60% 的测试用例，需要正规化的路径都是绝对路径。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共 P 行，每行一个字符串，表示经过正规化操作后的路径，顺序与输入对应。</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">input: </span><br><span class="line">7</span><br><span class="line">&#x2F;d2&#x2F;d3</span><br><span class="line">&#x2F;d2&#x2F;d4&#x2F;f1</span><br><span class="line">..&#x2F;d4&#x2F;f1</span><br><span class="line">&#x2F;d1&#x2F;.&#x2F;f1</span><br><span class="line">&#x2F;d1&#x2F;&#x2F;&#x2F;f1</span><br><span class="line">&#x2F;d1&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;d1&#x2F;..&#x2F;..&#x2F;d2</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&#x2F;d2&#x2F;d4&#x2F;f1</span><br><span class="line">&#x2F;d2&#x2F;d4&#x2F;f1</span><br><span class="line">&#x2F;d1&#x2F;f1</span><br><span class="line">&#x2F;d1&#x2F;f1</span><br><span class="line">&#x2F;d1</span><br><span class="line">&#x2F;</span><br><span class="line">&#x2F;d2</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit262144 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>题目很长，但是只要提取出以下关键点即可: </p><ol><li><code>/</code> 表示根目录</li><li><strong>绝对路径</strong>以 <code>/</code> 符号开头，表示从<strong>根目录</strong>开始构建的路径。</li><li><strong>相对路径</strong>不以 <code>/</code> 符号开头，表示从<strong>当前目录</strong>开始构建的路径。</li><li><code>..</code> 表示上一级目录，根目录的上一级目录是它<strong>本身</strong></li><li><code>/d1/./f1</code> = <code>/d1/f1</code>，即<code>/./</code> = <code>/</code></li><li><code>/d1///f1</code> = <code>/d1/f1</code>，即<code>/// = /</code></li><li>路径以 <code>/</code> 结尾，那么它代表的一定是一个目录，正规化操作要去掉结尾的 <code>/</code></li><li>若这个路径代表根目录，则正规化操作的结果是 <code>/</code></li><li>若路径为空字符串，则正规化操作的结果是当前目录</li><li>文件和目录的名字只包含大小写字母、数字和小数点 <code>.</code>、减号 <code>-</code> 以及下划线 <code>_</code>。</li><li>不会有文件或目录的名字是 <code>.</code> 或 <code>..</code> ，它们具有题目描述中给出的特殊含义。</li></ol><p>先是处理绝对路径与相对路径的问题：相对路径不以<code>/</code>开头，所以可以把相对路径变成绝对路径，即把当前路径加在相对路径前，就变成了绝对路径，接下来就变成了处理绝对路径的问题。</p><p>首先是处理多个<code>/</code>的问题，可以利用<code>/</code>将字符串分隔成多个目录或文件，储存到数组中，最后输出时再把数组元素前加上<code>/</code>即可。</p><p>然后就是处理<code>.</code>跟<code>..</code>，由于前面已经把<code>/</code>去除，结果所有字串存在数组里，接下来只要去除<code>..</code>跟上级目录、去除<code>.</code>就行。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> root, <span class="built_in">string</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] != <span class="string">'/'</span>)</span><br><span class="line">a = root + <span class="string">'/'</span> + a;<span class="comment">//相对路径变成绝对路径</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line"><span class="built_in">string</span> temp = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">bool</span> found = <span class="literal">true</span>;<span class="comment">//标记是否遇到 '/', 便于处理以 '/' 结尾</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] == <span class="string">'/'</span> || i == a.<span class="built_in">size</span>()) &#123;<span class="comment">//遇到了 '/' 或到头了</span></span><br><span class="line"><span class="keyword">if</span> (found == <span class="literal">false</span>) &#123;<span class="comment">// 不是连续出现的 '/'</span></span><br><span class="line">found = <span class="literal">true</span>;</span><br><span class="line">v.push_back(temp);</span><br><span class="line">temp.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//没遇到 '/' 就一路通行，将字符一个一个加入temp</span></span><br><span class="line">found = <span class="literal">false</span>;</span><br><span class="line">temp += a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>();) &#123;</span><br><span class="line"><span class="keyword">if</span> (v[i] == <span class="string">".."</span>) &#123;<span class="comment">//遇到了 '..'</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;<span class="comment">//擦除 '..' 和上级</span></span><br><span class="line">i--;</span><br><span class="line">v.erase(v.<span class="built_in">begin</span>() + i);</span><br><span class="line">v.erase(v.<span class="built_in">begin</span>() + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">v.erase(v.<span class="built_in">begin</span>() + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (v[i] == <span class="string">"."</span>)<span class="comment">//遇到了一个'.'</span></span><br><span class="line">v.erase(v.<span class="built_in">begin</span>() + i);<span class="comment">//直接去掉</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">i++;<span class="comment">//指针前进</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span> (v.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">res = <span class="string">"/"</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">res += <span class="string">"/"</span>;</span><br><span class="line">res+= v[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line"><span class="built_in">string</span> curr;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; curr;</span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != p; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line">getline(<span class="built_in">cin</span>, a);</span><br><span class="line"><span class="built_in">string</span> b = convert(curr, a);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;路径解析&quot;&gt;&lt;a href=&quot;#路径解析&quot; class=&quot;headerlink&quot; title=&quot;路径解析&quot;&gt;&lt;/a&gt;&lt;strong&gt;路径解析&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在操作系统中，数据通常以文件的形式存储在文件系统中。文件系统一般采用层次化的组织形式，由目录（或者文件夹）和文件构成，形成一棵树的形状。文件有内容，用于存储数据。目录是容器，可包含文件或其他目录。同一个目录下的所有文件和目录的名字各不相同，不同目录下可以有名字相同的文件或目录。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　为了指定文件系统中的某个文件，需要用路径来定位。在类 Unix 系统（Linux、Max OS X、FreeBSD等）中，路径由若干部分构成，每个部分是一个目录或者文件的名字，相邻两个部分之间用 &amp;#x2F; 符号分隔。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　有一个特殊的目录被称为根目录，是整个文件系统形成的这棵树的根节点，用一个单独的 &amp;#x2F; 符号表示。在操作系统中，有当前目录的概念，表示用户目前正在工作的目录。根据出发点可以把路径分为两类：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　 绝对路径：以 &amp;#x2F; 符号开头，表示从根目录开始构建的路径。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　 相对路径：不以 &amp;#x2F; 符号开头，表示从当前目录开始构建的路径。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="字符串处理" scheme="co10.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>扑克牌牌型</title>
    <link href="co10.github.io/2020/03/31/%E6%89%91%E5%85%8B%E7%89%8C%E7%89%8C%E5%9E%8B/"/>
    <id>co10.github.io/2020/03/31/%E6%89%91%E5%85%8B%E7%89%8C%E7%89%8C%E5%9E%8B/</id>
    <published>2020-03-31T13:47:38.000Z</published>
    <updated>2020-04-02T18:44:08.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扑克牌牌型"><a href="#扑克牌牌型" class="headerlink" title="扑克牌牌型"></a><strong>扑克牌牌型</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">有 A × B 张扑克牌。每张扑克牌有一个大小(整数，记为a，范围区间是 0 到 A - 1）和一个花色（整数，记为b，范围区间是 0 到 B - 1。</span><br><span class="line">扑克牌是互异的，也就是独一无二的，也就是说没有两张牌大小和花色都相同。</span><br><span class="line">“一手牌”的意思是你手里有5张不同的牌，这 5 张牌没有谁在前谁在后的顺序之分，它们可以形成一个牌型。 我们定义了 9 种牌型，如下是 9 种牌型的规则，我们用“低序号优先”来匹配牌型，即这“一手牌”从上到下满足的第一个牌型规则就是它的“牌型编号”（一个整数，属于1到9）:</span><br><span class="line">1. 同花顺: 同时满足规则 5 和规则 4.</span><br><span class="line">2. 炸弹 : 5张牌其中有4张牌的大小相等.</span><br><span class="line">3. 三带二 : 5张牌其中有3张牌的大小相等，且另外2张牌的大小也相等.</span><br><span class="line">4. 同花 : 5张牌都是相同花色的.</span><br><span class="line">5. 顺子 : 5张牌的大小形如 x, x + 1, x + 2, x + 3, x + 4</span><br><span class="line">6. 三条: 5张牌其中有3张牌的大小相等.</span><br><span class="line">7. 两对: 5张牌其中有2张牌的大小相等，且另外3张牌中2张牌的大小相等.</span><br><span class="line">8. 一对: 5张牌其中有2张牌的大小相等.</span><br><span class="line">9. 要不起: 这手牌不满足上述的牌型中任意一个.</span><br><span class="line">现在从A × B 张扑克牌中拿走 2 张牌，分别是 (a1, b1) 和 (a2, b2). （其中a表示大小，b表示花色），现在要从剩下的扑克牌中再随机拿出 3 张，组成一手牌。</span><br><span class="line">求在所有可能的方案中，这 9 种牌型每种牌型的方案数。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 1 行包含了整数 A 和 B (5 ≤ A ≤ 25, 1 ≤ B ≤ 4).</span><br><span class="line">第 2 行包含了整数 a1, b1, a2, b2 (0 ≤ a1, a2 ≤ A - 1, 0 ≤ b1, b2 ≤ B - 1, (a1, b1) ≠ (a2, b2)).</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行，这行有 9 个整数，每个整数代表了 9 种牌型的方案数（按牌型编号从小到大的顺序）</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">5 2</span><br><span class="line">1 0 3 1</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">0 0 0 0 8 0 12 36 0</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">25 4</span><br><span class="line">0 0 24 3</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">0 2 18 0 0 644 1656 36432 113344</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit2000 ms</span><br><span class="line">Memory limit524288 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>这是一道搜索问题，暴力<code>for</code>循环搜索就能解决，不需要用到排列组合……</p><p>本题主要有两步：求出所有组合，判断属于哪种牌型。</p><h3 id="求组合"><a href="#求组合" class="headerlink" title="求组合"></a>求组合</h3><p>本来是采用递归求出所有组合的，但是扑克牌有点数和花色，二维数组的组合枚举不会写……由于每一张牌都不同，所以把二维数组变成一维数组进行枚举，然后……不知怎么样反正就是<code>WA</code>了，判断牌型没出问题，但是找不出组合哪里出问题，纠结半天，也还是找不出来……后来看见某人发了说说才恍然大悟——这是一个搜索问题！😕</p><p>看数据比较小，25×4，多重<code>for</code>循环应该不会超时，所以后来直接暴力<code>for</code>循环求组合，但是又出现了新问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != a; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != b; j++)</span><br><span class="line"><span class="keyword">if</span> (!(i == a1 &amp;&amp; j == b1) &amp;&amp; !(i == a2 &amp;&amp; j == b2))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii = i; ii != a; ii++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span>; jj != b; jj++)</span><br><span class="line"><span class="keyword">if</span> (!(ii == a1 &amp;&amp; jj == b1) &amp;&amp; !(ii == a2 &amp;&amp; jj == b2) &amp;&amp;</span><br><span class="line">!(ii == i &amp;&amp; jj == j))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> iii = ii; iii != a; iii++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> jjj = jj; jjj != b; jjj++)</span><br><span class="line"><span class="keyword">if</span> (!(iii == a1 &amp;&amp; jjj == b1) &amp;&amp;</span><br><span class="line">!(iii == a2 &amp;&amp; jjj == b2) &amp;&amp;</span><br><span class="line">!(iii == i &amp;&amp; jjj == j) &amp;&amp;</span><br><span class="line">!(iii == ii &amp;&amp; jjj == jj)) &#123;</span><br><span class="line"><span class="function">poke <span class="title">p1</span><span class="params">(i, j)</span></span>;</span><br><span class="line">pv.push_back(p1);</span><br><span class="line"><span class="function">poke <span class="title">p2</span><span class="params">(ii, jj)</span></span>;</span><br><span class="line">pv.push_back(p2);</span><br><span class="line"><span class="function">poke <span class="title">p3</span><span class="params">(iii, jjj)</span></span>;</span><br><span class="line">pv.push_back(p3);</span><br><span class="line">sort(pv.<span class="built_in">begin</span>(), pv.<span class="built_in">end</span>(), cmp);</span><br><span class="line">pokeKind(pv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二&amp;第三大次的<code>for</code>循环无法保证选的牌这一次和下一次选的不是相反的，比如第n次选牌，第二大次<code>for</code>循环选了红桃4，第三大次<code>for</code>循环选了黑桃4；然而第n+1次选牌，第二大次<code>for</code>循环选了黑桃4，第三大次<code>for</code>循环选了红桃4……</p><p>我的改进就是每2个小次的for循环合并，<code>手牌标号%总点数 = 当前点数</code>，<code>手牌标号/总点数= 当前花色</code>，比如<code>手牌(点数, 花色): (0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), ..., (4, 0), (4, 1)</code>标号就是<code>0, 1, 2, 3, 4, 5, ..., 8, 9</code>。</p><h3 id="排序后判断牌型"><a href="#排序后判断牌型" class="headerlink" title="排序后判断牌型"></a>排序后判断牌型</h3><p>我用了5个变量：<code>int sameC, diffC</code>：几组两两连续的点数相同/不同；<code>bool colorS, Shunza</code>：是否同花/顺子；<code>int diffPos</code>：最后一次出现连续两两不等的位置。</p><p>具体见<code>pokeKind()</code>函数区分。</p><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>有时暴力一下可能出奇迹……</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poke</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">point</span>;</span><br><span class="line"><span class="keyword">int</span> color;</span><br><span class="line">poke(<span class="keyword">int</span> p, <span class="keyword">int</span> c) :<span class="built_in">point</span>(p), color(c) &#123;  &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> poke p)<span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (p.<span class="built_in">point</span> == <span class="built_in">point</span>)</span><br><span class="line"><span class="keyword">return</span> color &lt; p.color;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">point</span> &lt; p.<span class="built_in">point</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pK[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(poke a, poke b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pokeKind</span><span class="params">(<span class="built_in">vector</span>&lt;poke&gt; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sameC = <span class="number">0</span>, diffC = <span class="number">0</span>; <span class="comment">//4=; 3=&amp;2=; 3=; 2=&amp;2=; 2=</span></span><br><span class="line"><span class="keyword">int</span> diffPos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> colorS = <span class="literal">true</span>;<span class="comment">//同花</span></span><br><span class="line"><span class="keyword">bool</span> Shunza = <span class="literal">true</span>;<span class="comment">//顺子</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != v.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (v[i].<span class="built_in">point</span> == v[i + <span class="number">1</span>].<span class="built_in">point</span>)</span><br><span class="line">sameC++;</span><br><span class="line"><span class="keyword">if</span> (v[i].<span class="built_in">point</span> != v[i + <span class="number">1</span>].<span class="built_in">point</span>) &#123;</span><br><span class="line">diffC++;</span><br><span class="line">diffPos = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (colorS == <span class="literal">true</span> &amp;&amp; v[i].color != v[i + <span class="number">1</span>].color)</span><br><span class="line">colorS = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (Shunza == <span class="literal">true</span> &amp;&amp; v[i].<span class="built_in">point</span> + <span class="number">1</span> != v[i + <span class="number">1</span>].<span class="built_in">point</span>)</span><br><span class="line">Shunza = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (colorS == <span class="literal">true</span> &amp;&amp; Shunza == <span class="literal">true</span>) &#123;</span><br><span class="line">pK[<span class="number">0</span>]++;<span class="comment">//1 同花顺</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sameC == <span class="number">3</span> &amp;&amp; diffC == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (diffPos == <span class="number">0</span> || diffPos == <span class="number">3</span>)</span><br><span class="line">pK[<span class="number">1</span>]++;<span class="comment">//2 炸弹</span></span><br><span class="line"><span class="keyword">if</span> (diffPos == <span class="number">1</span> || diffPos == <span class="number">2</span>)</span><br><span class="line">pK[<span class="number">2</span>]++;<span class="comment">//3 三带二</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (colorS == <span class="literal">true</span> &amp;&amp; Shunza == <span class="literal">false</span>) &#123;</span><br><span class="line">pK[<span class="number">3</span>]++;<span class="comment">//4 同花</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (colorS == <span class="literal">false</span> &amp;&amp; Shunza == <span class="literal">true</span>) &#123;</span><br><span class="line">pK[<span class="number">4</span>]++;<span class="comment">//5 顺子</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sameC == <span class="number">2</span> &amp;&amp; diffC == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">bool</span> same3 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=v.<span class="built_in">size</span>()<span class="number">-2</span>;i++)</span><br><span class="line"><span class="keyword">if</span> (v[i].<span class="built_in">point</span> == v[i + <span class="number">2</span>].<span class="built_in">point</span>)</span><br><span class="line">same3 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (same3 == <span class="literal">true</span>)</span><br><span class="line">pK[<span class="number">5</span>]++;<span class="comment">//6 三条</span></span><br><span class="line"><span class="keyword">if</span> (same3 == <span class="literal">false</span>)</span><br><span class="line">pK[<span class="number">6</span>]++;<span class="comment">//7 两对</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sameC == <span class="number">1</span> &amp;&amp; diffC == <span class="number">3</span>) &#123;</span><br><span class="line">pK[<span class="number">7</span>]++;<span class="comment">//8 一对</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pK[<span class="number">8</span>]++;<span class="comment">//9 要不起</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a1, b1, a2, b2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; a2 &gt;&gt; b2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">pK[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != a * b - <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> ai = i % a, bi = i / a;</span><br><span class="line"><span class="keyword">if</span> (!(ai == a1 &amp;&amp; bi == b1) &amp;&amp; !(ai == a2 &amp;&amp; bi == b2)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j != a * b - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> aj = j % a, bj = j / a;</span><br><span class="line"><span class="keyword">if</span> (!(aj == a1 &amp;&amp; bj == b1) &amp;&amp; !(aj == a2 &amp;&amp; bj == b2)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k != a * b; k++) &#123;</span><br><span class="line"><span class="keyword">int</span> ak = k % a, bk = k / a;</span><br><span class="line"><span class="keyword">if</span> (!(ak == a1 &amp;&amp; bk == b1) &amp;&amp; !(ak == a2 &amp;&amp; bk == b2)) &#123;</span><br><span class="line"><span class="function">poke <span class="title">o1</span><span class="params">(a1, b1)</span></span>;</span><br><span class="line"><span class="function">poke <span class="title">o2</span><span class="params">(a2, b2)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;poke&gt; pv;</span><br><span class="line">pv.push_back(o1);</span><br><span class="line">pv.push_back(o2);</span><br><span class="line"></span><br><span class="line"><span class="function">poke <span class="title">p1</span><span class="params">(ai, bi)</span></span>;</span><br><span class="line">pv.push_back(p1);</span><br><span class="line"><span class="function">poke <span class="title">p2</span><span class="params">(aj, bj)</span></span>;</span><br><span class="line">pv.push_back(p2);</span><br><span class="line"><span class="function">poke <span class="title">p3</span><span class="params">(ak, bk)</span></span>;</span><br><span class="line">pv.push_back(p3);</span><br><span class="line">sort(pv.<span class="built_in">begin</span>(), pv.<span class="built_in">end</span>(), cmp);</span><br><span class="line">pokeKind(pv);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pK[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;扑克牌牌型&quot;&gt;&lt;a href=&quot;#扑克牌牌型&quot; class=&quot;headerlink&quot; title=&quot;扑克牌牌型&quot;&gt;&lt;/a&gt;&lt;strong&gt;扑克牌牌型&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;有 A × B 张扑克牌。每张扑克牌有一个大小(整数，记为a，范围区间是 0 到 A - 1）和一个花色（整数，记为b，范围区间是 0 到 B - 1。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;扑克牌是互异的，也就是独一无二的，也就是说没有两张牌大小和花色都相同。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;“一手牌”的意思是你手里有5张不同的牌，这 5 张牌没有谁在前谁在后的顺序之分，它们可以形成一个牌型。 我们定义了 9 种牌型，如下是 9 种牌型的规则，我们用“低序号优先”来匹配牌型，即这“一手牌”从上到下满足的第一个牌型规则就是它的“牌型编号”（一个整数，属于1到9）:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. 同花顺: 同时满足规则 5 和规则 4.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 炸弹 : 5张牌其中有4张牌的大小相等.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 三带二 : 5张牌其中有3张牌的大小相等，且另外2张牌的大小也相等.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. 同花 : 5张牌都是相同花色的.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5. 顺子 : 5张牌的大小形如 x, x + 1, x + 2, x + 3, x + 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6. 三条: 5张牌其中有3张牌的大小相等.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7. 两对: 5张牌其中有2张牌的大小相等，且另外3张牌中2张牌的大小相等.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8. 一对: 5张牌其中有2张牌的大小相等.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9. 要不起: 这手牌不满足上述的牌型中任意一个.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;现在从A × B 张扑克牌中拿走 2 张牌，分别是 (a1, b1) 和 (a2, b2). （其中a表示大小，b表示花色），现在要从剩下的扑克牌中再随机拿出 3 张，组成一手牌。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;求在所有可能的方案中，这 9 种牌型每种牌型的方案数。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="枚举" scheme="co10.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据中心</title>
    <link href="co10.github.io/2020/03/30/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/"/>
    <id>co10.github.io/2020/03/30/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/</id>
    <published>2020-03-30T13:47:01.000Z</published>
    <updated>2020-04-02T18:10:28.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a><strong>数据中心</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在一个集中式网络中，存在一个根节点，需要长时间接收其余结点传输给它的反馈数据。</span><br><span class="line">存在一个 n 结点的网络图，编号从 1 到 n。该网络的传输时全双工的，所以是无向图。如果两结点 vi, ui 相连，表明 vi, ui 之间可以互相收发数据，边权是传输数据所需时间 ti。现在每个结点需要选择一条路径将数据发送到 root 号节点。希望求出一个最优的树结构传输图，使得完成这个任务所需要的时间最少。root 结点只能接收数据，其余任何一个节点可以将数据传输给另外的一个节点，但是不能将数据传输给多个节点。所有节点可以接收多个不同节点的数据。</span><br><span class="line">一个树结构传输图的传输时间为Tmax，其中Tmax &#x3D; max(Th), h为接收点在树中的深度，Th &#x3D; max(th,j), th,j表示 j 条不同的边，这 j 条边接收点的深度都为 h。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从标准输入读入数据。</span><br><span class="line">输入的第 1 行包含一个正整数 n，保证 n ≤ 5 × 10^4</span><br><span class="line">输入的第 2 行包含一个正整数 m，保证 m ≤ 10^5。</span><br><span class="line">输入的第 3 行包含一个正整数 root，保证 root ≤ 5 × 10^4</span><br><span class="line">输入的第 4 行至第 3+m 行包含 3 个正整数 vi, ui, ti，保证 vi ≤ 5 × 10^4, ui ≤ 5 × 10^4, ti ≤ 10^6, vi ≠ ui。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出到标准输出。</span><br><span class="line">输出仅有一行，包含一个正整数 ans，表示最优的树结构流水线所耗时 Tmax。</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">1 2 3</span><br><span class="line">1 3 4</span><br><span class="line">1 4 5</span><br><span class="line">2 3 8</span><br><span class="line">3 4 2</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">1 2 3</span><br><span class="line">1 3 4</span><br><span class="line">1 4 5</span><br><span class="line">2 3 8</span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a><strong>Note</strong></h2><p><img src="https://i.loli.net/2020/04/03/juJwNGV2FL7dXm5.png" alt="image-20200403020036204.png"></p><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit524288 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p><del>本题又臭又长，题设变量花里胡哨，样例解释东拉西扯，</del>题意大致就是n个节点的带权无向图，连接每个点求总权重最小，其实就是一个最小生成树问题，可以用Kruskal算法，算法具体思路同上一篇。</p><p>就是吐槽一下test好像跑了120组，测试用了7分钟……也太多了吧，在那等着出结果等的心好慌，测那么多万一<code>WA</code>了还是啥的会崩溃的……🙃</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">305</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line">edge(<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _w) :u(_u), v(_v), w(_w) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (par[x] == x)</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;edge&gt; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> edgeCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">par[i] = i;</span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> p1 = <span class="built_in">find</span>(v[i].u);</span><br><span class="line"><span class="keyword">int</span> p2 = <span class="built_in">find</span>(v[i].v);</span><br><span class="line"><span class="keyword">if</span> (p1 != p2) &#123;</span><br><span class="line">par[p1] = p2;</span><br><span class="line">ans += v[i].w;</span><br><span class="line">edgeCount++;</span><br><span class="line"><span class="keyword">if</span> (edgeCount == n)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"><span class="function">edge <span class="title">e1</span><span class="params">(<span class="number">0</span>, i, a)</span></span>;</span><br><span class="line"><span class="function">edge <span class="title">e2</span><span class="params">(i, <span class="number">0</span>, a)</span></span>;</span><br><span class="line">v.push_back(e1);</span><br><span class="line">v.push_back(e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="function">edge <span class="title">e</span><span class="params">(i, j, a)</span></span>;</span><br><span class="line">v.push_back(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = kruskal(n, v);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据中心&quot;&gt;&lt;a href=&quot;#数据中心&quot; class=&quot;headerlink&quot; title=&quot;数据中心&quot;&gt;&lt;/a&gt;&lt;strong&gt;数据中心&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在一个集中式网络中，存在一个根节点，需要长时间接收其余结点传输给它的反馈数据。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;存在一个 n 结点的网络图，编号从 1 到 n。该网络的传输时全双工的，所以是无向图。如果两结点 vi, ui 相连，表明 vi, ui 之间可以互相收发数据，边权是传输数据所需时间 ti。现在每个结点需要选择一条路径将数据发送到 root 号节点。希望求出一个最优的树结构传输图，使得完成这个任务所需要的时间最少。root 结点只能接收数据，其余任何一个节点可以将数据传输给另外的一个节点，但是不能将数据传输给多个节点。所有节点可以接收多个不同节点的数据。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一个树结构传输图的传输时间为Tmax，其中Tmax &amp;#x3D; max(Th), h为接收点在树中的深度，Th &amp;#x3D; max(th,j), th,j表示 j 条不同的边，这 j 条边接收点的深度都为 h。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="最小生成树" scheme="co10.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="Kruskal" scheme="co10.github.io/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>农田引水</title>
    <link href="co10.github.io/2020/03/28/%E5%86%9C%E7%94%B0%E5%BC%95%E6%B0%B4/"/>
    <id>co10.github.io/2020/03/28/%E5%86%9C%E7%94%B0%E5%BC%95%E6%B0%B4/</id>
    <published>2020-03-28T13:45:59.000Z</published>
    <updated>2020-04-02T17:59:06.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="农田引水"><a href="#农田引水" class="headerlink" title="农田引水"></a><strong>农田引水</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">农田有 n 块，编号从 1~n。种田要灌水。</span><br><span class="line">众所周知东东是一个魔法师，他可以消耗一定的 MP 在一块田上施展魔法，使得黄河之水天上来。他也可以消耗一定的 MP 在两块田的渠上建立传送门，使得这块田引用那块有水的田的水。(1 ≤ n ≤ 300)</span><br><span class="line">黄河之水天上来的消耗是 Wi，i 是农田编号 (1 ≤ Wi ≤ 1e5)</span><br><span class="line">建立传送门的消耗是 Pij，i、j 是农田编号 (1 ≤ Pij ≤ 1e5, Pij &#x3D; Pji, Pii &#x3D; 0)</span><br><span class="line">求为所有的田灌水的最小消耗。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第 1 行：一个数 n</span><br><span class="line">第 2 行到第 n + 1 行：数 wi</span><br><span class="line">第 n + 2 行到第 2n + 1 行：矩阵即 pij 矩阵</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小消耗的MP值</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">0 2 2 2</span><br><span class="line">2 0 3 3</span><br><span class="line">2 3 0 4</span><br><span class="line">2 3 4 0</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit262144 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>可以将“天上来”作为源点，即第0号农田到第 i 号农田灌水需要消耗的MP值，因此样例的数组可变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 5 4 4 3</span><br><span class="line">0 2 2 25 0 2 2 2</span><br><span class="line">2 0 3 3→4 2 0 3 3</span><br><span class="line">2 3 0 4 4 2 3 0 4</span><br><span class="line">2 3 4 03 2 3 4 0</span><br></pre></td></tr></table></figure><p>本题就变成了最小生成树问题，可以用Kruskal算法:<br>将所有的边按边权升序排列，每次加入最小权的边到生成树中，保证加入的边在该连通图中，且不会生成环，直到最小生成树中的边数等于总顶点数减1。</p><p>这些权重之和就是答案。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">305</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line">edge(<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _w) :u(_u), v(_v), w(_w) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (par[x] == x)</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;edge&gt; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> edgeCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">par[i] = i;</span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> p1 = <span class="built_in">find</span>(v[i].u);</span><br><span class="line"><span class="keyword">int</span> p2 = <span class="built_in">find</span>(v[i].v);</span><br><span class="line"><span class="keyword">if</span> (p1 != p2) &#123;<span class="comment">//并查集保证不会生成环</span></span><br><span class="line">par[p1] = p2;</span><br><span class="line">ans += v[i].w;</span><br><span class="line">edgeCount++;</span><br><span class="line"><span class="keyword">if</span> (edgeCount == n)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"><span class="function">edge <span class="title">e1</span><span class="params">(<span class="number">0</span>, i, a)</span></span>;</span><br><span class="line"><span class="function">edge <span class="title">e2</span><span class="params">(i, <span class="number">0</span>, a)</span></span>;</span><br><span class="line">v.push_back(e1);</span><br><span class="line">v.push_back(e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="function">edge <span class="title">e</span><span class="params">(i, j, a)</span></span>;</span><br><span class="line">v.push_back(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = kruskal(n, v);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;农田引水&quot;&gt;&lt;a href=&quot;#农田引水&quot; class=&quot;headerlink&quot; title=&quot;农田引水&quot;&gt;&lt;/a&gt;&lt;strong&gt;农田引水&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;农田有 n 块，编号从 1~n。种田要灌水。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;众所周知东东是一个魔法师，他可以消耗一定的 MP 在一块田上施展魔法，使得黄河之水天上来。他也可以消耗一定的 MP 在两块田的渠上建立传送门，使得这块田引用那块有水的田的水。(1 ≤ n ≤ 300)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;黄河之水天上来的消耗是 Wi，i 是农田编号 (1 ≤ Wi ≤ 1e5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;建立传送门的消耗是 Pij，i、j 是农田编号 (1 ≤ Pij ≤ 1e5, Pij &amp;#x3D; Pji, Pii &amp;#x3D; 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;求为所有的田灌水的最小消耗。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="最小生成树" scheme="co10.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="Kruskal" scheme="co10.github.io/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>传染病</title>
    <link href="co10.github.io/2020/03/27/%E4%BC%A0%E6%9F%93%E7%97%85/"/>
    <id>co10.github.io/2020/03/27/%E4%BC%A0%E6%9F%93%E7%97%85/</id>
    <published>2020-03-27T13:45:38.000Z</published>
    <updated>2020-04-02T17:42:54.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="COVID-19传染病"><a href="#COVID-19传染病" class="headerlink" title="COVID-19传染病"></a><strong>COVID-19传染病</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果一个感染者走入一个群体，那么这个群体需要被隔离。</span><br><span class="line">小A同学被确诊为新冠感染，并且没有戴口罩！</span><br><span class="line">需要尽快找到所有和小A同学直接或者间接接触过的同学，将他们隔离，防止更大范围的扩散。</span><br><span class="line">众所周知，学生的交际可能是分小团体的，一位学生可能同时参与多个小团体内。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">多组数据，对于每组测试数据：</span><br><span class="line">第一行为两个整数n和m（n &#x3D; m &#x3D; 0表示输入结束，不需要处理），n 是学生的数量，m 是学生群体的数量。0 &lt; n ≤ 30000 ， 0 ≤ m ≤ 500</span><br><span class="line">学生编号为0~ n-1</span><br><span class="line">小A编号为0</span><br><span class="line">随后，m 行，每行有一个整数 num 即小团体人员数量。随后有 num 个整数代表这个小团体的学生。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出要隔离的人数，每组数据的答案输出占一行</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">100 4</span><br><span class="line">2 1 2</span><br><span class="line">5 10 13 11 12 14</span><br><span class="line">2 0 1</span><br><span class="line">2 99 2</span><br><span class="line">200 2</span><br><span class="line">1 5</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit20000 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>并查集：并：合并两个集合，将元素A作为元素B的父节点；查：确定两个元素是否属于同一集合，每次查找当前节点的父节点，直到遇到根节点，如果两个元素的根节点相同，则它们属于同一集合。</p><p>初始化每个成员都属于一个只包括自己的集合，并以自己为代表元素，然后根据题目条件逐一合并集合。</p><p>用一个<code>Rank[]</code>数组来维护集合的秩，避免“大树”挂在“小树”上面，使得树更高。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">30005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[maxN];</span><br><span class="line"><span class="keyword">int</span> Rank[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">Rank[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (par[x] == x)</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span> (x == y)<span class="comment">//同一集合</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (Rank[x] &gt; Rank[y])</span><br><span class="line">swap(x, y);<span class="comment">//避免大的挂在小的名下</span></span><br><span class="line">par[x] = y;</span><br><span class="line">Rank[x] += Rank[y];</span><br><span class="line">Rank[y] = Rank[x];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">while</span> (scanf_s(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">initial(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line"><span class="keyword">int</span> ori;</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;ori);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; num; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">unit(ori, a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = Rank[<span class="built_in">find</span>(<span class="number">0</span>)];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;COVID-19传染病&quot;&gt;&lt;a href=&quot;#COVID-19传染病&quot; class=&quot;headerlink&quot; title=&quot;COVID-19传染病&quot;&gt;&lt;/a&gt;&lt;strong&gt;COVID-19传染病&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;如果一个感染者走入一个群体，那么这个群体需要被隔离。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;小A同学被确诊为新冠感染，并且没有戴口罩！&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;需要尽快找到所有和小A同学直接或者间接接触过的同学，将他们隔离，防止更大范围的扩散。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;众所周知，学生的交际可能是分小团体的，一位学生可能同时参与多个小团体内。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="并查集" scheme="co10.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>最长网线</title>
    <link href="co10.github.io/2020/03/26/%E6%9C%80%E9%95%BF%E7%BD%91%E7%BA%BF/"/>
    <id>co10.github.io/2020/03/26/%E6%9C%80%E9%95%BF%E7%BD%91%E7%BA%BF/</id>
    <published>2020-03-26T03:06:14.000Z</published>
    <updated>2020-04-02T17:32:23.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长网线"><a href="#最长网线" class="headerlink" title="最长网线"></a><strong>最长网线</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实验室里原先有一台电脑(编号为 1 )，最近又购置了 N - 1 台电脑，编号为 2 到 N 。每台电脑都用网线连接到一台先前安装的电脑上。求第 i 台电脑到其他电脑的最大网线长度。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入文件包含多组测试数据。对于每组测试数据，第一行一个整数 N (N ≤ 10000)，接下来有 N - 1 行，每一行两个数，对于第 j 行的两个数，它们表示与 i 号电脑连接的电脑编号以及它们之间网线的长度。网线的总长度不会超过 10^9，每个数之间用一个空格隔开。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每组测试数据输出 N 行，第 i 行表示 i 号电脑的答案 (1 ≤ i ≤ N).</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">1 1</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit1000 ms</span><br><span class="line">Memory limit32768 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>每台电脑最多有2条网线相连，因此可以看成一棵树，采用邻接矩阵来储存节点。</p><p>利用DFS逐个求出每个节点的最长路径会超时，但是本题连接的网线可以看成一棵没有分支的树，是一条链，树的直径就是链长，因此可以求出链的两端点到每个节点的距离，更新最大距离即可。</p><p>树的直径：从某个点开始遍历，它能到达的终点就是直径的一个端点；再从这个得到的端点开始遍历，它能到达的终点就是直径的另一个端点。</p><p>本题进行3次DFS就能得出结果。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">edge() &#123; v = <span class="number">0</span>; w = <span class="number">0</span>; &#125;</span><br><span class="line">edge(<span class="keyword">int</span> _v, <span class="keyword">long</span> <span class="keyword">long</span> _w) :v(_v), w(_w) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; edges[maxN];</span><br><span class="line"><span class="keyword">bool</span> visit[maxN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> path[maxN];</span><br><span class="line"><span class="keyword">int</span> source;<span class="comment">//直径的端点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">long</span> <span class="keyword">long</span> length)</span> </span>&#123;</span><br><span class="line">visit[s] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges[s].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = edges[s].at(i).v;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tempW = edges[s].at(i).w;</span><br><span class="line"><span class="keyword">if</span> (!visit[temp]) &#123;</span><br><span class="line">path[temp] = <span class="built_in">max</span>(path[temp], length + tempW);</span><br><span class="line"><span class="keyword">if</span> (path[source] &lt; path[temp])</span><br><span class="line">source = temp;</span><br><span class="line">dfs(temp, length + tempW);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thePath</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">source = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line"><span class="built_in">memset</span>(path, <span class="number">0</span>, <span class="keyword">sizeof</span>(path));</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);<span class="comment">//第一次 从第一个点开始 求得直径的一个端点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">dfs(source, <span class="number">0</span>);<span class="comment">//第二次 从求得的端点开始 求得另一端点 同时更新最长路径</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">dfs(source, <span class="number">0</span>);<span class="comment">//第三次 从上一次求得的端点开始 更新最长路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, path[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (scanf_s(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b;</span><br><span class="line">scanf_s(<span class="string">"%d %lld"</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="function">edge <span class="title">e1</span><span class="params">(a, b)</span></span>;</span><br><span class="line"><span class="function">edge <span class="title">e2</span><span class="params">(i, b)</span></span>;</span><br><span class="line">edges[i].push_back(e1);</span><br><span class="line">edges[a].push_back(e2);</span><br><span class="line">&#125;</span><br><span class="line">thePath(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">edges[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;最长网线&quot;&gt;&lt;a href=&quot;#最长网线&quot; class=&quot;headerlink&quot; title=&quot;最长网线&quot;&gt;&lt;/a&gt;&lt;strong&gt;最长网线&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;实验室里原先有一台电脑(编号为 1 )，最近又购置了 N - 1 台电脑，编号为 2 到 N 。每台电脑都用网线连接到一台先前安装的电脑上。求第 i 台电脑到其他电脑的最大网线长度。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="DFS" scheme="co10.github.io/tags/DFS/"/>
    
      <category term="树的直径" scheme="co10.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="co10.github.io/2020/03/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>co10.github.io/2020/03/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2020-03-24T08:21:47.000Z</published>
    <updated>2020-04-02T17:20:28.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><strong>滑动窗口</strong></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有一个长度为 n 的数列和一个大小为 k 的窗口, 窗口可以在数列上来回移动。问在窗口从左往右滑的时候，每次窗口内数的最大值和最小值分别是多少？</span><br><span class="line">例如：数列是 [1 3 -1 -3 5 3 6 7], 其中 k 等于 3。</span><br></pre></td></tr></table></figure><a id="more"></a><table><thead><tr><th><strong>Window position</strong></th><th align="right"><strong>Minimum value</strong></th><th align="right"><strong>Maximum value</strong></th></tr></thead><tbody><tr><td><code>[1 3 -1] -3 5 3 6 7</code></td><td align="right">-1</td><td align="right">3</td></tr><tr><td><code>1 [3 -1 -3] 5 3 6 7</code></td><td align="right">-3</td><td align="right">3</td></tr><tr><td><code>1 3 [-1 -3 5] 3 6 7</code></td><td align="right">-3</td><td align="right">5</td></tr><tr><td><code>1 3 -1 [-3 5 3] 6 7</code></td><td align="right">-3</td><td align="right">5</td></tr><tr><td><code>1 3 -1 -3 [5 3 6] 7</code></td><td align="right">3</td><td align="right">6</td></tr><tr><td><code>1 3 -1 -3 5 [3 6 7]</code></td><td align="right">3</td><td align="right">7</td></tr></tbody></table><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入有两行。第一行两个整数 n 和k分别表示数列的长度和滑动窗口的大小，1 ≤ k ≤ n ≤ 1000000。</span><br><span class="line">第二行有n个整数表示数列。</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><strong>Output</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出有两行。第一行输出滑动窗口在从左到右的每个位置时，滑动窗口中的最小值。第二行是最大值。</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><strong>Sample</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input: </span><br><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br><span class="line">output: </span><br><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a><strong>Limitation</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time limit12000 ms</span><br><span class="line">Memory limit65536 kB</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><p>维护局部单调性，可以用单调队列。</p><p>求最小值可以用单调非减队列，从左往右依次入队，若入队的元素比队尾小则不断弹出队尾元素直到符合条件。当<code>队尾索引 - 队首索引 + 1 = 滑动窗口大小</code>时，队首元素弹出，此时队首元素就是最小值。</p><p>同理，求最大值用单调非增队列。</p><p>两次遍历就能求出最大最小值。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">num</span> &#123;</span><span class="comment">//记录元素值与位置</span></span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">num(<span class="keyword">int</span> x, <span class="keyword">int</span> y) :a(x), b(y) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;num&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!q.empty() &amp;&amp; q.back().a &gt;= arr[i])</span><br><span class="line">q.pop_back();<span class="comment">//队尾大于要入队的元素</span></span><br><span class="line"><span class="function">num <span class="title">x</span><span class="params">(arr[i], i)</span></span>;</span><br><span class="line">q.push_back(x);<span class="comment">//符合条件 可以入队</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) &#123;<span class="comment">//到达了窗口的宽度  队首弹出</span></span><br><span class="line"><span class="keyword">while</span> (i - q.front().b &gt; k - <span class="number">1</span>)</span><br><span class="line">q.pop_front();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, q.front().a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;num&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!q.empty() &amp;&amp; q.back().a &lt;= arr[i])</span><br><span class="line">q.pop_back();<span class="comment">//队尾小于要入队的元素</span></span><br><span class="line"><span class="function">num <span class="title">x</span><span class="params">(arr[i], i)</span></span>;</span><br><span class="line">q.push_back(x);<span class="comment">//符合条件 可以入队</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) &#123;<span class="comment">//到达了窗口的宽度  队首弹出</span></span><br><span class="line"><span class="keyword">while</span> (i - q.front().b &gt; k - <span class="number">1</span>)</span><br><span class="line">q.pop_front();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, q.front().a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">scanf_s(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">getMin(arr, n, k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">getMax(arr, n, k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;&lt;strong&gt;滑动窗口&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;有一个长度为 n 的数列和一个大小为 k 的窗口, 窗口可以在数列上来回移动。问在窗口从左往右滑的时候，每次窗口内数的最大值和最小值分别是多少？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如：数列是 [1 3 -1 -3 5 3 6 7], 其中 k 等于 3。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="单调队列" scheme="co10.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
